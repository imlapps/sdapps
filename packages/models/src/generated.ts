import type * as rdfjs from "@rdfjs/types";
import { sha256 } from "js-sha256";
import N3, { DataFactory as dataFactory } from "n3";
import * as purify from "purify-ts";
import * as rdfLiteral from "rdf-literal";
import * as rdfjsResource from "rdfjs-resource";
import * as sparqljs from "sparqljs";
import { z as zod } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";
export type $EqualsResult = purify.Either<$EqualsResult.Unequal, true>;

export namespace $EqualsResult {
  export const Equal: $EqualsResult = purify.Either.of<Unequal, true>(true);

  export function fromBooleanEqualsResult(
    left: any,
    right: any,
    equalsResult: boolean | $EqualsResult,
  ): $EqualsResult {
    if (typeof equalsResult !== "boolean") {
      return equalsResult;
    }

    if (equalsResult) {
      return Equal;
    }

    return purify.Left({ left, right, type: "BooleanEquals" });
  }

  export type Unequal =
    | {
        readonly left: {
          readonly array: readonly any[];
          readonly element: any;
          readonly elementIndex: number;
        };
        readonly right: {
          readonly array: readonly any[];
          readonly unequals: readonly Unequal[];
        };
        readonly type: "ArrayElement";
      }
    | {
        readonly left: readonly any[];
        readonly right: readonly any[];
        readonly type: "ArrayLength";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "BooleanEquals";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "LeftError";
      }
    | {
        readonly right: any;
        readonly type: "LeftNull";
      }
    | {
        readonly left: bigint | boolean | number | string;
        readonly right: bigint | boolean | number | string;
        readonly type: "Primitive";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly propertyName: string;
        readonly propertyValuesUnequal: Unequal;
        readonly type: "Property";
      }
    | {
        readonly left: any;
        readonly right: any;
        readonly type: "RightError";
      }
    | {
        readonly left: any;
        readonly type: "RightNull";
      };
}
export namespace $RdfVocabularies {
  export namespace rdf {
    export const first = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
    );
    export const nil = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil",
    );
    export const rest = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
    );
    export const subject = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
    );
    export const type = dataFactory.namedNode(
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    );
  }

  export namespace rdfs {
    export const subClassOf = dataFactory.namedNode(
      "http://www.w3.org/2000/01/rdf-schema#subClassOf",
    );
  }

  export namespace xsd {
    export const boolean = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#boolean",
    );
    export const date = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#date",
    );
    export const dateTime = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#dateTime",
    );
    export const integer = dataFactory.namedNode(
      "http://www.w3.org/2001/XMLSchema#integer",
    );
  }
}
/**
 * Compare two objects with equals(other: T): boolean methods and return an $EqualsResult.
 */
export function $booleanEquals<T extends { equals: (other: T) => boolean }>(
  left: T,
  right: T,
): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(left, right, left.equals(right));
}
/**
 * Compare two values for strict equality (===), returning an $EqualsResult rather than a boolean.
 */
export function $strictEquals<T extends bigint | boolean | number | string>(
  left: T,
  right: T,
): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(left, right, left === right);
}
/**
 * A sparqljs.Pattern that's the equivalent of ?subject rdf:type/rdfs:subClassOf* ?rdfType .
 */
export function $sparqlInstancesOfPattern({
  rdfType,
  subject,
}: {
  rdfType: rdfjs.NamedNode;
  subject: sparqljs.Triple["subject"];
}): sparqljs.Pattern {
  return {
    triples: [
      {
        subject,
        predicate: {
          items: [
            $RdfVocabularies.rdf.type,
            {
              items: [$RdfVocabularies.rdfs.subClassOf],
              pathType: "*",
              type: "path",
            },
          ],
          pathType: "/",
          type: "path",
        },
        object: rdfType,
      },
    ],
    type: "bgp",
  };
}
type $UnwrapR<T> = T extends purify.Either<any, infer R> ? R : never;
export function $arrayEquals<T>(
  leftArray: readonly T[],
  rightArray: readonly T[],
  elementEquals: (left: T, right: T) => boolean | $EqualsResult,
): $EqualsResult {
  if (leftArray.length !== rightArray.length) {
    return purify.Left({
      left: leftArray,
      right: rightArray,
      type: "ArrayLength",
    });
  }

  for (
    let leftElementIndex = 0;
    leftElementIndex < leftArray.length;
    leftElementIndex++
  ) {
    const leftElement = leftArray[leftElementIndex];

    const rightUnequals: $EqualsResult.Unequal[] = [];
    for (
      let rightElementIndex = 0;
      rightElementIndex < rightArray.length;
      rightElementIndex++
    ) {
      const rightElement = rightArray[rightElementIndex];

      const leftElementEqualsRightElement =
        $EqualsResult.fromBooleanEqualsResult(
          leftElement,
          rightElement,
          elementEquals(leftElement, rightElement),
        );
      if (leftElementEqualsRightElement.isRight()) {
        break; // left element === right element, break out of the right iteration
      }
      rightUnequals.push(
        leftElementEqualsRightElement.extract() as $EqualsResult.Unequal,
      );
    }

    if (rightUnequals.length === rightArray.length) {
      // All right elements were unequal to the left element
      return purify.Left({
        left: {
          array: leftArray,
          element: leftElement,
          elementIndex: leftElementIndex,
        },
        right: {
          array: rightArray,
          unequals: rightUnequals,
        },
        type: "ArrayElement",
      });
    }
    // Else there was a right element equal to the left element, continue to the next left element
  }

  return $EqualsResult.Equal;
}
export function $maybeEquals<T>(
  leftMaybe: purify.Maybe<T>,
  rightMaybe: purify.Maybe<T>,
  valueEquals: (left: T, right: T) => boolean | $EqualsResult,
): $EqualsResult {
  if (leftMaybe.isJust()) {
    if (rightMaybe.isJust()) {
      return $EqualsResult.fromBooleanEqualsResult(
        leftMaybe,
        rightMaybe,
        valueEquals(leftMaybe.unsafeCoerce(), rightMaybe.unsafeCoerce()),
      );
    }
    return purify.Left({
      left: leftMaybe.unsafeCoerce(),
      type: "RightNull",
    });
  }

  if (rightMaybe.isJust()) {
    return purify.Left({
      right: rightMaybe.unsafeCoerce(),
      type: "LeftNull",
    });
  }

  return $EqualsResult.Equal;
}
/**
 * Compare two Dates and return an $EqualsResult.
 */
export function $dateEquals(left: Date, right: Date): $EqualsResult {
  return $EqualsResult.fromBooleanEqualsResult(
    left,
    right,
    left.getTime() === right.getTime(),
  );
}
export abstract class Model {
  abstract readonly $identifier: ModelStatic.$Identifier;
  abstract readonly $type:
    | "Action"
    | "ActionStub"
    | "Article"
    | "ArticleStub"
    | "AssessAction"
    | "AssessActionStub"
    | "BroadcastEvent"
    | "BroadcastEventStub"
    | "BroadcastService"
    | "BroadcastServiceStub"
    | "ChooseAction"
    | "ChooseActionStub"
    | "CreativeWork"
    | "CreativeWorkSeries"
    | "CreativeWorkSeriesStub"
    | "CreativeWorkStub"
    | "Enumeration"
    | "Episode"
    | "EpisodeStub"
    | "Event"
    | "EventStub"
    | "GenderType"
    | "ImageObject"
    | "ImageObjectStub"
    | "Intangible"
    | "IntangibleStub"
    | "Invoice"
    | "InvoiceStub"
    | "ItemList"
    | "ItemListStub"
    | "ListItem"
    | "ListItemStub"
    | "MediaObject"
    | "MediaObjectStub"
    | "Message"
    | "MessageStub"
    | "MonetaryAmount"
    | "MonetaryAmountStub"
    | "MusicAlbum"
    | "MusicAlbumStub"
    | "MusicArtistRoleStub"
    | "MusicComposition"
    | "MusicCompositionStub"
    | "MusicGroup"
    | "MusicGroupStub"
    | "MusicPlaylist"
    | "MusicPlaylistStub"
    | "MusicRecording"
    | "MusicRecordingStub"
    | "OccupationStub"
    | "Order"
    | "OrderStub"
    | "Organization"
    | "OrganizationStub"
    | "PerformingGroup"
    | "PerformingGroupStub"
    | "Person"
    | "PersonStub"
    | "Place"
    | "PlaceStub"
    | "PublicationEvent"
    | "PublicationEventStub"
    | "QuantitativeValue"
    | "QuantitativeValueStub"
    | "RadioBroadcastService"
    | "RadioBroadcastServiceStub"
    | "RadioEpisode"
    | "RadioEpisodeStub"
    | "RadioSeries"
    | "RadioSeriesStub"
    | "Report"
    | "ReportStub"
    | "RoleStub"
    | "Service"
    | "ServiceStub"
    | "StructuredValue"
    | "StructuredValueStub"
    | "TextObject"
    | "TextObjectStub"
    | "Thing"
    | "ThingStub"
    | "VoteAction"
    | "VoteActionStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(_parameters: object) {}

  $equals(other: Model): $EqualsResult {
    return $booleanEquals(this.$identifier, other.$identifier)
      .mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "$identifier",
        propertyValuesUnequal,
        type: "Property" as const,
      }))
      .chain(() =>
        $strictEquals(this.$type, other.$type).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "$type",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    _hasher.update(this.$identifier.value);
    _hasher.update(this.$type);
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    return _hasher;
  }

  $toJson(): ModelStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        "@id":
          this.$identifier.termType === "BlankNode"
            ? `_:${this.$identifier.value}`
            : this.$identifier.value,
        $type: this.$type,
      } satisfies ModelStatic.$Json),
    );
  }

  $toRdf({
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = resourceSet.mutableResource(this.$identifier, {
      mutateGraph,
    });
    return _resource;
  }

  toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ModelStatic {
  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory: dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = {
    readonly "@id": string;
    readonly $type:
      | "Action"
      | "ActionStub"
      | "Article"
      | "ArticleStub"
      | "AssessAction"
      | "AssessActionStub"
      | "BroadcastEvent"
      | "BroadcastEventStub"
      | "BroadcastService"
      | "BroadcastServiceStub"
      | "ChooseAction"
      | "ChooseActionStub"
      | "CreativeWork"
      | "CreativeWorkSeries"
      | "CreativeWorkSeriesStub"
      | "CreativeWorkStub"
      | "Enumeration"
      | "Episode"
      | "EpisodeStub"
      | "Event"
      | "EventStub"
      | "GenderType"
      | "ImageObject"
      | "ImageObjectStub"
      | "Intangible"
      | "IntangibleStub"
      | "Invoice"
      | "InvoiceStub"
      | "ItemList"
      | "ItemListStub"
      | "ListItem"
      | "ListItemStub"
      | "MediaObject"
      | "MediaObjectStub"
      | "Message"
      | "MessageStub"
      | "MonetaryAmount"
      | "MonetaryAmountStub"
      | "MusicAlbum"
      | "MusicAlbumStub"
      | "MusicArtistRoleStub"
      | "MusicComposition"
      | "MusicCompositionStub"
      | "MusicGroup"
      | "MusicGroupStub"
      | "MusicPlaylist"
      | "MusicPlaylistStub"
      | "MusicRecording"
      | "MusicRecordingStub"
      | "OccupationStub"
      | "Order"
      | "OrderStub"
      | "Organization"
      | "OrganizationStub"
      | "PerformingGroup"
      | "PerformingGroupStub"
      | "Person"
      | "PersonStub"
      | "Place"
      | "PlaceStub"
      | "PublicationEvent"
      | "PublicationEventStub"
      | "QuantitativeValue"
      | "QuantitativeValueStub"
      | "RadioBroadcastService"
      | "RadioBroadcastServiceStub"
      | "RadioEpisode"
      | "RadioEpisodeStub"
      | "RadioSeries"
      | "RadioSeriesStub"
      | "Report"
      | "ReportStub"
      | "RoleStub"
      | "Service"
      | "ServiceStub"
      | "StructuredValue"
      | "StructuredValueStub"
      | "TextObject"
      | "TextObjectStub"
      | "Thing"
      | "ThingStub"
      | "VoteAction"
      | "VoteActionStub";
  };

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ $identifier });
  }

  export function $fromJson(json: unknown): purify.Either<zod.ZodError, Model> {
    return (
      ThingStubStatic.$fromJson(json) as purify.Either<zod.ZodError, Model>
    ).altLazy(
      () => ThingStatic.$fromJson(json) as purify.Either<zod.ZodError, Model>,
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        {
          label: "Identifier",
          scope: `${scopePrefix}/properties/@id`,
          type: "Control",
        },
        {
          rule: {
            condition: {
              schema: { const: "Model" },
              scope: `${scopePrefix}/properties/$type`,
            },
            effect: "HIDE",
          },
          scope: `${scopePrefix}/properties/$type`,
          type: "Control",
        },
      ],
      label: "Model",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return zod.object({
      "@id": zod.string().min(1),
      $type: zod.enum([
        "Action",
        "ActionStub",
        "Article",
        "ArticleStub",
        "AssessAction",
        "AssessActionStub",
        "BroadcastEvent",
        "BroadcastEventStub",
        "BroadcastService",
        "BroadcastServiceStub",
        "ChooseAction",
        "ChooseActionStub",
        "CreativeWork",
        "CreativeWorkSeries",
        "CreativeWorkSeriesStub",
        "CreativeWorkStub",
        "Enumeration",
        "Episode",
        "EpisodeStub",
        "Event",
        "EventStub",
        "GenderType",
        "ImageObject",
        "ImageObjectStub",
        "Intangible",
        "IntangibleStub",
        "Invoice",
        "InvoiceStub",
        "ItemList",
        "ItemListStub",
        "ListItem",
        "ListItemStub",
        "MediaObject",
        "MediaObjectStub",
        "Message",
        "MessageStub",
        "MonetaryAmount",
        "MonetaryAmountStub",
        "MusicAlbum",
        "MusicAlbumStub",
        "MusicArtistRoleStub",
        "MusicComposition",
        "MusicCompositionStub",
        "MusicGroup",
        "MusicGroupStub",
        "MusicPlaylist",
        "MusicPlaylistStub",
        "MusicRecording",
        "MusicRecordingStub",
        "OccupationStub",
        "Order",
        "OrderStub",
        "Organization",
        "OrganizationStub",
        "PerformingGroup",
        "PerformingGroupStub",
        "Person",
        "PersonStub",
        "Place",
        "PlaceStub",
        "PublicationEvent",
        "PublicationEventStub",
        "QuantitativeValue",
        "QuantitativeValueStub",
        "RadioBroadcastService",
        "RadioBroadcastServiceStub",
        "RadioEpisode",
        "RadioEpisodeStub",
        "RadioSeries",
        "RadioSeriesStub",
        "Report",
        "ReportStub",
        "RoleStub",
        "Service",
        "ServiceStub",
        "StructuredValue",
        "StructuredValueStub",
        "TextObject",
        "TextObjectStub",
        "Thing",
        "ThingStub",
        "VoteAction",
        "VoteActionStub",
      ]),
    });
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode }
  > {
    const $identifier: ModelStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ModelStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Model> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      ThingStubStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Model
      >
    ).altLazy(
      () =>
        ThingStatic.$fromRdf(otherParameters) as purify.Either<
          rdfjsResource.Resource.ValueError,
          Model
        >,
    );
  }

  export const $properties = {};

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ModelStatic.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ModelStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ModelStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [];
  }

  export function $sparqlWherePatterns(_parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [];
  }
}
export class Thing extends Model {
  protected _$identifier: ThingStatic.$Identifier | undefined;
  override readonly $type:
    | "Thing"
    | "Action"
    | "Article"
    | "AssessAction"
    | "BroadcastEvent"
    | "BroadcastService"
    | "ChooseAction"
    | "CreativeWork"
    | "CreativeWorkSeries"
    | "Enumeration"
    | "Episode"
    | "Event"
    | "GenderType"
    | "ImageObject"
    | "Intangible"
    | "Invoice"
    | "ItemList"
    | "ListItem"
    | "MediaObject"
    | "Message"
    | "MonetaryAmount"
    | "MusicAlbum"
    | "MusicComposition"
    | "MusicGroup"
    | "MusicPlaylist"
    | "MusicRecording"
    | "Order"
    | "Organization"
    | "PerformingGroup"
    | "Person"
    | "Place"
    | "PublicationEvent"
    | "QuantitativeValue"
    | "RadioBroadcastService"
    | "RadioEpisode"
    | "RadioSeries"
    | "Report"
    | "Service"
    | "StructuredValue"
    | "TextObject"
    | "VoteAction" = "Thing";
  readonly alternateNames: readonly string[];
  readonly description: purify.Maybe<string>;
  readonly disambiguatingDescription: purify.Maybe<string>;
  readonly identifiers: readonly string[];
  readonly images: readonly ImageObjectStub[];
  readonly name: purify.Maybe<string>;
  readonly order: purify.Maybe<number>;
  readonly sameAs: readonly rdfjs.NamedNode[];
  readonly subjectOf: readonly (CreativeWorkStub | EventStub)[];
  readonly url: purify.Maybe<rdfjs.NamedNode>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly alternateNames?: readonly string[];
      readonly description?: purify.Maybe<string> | string;
      readonly disambiguatingDescription?: purify.Maybe<string> | string;
      readonly identifiers?: readonly string[];
      readonly images?: readonly ImageObjectStub[];
      readonly name?: purify.Maybe<string> | string;
      readonly order?: number | purify.Maybe<number>;
      readonly sameAs?: readonly rdfjs.NamedNode[];
      readonly subjectOf?: readonly (CreativeWorkStub | EventStub)[];
      readonly url?: rdfjs.NamedNode | purify.Maybe<rdfjs.NamedNode> | string;
    } & ConstructorParameters<typeof Model>[0],
  ) {
    super(parameters);
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (typeof parameters.alternateNames === "undefined") {
      this.alternateNames = [];
    } else if (typeof parameters.alternateNames === "object") {
      this.alternateNames = parameters.alternateNames;
    } else {
      this.alternateNames = parameters.alternateNames satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.description)) {
      this.description = parameters.description;
    } else if (typeof parameters.description === "string") {
      this.description = purify.Maybe.of(parameters.description);
    } else if (typeof parameters.description === "undefined") {
      this.description = purify.Maybe.empty();
    } else {
      this.description = parameters.description satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.disambiguatingDescription)) {
      this.disambiguatingDescription = parameters.disambiguatingDescription;
    } else if (typeof parameters.disambiguatingDescription === "string") {
      this.disambiguatingDescription = purify.Maybe.of(
        parameters.disambiguatingDescription,
      );
    } else if (typeof parameters.disambiguatingDescription === "undefined") {
      this.disambiguatingDescription = purify.Maybe.empty();
    } else {
      this.disambiguatingDescription =
        parameters.disambiguatingDescription satisfies never;
    }

    if (typeof parameters.identifiers === "undefined") {
      this.identifiers = [];
    } else if (typeof parameters.identifiers === "object") {
      this.identifiers = parameters.identifiers;
    } else {
      this.identifiers = parameters.identifiers satisfies never;
    }

    if (typeof parameters.images === "undefined") {
      this.images = [];
    } else if (typeof parameters.images === "object") {
      this.images = parameters.images;
    } else {
      this.images = parameters.images satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.name)) {
      this.name = parameters.name;
    } else if (typeof parameters.name === "string") {
      this.name = purify.Maybe.of(parameters.name);
    } else if (typeof parameters.name === "undefined") {
      this.name = purify.Maybe.empty();
    } else {
      this.name = parameters.name satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.order)) {
      this.order = parameters.order;
    } else if (typeof parameters.order === "number") {
      this.order = purify.Maybe.of(parameters.order);
    } else if (typeof parameters.order === "undefined") {
      this.order = purify.Maybe.empty();
    } else {
      this.order = parameters.order satisfies never;
    }

    if (typeof parameters.sameAs === "undefined") {
      this.sameAs = [];
    } else if (typeof parameters.sameAs === "object") {
      this.sameAs = parameters.sameAs;
    } else {
      this.sameAs = parameters.sameAs satisfies never;
    }

    if (typeof parameters.subjectOf === "undefined") {
      this.subjectOf = [];
    } else if (typeof parameters.subjectOf === "object") {
      this.subjectOf = parameters.subjectOf.concat();
    } else {
      this.subjectOf = parameters.subjectOf satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.url)) {
      this.url = parameters.url;
    } else if (typeof parameters.url === "object") {
      this.url = purify.Maybe.of(parameters.url);
    } else if (typeof parameters.url === "string") {
      this.url = purify.Maybe.of(dataFactory.namedNode(parameters.url));
    } else if (typeof parameters.url === "undefined") {
      this.url = purify.Maybe.empty();
    } else {
      this.url = parameters.url satisfies never;
    }
  }

  override get $identifier(): ThingStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: Thing): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.alternateNames,
          other.alternateNames,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "alternateNames",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.description,
          other.description,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "description",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.disambiguatingDescription,
          other.disambiguatingDescription,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "disambiguatingDescription",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $strictEquals))(
          this.identifiers,
          other.identifiers,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "identifiers",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.images,
          other.images,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "images",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.name,
          other.name,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "name",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.order,
          other.order,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "order",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.sameAs,
          other.sameAs,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "sameAs",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left: CreativeWorkStub | EventStub,
              right: CreativeWorkStub | EventStub,
            ) => {
              if (
                left.$type === "CreativeWorkStub" &&
                right.$type === "CreativeWorkStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "ArticleStub" &&
                right.$type === "ArticleStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "CreativeWorkSeriesStub" &&
                right.$type === "CreativeWorkSeriesStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "EpisodeStub" &&
                right.$type === "EpisodeStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "ImageObjectStub" &&
                right.$type === "ImageObjectStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "MediaObjectStub" &&
                right.$type === "MediaObjectStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "MessageStub" &&
                right.$type === "MessageStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "MusicAlbumStub" &&
                right.$type === "MusicAlbumStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "MusicCompositionStub" &&
                right.$type === "MusicCompositionStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "MusicPlaylistStub" &&
                right.$type === "MusicPlaylistStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "MusicRecordingStub" &&
                right.$type === "MusicRecordingStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "RadioEpisodeStub" &&
                right.$type === "RadioEpisodeStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "RadioSeriesStub" &&
                right.$type === "RadioSeriesStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (left.$type === "ReportStub" && right.$type === "ReportStub") {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "TextObjectStub" &&
                right.$type === "TextObjectStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (left.$type === "EventStub" && right.$type === "EventStub") {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "BroadcastEventStub" &&
                right.$type === "BroadcastEventStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "PublicationEventStub" &&
                right.$type === "PublicationEventStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.subjectOf, other.subjectOf).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "subjectOf",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.url,
          other.url,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "url",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.alternateNames) {
      _hasher.update(_item0);
    }

    this.description.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.disambiguatingDescription.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    for (const _item0 of this.identifiers) {
      _hasher.update(_item0);
    }

    for (const _item0 of this.images) {
      _item0.$hash(_hasher);
    }

    this.name.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.order.ifJust((_value0) => {
      _hasher.update(_value0.toString());
    });
    for (const _item0 of this.sameAs) {
      _hasher.update(_item0.termType);
      _hasher.update(_item0.value);
    }

    for (const _item0 of this.subjectOf) {
      switch (_item0.$type) {
        case "CreativeWorkStub":
        case "ArticleStub":
        case "CreativeWorkSeriesStub":
        case "EpisodeStub":
        case "ImageObjectStub":
        case "MediaObjectStub":
        case "MessageStub":
        case "MusicAlbumStub":
        case "MusicCompositionStub":
        case "MusicPlaylistStub":
        case "MusicRecordingStub":
        case "RadioEpisodeStub":
        case "RadioSeriesStub":
        case "ReportStub":
        case "TextObjectStub": {
          _item0.$hash(_hasher);
          break;
        }
        case "EventStub":
        case "BroadcastEventStub":
        case "PublicationEventStub": {
          _item0.$hash(_hasher);
          break;
        }
        default:
          _item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    this.url.ifJust((_value0) => {
      _hasher.update(_value0.termType);
      _hasher.update(_value0.value);
    });
    return _hasher;
  }

  override $toJson(): ThingStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        alternateNames: this.alternateNames.map((_item) => _item),
        description: this.description.map((_item) => _item).extract(),
        disambiguatingDescription: this.disambiguatingDescription
          .map((_item) => _item)
          .extract(),
        identifiers: this.identifiers.map((_item) => _item),
        images: this.images.map((_item) => _item.$toJson()),
        name: this.name.map((_item) => _item).extract(),
        order: this.order.map((_item) => _item).extract(),
        sameAs: this.sameAs.map((_item) => ({ "@id": _item.value })),
        subjectOf: this.subjectOf.map((_item) =>
          _item.$type === "EventStub" ||
          _item.$type === "BroadcastEventStub" ||
          _item.$type === "PublicationEventStub"
            ? _item.$toJson()
            : _item.$toJson(),
        ),
        url: this.url.map((_item) => ({ "@id": _item.value })).extract(),
      } satisfies ThingStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Thing"),
      );
    }

    _resource.add(
      ThingStatic.$properties.alternateNames["identifier"],
      this.alternateNames.map((_item) => _item),
    );
    _resource.add(
      ThingStatic.$properties.description["identifier"],
      this.description,
    );
    _resource.add(
      ThingStatic.$properties.disambiguatingDescription["identifier"],
      this.disambiguatingDescription,
    );
    _resource.add(
      ThingStatic.$properties.identifiers["identifier"],
      this.identifiers.map((_item) => _item),
    );
    _resource.add(
      ThingStatic.$properties.images["identifier"],
      this.images.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(ThingStatic.$properties.name["identifier"], this.name);
    _resource.add(ThingStatic.$properties.order["identifier"], this.order);
    _resource.add(
      ThingStatic.$properties.sameAs["identifier"],
      this.sameAs.map((_item) => _item),
    );
    _resource.add(
      ThingStatic.$properties.subjectOf["identifier"],
      this.subjectOf.map((_item) =>
        _item.$type === "EventStub" ||
        _item.$type === "BroadcastEventStub" ||
        _item.$type === "PublicationEventStub"
          ? _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
          : _item.$toRdf({
              mutateGraph: mutateGraph,
              resourceSet: resourceSet,
            }),
      ),
    );
    _resource.add(ThingStatic.$properties.url["identifier"], this.url);
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ThingStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Thing",
  );
  export type $Identifier = ModelStatic.$Identifier;
  export const $Identifier = ModelStatic.$Identifier;
  export type $Json = {
    readonly alternateNames: readonly string[];
    readonly description: string | undefined;
    readonly disambiguatingDescription: string | undefined;
    readonly identifiers: readonly string[];
    readonly images: readonly ImageObjectStub.$Json[];
    readonly name: string | undefined;
    readonly order: number | undefined;
    readonly sameAs: readonly { readonly "@id": string }[];
    readonly subjectOf: readonly (
      | CreativeWorkStubStatic.$Json
      | EventStubStatic.$Json
    )[];
    readonly url: { readonly "@id": string } | undefined;
  } & ModelStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      alternateNames: readonly string[];
      description: purify.Maybe<string>;
      disambiguatingDescription: purify.Maybe<string>;
      identifiers: readonly string[];
      images: readonly ImageObjectStub[];
      name: purify.Maybe<string>;
      order: purify.Maybe<number>;
      sameAs: readonly rdfjs.NamedNode[];
      subjectOf: readonly (CreativeWorkStub | EventStub)[];
      url: purify.Maybe<rdfjs.NamedNode>;
    } & $UnwrapR<ReturnType<typeof ModelStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ModelStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const alternateNames = _jsonObject["alternateNames"];
    const description = purify.Maybe.fromNullable(_jsonObject["description"]);
    const disambiguatingDescription = purify.Maybe.fromNullable(
      _jsonObject["disambiguatingDescription"],
    );
    const identifiers = _jsonObject["identifiers"];
    const images = _jsonObject["images"].map((_item) =>
      ImageObjectStub.$fromJson(_item).unsafeCoerce(),
    );
    const name = purify.Maybe.fromNullable(_jsonObject["name"]);
    const order = purify.Maybe.fromNullable(_jsonObject["order"]);
    const sameAs = _jsonObject["sameAs"].map((_item) =>
      dataFactory.namedNode(_item["@id"]),
    );
    const subjectOf = _jsonObject["subjectOf"].map((_item) =>
      _item.$type === "EventStub" ||
      _item.$type === "BroadcastEventStub" ||
      _item.$type === "PublicationEventStub"
        ? EventStubStatic.$fromJson(_item).unsafeCoerce()
        : CreativeWorkStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    const url = purify.Maybe.fromNullable(_jsonObject["url"]).map((_item) =>
      dataFactory.namedNode(_item["@id"]),
    );
    return purify.Either.of({
      ...$super0,
      $identifier,
      alternateNames,
      description,
      disambiguatingDescription,
      identifiers,
      images,
      name,
      order,
      sameAs,
      subjectOf,
      url,
    });
  }

  export function $fromJson(json: unknown): purify.Either<zod.ZodError, Thing> {
    return (ActionStatic.$fromJson(json) as purify.Either<zod.ZodError, Thing>)
      .altLazy(
        () =>
          CreativeWorkStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            Thing
          >,
      )
      .altLazy(
        () => EventStatic.$fromJson(json) as purify.Either<zod.ZodError, Thing>,
      )
      .altLazy(
        () =>
          IntangibleStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            Thing
          >,
      )
      .altLazy(
        () =>
          OrganizationStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            Thing
          >,
      )
      .altLazy(
        () => Person.$fromJson(json) as purify.Either<zod.ZodError, Thing>,
      )
      .altLazy(
        () => Place.$fromJson(json) as purify.Either<zod.ZodError, Thing>,
      )
      .altLazy(() =>
        $propertiesFromJson(json).map((properties) => new Thing(properties)),
      );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ModelStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/alternateNames`, type: "Control" },
        { scope: `${scopePrefix}/properties/description`, type: "Control" },
        {
          scope: `${scopePrefix}/properties/disambiguatingDescription`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/identifiers`, type: "Control" },
        ImageObjectStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/images`,
        }),
        { scope: `${scopePrefix}/properties/name`, type: "Control" },
        { scope: `${scopePrefix}/properties/order`, type: "Control" },
        { scope: `${scopePrefix}/properties/sameAs`, type: "Control" },
        { scope: `${scopePrefix}/properties/subjectOf`, type: "Control" },
        { scope: `${scopePrefix}/properties/url`, type: "Control" },
      ],
      label: "Thing",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ModelStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "Thing",
          "Action",
          "Article",
          "AssessAction",
          "BroadcastEvent",
          "BroadcastService",
          "ChooseAction",
          "CreativeWork",
          "CreativeWorkSeries",
          "Enumeration",
          "Episode",
          "Event",
          "GenderType",
          "ImageObject",
          "Intangible",
          "Invoice",
          "ItemList",
          "ListItem",
          "MediaObject",
          "Message",
          "MonetaryAmount",
          "MusicAlbum",
          "MusicComposition",
          "MusicGroup",
          "MusicPlaylist",
          "MusicRecording",
          "Order",
          "Organization",
          "PerformingGroup",
          "Person",
          "Place",
          "PublicationEvent",
          "QuantitativeValue",
          "RadioBroadcastService",
          "RadioEpisode",
          "RadioSeries",
          "Report",
          "Service",
          "StructuredValue",
          "TextObject",
          "VoteAction",
        ]),
        alternateNames: zod
          .string()
          .array()
          .default(() => []),
        description: zod.string().optional(),
        disambiguatingDescription: zod.string().optional(),
        identifiers: zod
          .string()
          .array()
          .default(() => []),
        images: ImageObjectStub.$jsonZodSchema()
          .array()
          .default(() => []),
        name: zod.string().optional(),
        order: zod.number().optional(),
        sameAs: zod
          .object({ "@id": zod.string().min(1) })
          .array()
          .default(() => []),
        subjectOf: zod
          .discriminatedUnion("$type", [
            CreativeWorkStubStatic.$jsonZodSchema(),
            EventStubStatic.$jsonZodSchema(),
          ])
          .array()
          .default(() => []),
        url: zod.object({ "@id": zod.string().min(1) }).optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      alternateNames: readonly string[];
      description: purify.Maybe<string>;
      disambiguatingDescription: purify.Maybe<string>;
      identifiers: readonly string[];
      images: readonly ImageObjectStub[];
      name: purify.Maybe<string>;
      order: purify.Maybe<number>;
      sameAs: readonly rdfjs.NamedNode[];
      subjectOf: readonly (CreativeWorkStub | EventStub)[];
      url: purify.Maybe<rdfjs.NamedNode>;
    } & $UnwrapR<ReturnType<typeof ModelStatic.$propertiesFromRdf>>
  > {
    const $super0Either = ModelStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Thing)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ThingStatic.$Identifier = _resource.identifier;
    const _alternateNamesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly string[]
    > = purify.Either.of([
      ..._resource
        .values($properties.alternateNames["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((_value) => _value.toString())
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_alternateNamesEither.isLeft()) {
      return _alternateNamesEither;
    }

    const alternateNames = _alternateNamesEither.unsafeCoerce();
    const _descriptionEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.description["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_descriptionEither.isLeft()) {
      return _descriptionEither;
    }

    const description = _descriptionEither.unsafeCoerce();
    const _disambiguatingDescriptionEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.disambiguatingDescription["identifier"], {
          unique: true,
        })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_disambiguatingDescriptionEither.isLeft()) {
      return _disambiguatingDescriptionEither;
    }

    const disambiguatingDescription =
      _disambiguatingDescriptionEither.unsafeCoerce();
    const _identifiersEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly string[]
    > = purify.Either.of([
      ..._resource
        .values($properties.identifiers["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((_value) => _value.toString())
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_identifiersEither.isLeft()) {
      return _identifiersEither;
    }

    const identifiers = _identifiersEither.unsafeCoerce();
    const _imagesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly ImageObjectStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.images["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              ImageObjectStub.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_imagesEither.isLeft()) {
      return _imagesEither;
    }

    const images = _imagesEither.unsafeCoerce();
    const _nameEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.name["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_nameEither.isLeft()) {
      return _nameEither;
    }

    const name = _nameEither.unsafeCoerce();
    const _orderEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<number>
    > = purify.Either.of(
      _resource
        .values($properties.order["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toNumber())
        .toMaybe(),
    );
    if (_orderEither.isLeft()) {
      return _orderEither;
    }

    const order = _orderEither.unsafeCoerce();
    const _sameAsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly rdfjs.NamedNode[]
    > = purify.Either.of([
      ..._resource
        .values($properties.sameAs["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((_value) => _value.toIri())
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_sameAsEither.isLeft()) {
      return _sameAsEither;
    }

    const sameAs = _sameAsEither.unsafeCoerce();
    const _subjectOfEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly (CreativeWorkStub | EventStub)[]
    > = purify.Either.of([
      ..._resource
        .values($properties.subjectOf["identifier"], { unique: true })
        .flatMap((_item) =>
          (
            _item
              .toValues()
              .head()
              .chain((value) => value.toResource())
              .chain((_resource) =>
                CreativeWorkStubStatic.$fromRdf({
                  ..._context,
                  languageIn: _languageIn,
                  resource: _resource,
                }),
              ) as purify.Either<
              rdfjsResource.Resource.ValueError,
              CreativeWorkStub | EventStub
            >
          )
            .altLazy(
              () =>
                _item
                  .toValues()
                  .head()
                  .chain((value) => value.toResource())
                  .chain((_resource) =>
                    EventStubStatic.$fromRdf({
                      ..._context,
                      languageIn: _languageIn,
                      resource: _resource,
                    }),
                  ) as purify.Either<
                  rdfjsResource.Resource.ValueError,
                  CreativeWorkStub | EventStub
                >,
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_subjectOfEither.isLeft()) {
      return _subjectOfEither;
    }

    const subjectOf = _subjectOfEither.unsafeCoerce();
    const _urlEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<rdfjs.NamedNode>
    > = purify.Either.of(
      _resource
        .values($properties.url["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toIri())
        .toMaybe(),
    );
    if (_urlEither.isLeft()) {
      return _urlEither;
    }

    const url = _urlEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      alternateNames,
      description,
      disambiguatingDescription,
      identifiers,
      images,
      name,
      order,
      sameAs,
      subjectOf,
      url,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ThingStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Thing> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      ActionStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Thing
      >
    )
      .altLazy(
        () =>
          CreativeWorkStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Thing
          >,
      )
      .altLazy(
        () =>
          EventStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Thing
          >,
      )
      .altLazy(
        () =>
          IntangibleStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Thing
          >,
      )
      .altLazy(
        () =>
          OrganizationStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Thing
          >,
      )
      .altLazy(
        () =>
          Person.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Thing
          >,
      )
      .altLazy(
        () =>
          Place.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Thing
          >,
      )
      .altLazy(() =>
        ThingStatic.$propertiesFromRdf(parameters).map(
          (properties) => new Thing(properties),
        ),
      );
  }

  export const $properties = {
    ...ModelStatic.$properties,
    alternateNames: {
      identifier: dataFactory.namedNode("http://schema.org/alternateName"),
    },
    description: {
      identifier: dataFactory.namedNode("http://schema.org/description"),
    },
    disambiguatingDescription: {
      identifier: dataFactory.namedNode(
        "http://schema.org/disambiguatingDescription",
      ),
    },
    identifiers: {
      identifier: dataFactory.namedNode("http://schema.org/identifier"),
    },
    images: { identifier: dataFactory.namedNode("http://schema.org/image") },
    name: { identifier: dataFactory.namedNode("http://schema.org/name") },
    order: {
      identifier: dataFactory.namedNode("http://www.w3.org/ns/shacl#order"),
    },
    sameAs: { identifier: dataFactory.namedNode("http://schema.org/sameAs") },
    subjectOf: {
      identifier: dataFactory.namedNode("http://schema.org/subjectOf"),
    },
    url: { identifier: dataFactory.namedNode("http://schema.org/url") },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ThingStatic.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ThingStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ThingStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("thing");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "thing");
    triples.push(
      ...ModelStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}AlternateNames`),
      predicate: ThingStatic.$properties.alternateNames["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Description`),
      predicate: ThingStatic.$properties.description["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(
        `${variablePrefix}DisambiguatingDescription`,
      ),
      predicate:
        ThingStatic.$properties.disambiguatingDescription["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Identifiers`),
      predicate: ThingStatic.$properties.identifiers["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Images`),
      predicate: ThingStatic.$properties.images["identifier"],
      subject,
    });
    triples.push(
      ...ImageObjectStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Images`),
        variablePrefix: `${variablePrefix}Images`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Name`),
      predicate: ThingStatic.$properties.name["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Order`),
      predicate: ThingStatic.$properties.order["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}SameAs`),
      predicate: ThingStatic.$properties.sameAs["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}SubjectOf`),
      predicate: ThingStatic.$properties.subjectOf["identifier"],
      subject,
    });
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}SubjectOf`),
        variablePrefix: `${variablePrefix}SubjectOf`,
      }),
    );
    triples.push(
      ...EventStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}SubjectOf`),
        variablePrefix: `${variablePrefix}SubjectOf`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Url`),
      predicate: ThingStatic.$properties.url["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("thing");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "thing");
    for (const pattern of ModelStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}AlternateNames`,
                ),
                predicate: ThingStatic.$properties.alternateNames["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Description`),
                predicate: ThingStatic.$properties.description["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}DisambiguatingDescription`,
                ),
                predicate:
                  ThingStatic.$properties.disambiguatingDescription[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Identifiers`),
                predicate: ThingStatic.$properties.identifiers["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Images`),
                predicate: ThingStatic.$properties.images["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...ImageObjectStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}Images`),
            variablePrefix: `${variablePrefix}Images`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Name`),
                predicate: ThingStatic.$properties.name["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Order`),
                predicate: ThingStatic.$properties.order["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}SameAs`),
                predicate: ThingStatic.$properties.sameAs["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}SubjectOf`),
                predicate: ThingStatic.$properties.subjectOf["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          {
            patterns: [
              {
                patterns: [
                  ...CreativeWorkStubStatic.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(
                      `${variablePrefix}SubjectOf`,
                    ),
                    variablePrefix: `${variablePrefix}SubjectOf`,
                  }),
                ],
                type: "group",
              },
              {
                patterns: [
                  ...EventStubStatic.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(
                      `${variablePrefix}SubjectOf`,
                    ),
                    variablePrefix: `${variablePrefix}SubjectOf`,
                  }),
                ],
                type: "group",
              },
            ],
            type: "union",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Url`),
                predicate: ThingStatic.$properties.url["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Intangible extends Thing {
  override readonly $type:
    | "Intangible"
    | "BroadcastService"
    | "Enumeration"
    | "GenderType"
    | "Invoice"
    | "ItemList"
    | "ListItem"
    | "MonetaryAmount"
    | "Order"
    | "QuantitativeValue"
    | "RadioBroadcastService"
    | "Service"
    | "StructuredValue" = "Intangible";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof Thing>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): IntangibleStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Intangible"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IntangibleStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Intangible",
  );
  export type $Identifier = ThingStatic.$Identifier;
  export const $Identifier = ThingStatic.$Identifier;
  export type $Json = ThingStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Intangible> {
    return (Invoice.$fromJson(json) as purify.Either<zod.ZodError, Intangible>)
      .altLazy(
        () =>
          ItemList.$fromJson(json) as purify.Either<zod.ZodError, Intangible>,
      )
      .altLazy(
        () =>
          ListItem.$fromJson(json) as purify.Either<zod.ZodError, Intangible>,
      )
      .altLazy(
        () => Order.$fromJson(json) as purify.Either<zod.ZodError, Intangible>,
      )
      .altLazy(
        () =>
          ServiceStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            Intangible
          >,
      )
      .altLazy(
        () =>
          StructuredValueStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            Intangible
          >,
      )
      .altLazy(
        () =>
          EnumerationStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            Intangible
          >,
      )
      .altLazy(() =>
        $propertiesFromJson(json).map(
          (properties) => new Intangible(properties),
        ),
      );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ThingStatic.$jsonUiSchema({ scopePrefix })],
      label: "Intangible",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "Intangible",
          "BroadcastService",
          "Enumeration",
          "GenderType",
          "Invoice",
          "ItemList",
          "ListItem",
          "MonetaryAmount",
          "Order",
          "QuantitativeValue",
          "RadioBroadcastService",
          "Service",
          "StructuredValue",
        ]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ThingStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Intangible)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: IntangibleStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof IntangibleStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Intangible> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      Invoice.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Intangible
      >
    )
      .altLazy(
        () =>
          ItemList.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Intangible
          >,
      )
      .altLazy(
        () =>
          ListItem.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Intangible
          >,
      )
      .altLazy(
        () =>
          Order.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Intangible
          >,
      )
      .altLazy(
        () =>
          ServiceStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Intangible
          >,
      )
      .altLazy(
        () =>
          StructuredValueStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Intangible
          >,
      )
      .altLazy(
        () =>
          EnumerationStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            Intangible
          >,
      )
      .altLazy(() =>
        IntangibleStatic.$propertiesFromRdf(parameters).map(
          (properties) => new Intangible(properties),
        ),
      );
  }

  export const $properties = { ...ThingStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IntangibleStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        IntangibleStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IntangibleStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("intangible");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "intangible");
    triples.push(
      ...ThingStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("intangible");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "intangible");
    for (const pattern of ThingStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Enumeration extends Intangible {
  override readonly $type: "Enumeration" | "GenderType" = "Enumeration";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof Intangible>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): EnumerationStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Enumeration"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace EnumerationStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Enumeration",
  );
  export type $Identifier = IntangibleStatic.$Identifier;
  export const $Identifier = IntangibleStatic.$Identifier;
  export type $Json = IntangibleStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Enumeration> {
    return (
      GenderType.$fromJson(json) as purify.Either<zod.ZodError, Enumeration>
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new Enumeration(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IntangibleStatic.$jsonUiSchema({ scopePrefix })],
      label: "Enumeration",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["Enumeration", "GenderType"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IntangibleStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Enumeration)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: EnumerationStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof EnumerationStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Enumeration> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      GenderType.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Enumeration
      >
    ).altLazy(() =>
      EnumerationStatic.$propertiesFromRdf(parameters).map(
        (properties) => new Enumeration(properties),
      ),
    );
  }

  export const $properties = { ...IntangibleStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        EnumerationStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        EnumerationStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      EnumerationStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("enumeration");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "enumeration");
    triples.push(
      ...IntangibleStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("enumeration");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "enumeration");
    for (const pattern of IntangibleStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class GenderType extends Enumeration {
  override readonly $type = "GenderType";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier:
        | "http://schema.org/Female"
        | "http://schema.org/Male"
        | rdfjs.NamedNode<
            "http://schema.org/Female" | "http://schema.org/Male"
          >;
    } & ConstructorParameters<typeof Enumeration>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): GenderType.$Identifier {
    return super.$identifier as GenderType.$Identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/GenderType"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace GenderType {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/GenderType",
  );
  export type $Identifier = rdfjs.NamedNode<
    "http://schema.org/Female" | "http://schema.org/Male"
  >;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<
      Error,
      rdfjs.NamedNode<"http://schema.org/Female" | "http://schema.org/Male">
    > {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory: dataFactory,
          identifier,
        }),
      )
        .chain((identifier) =>
          identifier.termType === "NamedNode"
            ? purify.Either.of(identifier)
            : purify.Left(new Error("expected identifier to be NamedNode")),
        )
        .chain((identifier) => {
          switch (identifier.value) {
            case "http://schema.org/Female":
              return purify.Either.of(
                identifier as rdfjs.NamedNode<"http://schema.org/Female">,
              );
            case "http://schema.org/Male":
              return purify.Either.of(
                identifier as rdfjs.NamedNode<"http://schema.org/Male">,
              );
            default:
              return purify.Left(
                new Error(
                  "expected NamedNode identifier to be one of http://schema.org/Female http://schema.org/Male",
                ),
              );
          }
        }) as purify.Either<
        Error,
        rdfjs.NamedNode<"http://schema.org/Female" | "http://schema.org/Male">
      >;
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export type $Json = EnumerationStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.NamedNode<
        "http://schema.org/Female" | "http://schema.org/Male"
      >;
    } & $UnwrapR<ReturnType<typeof EnumerationStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = EnumerationStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, GenderType> {
    return $propertiesFromJson(json).map(
      (properties) => new GenderType(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [EnumerationStatic.$jsonUiSchema({ scopePrefix })],
      label: "GenderType",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return EnumerationStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.enum(["http://schema.org/Female", "http://schema.org/Male"]),
        $type: zod.literal("GenderType"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.NamedNode<
        "http://schema.org/Female" | "http://schema.org/Male"
      >;
    } & $UnwrapR<ReturnType<typeof EnumerationStatic.$propertiesFromRdf>>
  > {
    const $super0Either = EnumerationStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/GenderType)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    let $identifier: GenderType.$Identifier;
    switch (_resource.identifier.value) {
      case "http://schema.org/Female":
        $identifier = dataFactory.namedNode("http://schema.org/Female");
        break;
      case "http://schema.org/Male":
        $identifier = dataFactory.namedNode("http://schema.org/Male");
        break;
      default:
        return purify.Left(
          new rdfjsResource.Resource.MistypedValueError({
            actualValue: _resource.identifier,
            expectedValueType:
              'rdfjs.NamedNode<"http://schema.org/Female" | "http://schema.org/Male">',
            focusResource: _resource,
            predicate: $RdfVocabularies.rdf.subject,
          }),
        );
    }

    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof GenderType.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, GenderType> {
    return GenderType.$propertiesFromRdf(parameters).map(
      (properties) => new GenderType(properties),
    );
  }

  export const $properties = { ...EnumerationStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        GenderType.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        GenderType.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      GenderType.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("genderType");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "genderType");
    triples.push(
      ...EnumerationStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("genderType");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "genderType");
    for (const pattern of EnumerationStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Action extends Thing {
  override readonly $type:
    | "Action"
    | "AssessAction"
    | "ChooseAction"
    | "VoteAction" = "Action";
  readonly agents: readonly AgentStub[];
  readonly endTime: purify.Maybe<Date>;
  readonly participants: readonly AgentStub[];
  readonly startTime: purify.Maybe<Date>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly agents?: readonly AgentStub[];
      readonly endTime?: Date | purify.Maybe<Date>;
      readonly participants?: readonly AgentStub[];
      readonly startTime?: Date | purify.Maybe<Date>;
    } & ConstructorParameters<typeof Thing>[0],
  ) {
    super(parameters);
    if (typeof parameters.agents === "undefined") {
      this.agents = [];
    } else if (typeof parameters.agents === "object") {
      this.agents = parameters.agents;
    } else {
      this.agents = parameters.agents satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.endTime)) {
      this.endTime = parameters.endTime;
    } else if (
      typeof parameters.endTime === "object" &&
      parameters.endTime instanceof Date
    ) {
      this.endTime = purify.Maybe.of(parameters.endTime);
    } else if (typeof parameters.endTime === "undefined") {
      this.endTime = purify.Maybe.empty();
    } else {
      this.endTime = parameters.endTime satisfies never;
    }

    if (typeof parameters.participants === "undefined") {
      this.participants = [];
    } else if (typeof parameters.participants === "object") {
      this.participants = parameters.participants;
    } else {
      this.participants = parameters.participants satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.startTime)) {
      this.startTime = parameters.startTime;
    } else if (
      typeof parameters.startTime === "object" &&
      parameters.startTime instanceof Date
    ) {
      this.startTime = purify.Maybe.of(parameters.startTime);
    } else if (typeof parameters.startTime === "undefined") {
      this.startTime = purify.Maybe.empty();
    } else {
      this.startTime = parameters.startTime satisfies never;
    }
  }

  override get $identifier(): ActionStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: Action): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, AgentStub.$equals))(
          this.agents,
          other.agents,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "agents",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.endTime,
          other.endTime,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "endTime",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, AgentStub.$equals))(
          this.participants,
          other.participants,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "participants",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.startTime,
          other.startTime,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "startTime",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.agents) {
      _item0.$hash(_hasher);
    }

    this.endTime.ifJust((_value0) => {
      _hasher.update(_value0.toISOString());
    });
    for (const _item0 of this.participants) {
      _item0.$hash(_hasher);
    }

    this.startTime.ifJust((_value0) => {
      _hasher.update(_value0.toISOString());
    });
    return _hasher;
  }

  override $toJson(): ActionStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        agents: this.agents.map((_item) => _item.$toJson()),
        endTime: this.endTime.map((_item) => _item.toISOString()).extract(),
        participants: this.participants.map((_item) => _item.$toJson()),
        startTime: this.startTime.map((_item) => _item.toISOString()).extract(),
      } satisfies ActionStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Action"),
      );
    }

    _resource.add(
      ActionStatic.$properties.agents["identifier"],
      this.agents.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      ActionStatic.$properties.endTime["identifier"],
      this.endTime.map((_value) =>
        rdfLiteral.toRdf(_value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.dateTime,
        }),
      ),
    );
    _resource.add(
      ActionStatic.$properties.participants["identifier"],
      this.participants.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      ActionStatic.$properties.startTime["identifier"],
      this.startTime.map((_value) =>
        rdfLiteral.toRdf(_value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.dateTime,
        }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ActionStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Action",
  );
  export type $Identifier = ThingStatic.$Identifier;
  export const $Identifier = ThingStatic.$Identifier;
  export type $Json = {
    readonly agents: readonly (
      | OrganizationStubStatic.$Json
      | PersonStub.$Json
    )[];
    readonly endTime: string | undefined;
    readonly participants: readonly (
      | OrganizationStubStatic.$Json
      | PersonStub.$Json
    )[];
    readonly startTime: string | undefined;
  } & ThingStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      agents: readonly AgentStub[];
      endTime: purify.Maybe<Date>;
      participants: readonly AgentStub[];
      startTime: purify.Maybe<Date>;
    } & $UnwrapR<ReturnType<typeof ThingStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const agents = _jsonObject["agents"].map((_item) =>
      AgentStub.$fromJson(_item).unsafeCoerce(),
    );
    const endTime = purify.Maybe.fromNullable(_jsonObject["endTime"]).map(
      (_item) => new Date(_item),
    );
    const participants = _jsonObject["participants"].map((_item) =>
      AgentStub.$fromJson(_item).unsafeCoerce(),
    );
    const startTime = purify.Maybe.fromNullable(_jsonObject["startTime"]).map(
      (_item) => new Date(_item),
    );
    return purify.Either.of({
      ...$super0,
      $identifier,
      agents,
      endTime,
      participants,
      startTime,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Action> {
    return (
      AssessActionStatic.$fromJson(json) as purify.Either<zod.ZodError, Action>
    ).altLazy(() =>
      $propertiesFromJson(json).map((properties) => new Action(properties)),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ThingStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/agents`, type: "Control" },
        { scope: `${scopePrefix}/properties/endTime`, type: "Control" },
        { scope: `${scopePrefix}/properties/participants`, type: "Control" },
        { scope: `${scopePrefix}/properties/startTime`, type: "Control" },
      ],
      label: "Action",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "Action",
          "AssessAction",
          "ChooseAction",
          "VoteAction",
        ]),
        agents: AgentStub.$jsonZodSchema()
          .array()
          .default(() => []),
        endTime: zod.string().datetime().optional(),
        participants: AgentStub.$jsonZodSchema()
          .array()
          .default(() => []),
        startTime: zod.string().datetime().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      agents: readonly AgentStub[];
      endTime: purify.Maybe<Date>;
      participants: readonly AgentStub[];
      startTime: purify.Maybe<Date>;
    } & $UnwrapR<ReturnType<typeof ThingStatic.$propertiesFromRdf>>
  > {
    const $super0Either = ThingStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Action)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ActionStatic.$Identifier = _resource.identifier;
    const _agentsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly AgentStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.agents["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              AgentStub.$fromRdf({
                ..._context,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_agentsEither.isLeft()) {
      return _agentsEither;
    }

    const agents = _agentsEither.unsafeCoerce();
    const _endTimeEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<Date>
    > = purify.Either.of(
      _resource
        .values($properties.endTime["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toDate())
        .toMaybe(),
    );
    if (_endTimeEither.isLeft()) {
      return _endTimeEither;
    }

    const endTime = _endTimeEither.unsafeCoerce();
    const _participantsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly AgentStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.participants["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              AgentStub.$fromRdf({
                ..._context,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_participantsEither.isLeft()) {
      return _participantsEither;
    }

    const participants = _participantsEither.unsafeCoerce();
    const _startTimeEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<Date>
    > = purify.Either.of(
      _resource
        .values($properties.startTime["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toDate())
        .toMaybe(),
    );
    if (_startTimeEither.isLeft()) {
      return _startTimeEither;
    }

    const startTime = _startTimeEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      agents,
      endTime,
      participants,
      startTime,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ActionStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Action> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      AssessActionStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Action
      >
    ).altLazy(() =>
      ActionStatic.$propertiesFromRdf(parameters).map(
        (properties) => new Action(properties),
      ),
    );
  }

  export const $properties = {
    ...ThingStatic.$properties,
    agents: { identifier: dataFactory.namedNode("http://schema.org/agent") },
    endTime: { identifier: dataFactory.namedNode("http://schema.org/endTime") },
    participants: {
      identifier: dataFactory.namedNode("http://schema.org/participant"),
    },
    startTime: {
      identifier: dataFactory.namedNode("http://schema.org/startTime"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ActionStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ActionStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ActionStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("action");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "action");
    triples.push(
      ...ThingStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Agents`),
      predicate: ActionStatic.$properties.agents["identifier"],
      subject,
    });
    triples.push(
      ...AgentStub.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(`${variablePrefix}Agents`),
        variablePrefix: `${variablePrefix}Agents`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}EndTime`),
      predicate: ActionStatic.$properties.endTime["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Participants`),
      predicate: ActionStatic.$properties.participants["identifier"],
      subject,
    });
    triples.push(
      ...AgentStub.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(`${variablePrefix}Participants`),
        variablePrefix: `${variablePrefix}Participants`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}StartTime`),
      predicate: ActionStatic.$properties.startTime["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("action");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "action");
    for (const pattern of ThingStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Agents`),
                predicate: ActionStatic.$properties.agents["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...AgentStub.$sparqlWherePatterns({
            subject: dataFactory.variable!(`${variablePrefix}Agents`),
            variablePrefix: `${variablePrefix}Agents`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}EndTime`),
                predicate: ActionStatic.$properties.endTime["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Participants`),
                predicate: ActionStatic.$properties.participants["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...AgentStub.$sparqlWherePatterns({
            subject: dataFactory.variable!(`${variablePrefix}Participants`),
            variablePrefix: `${variablePrefix}Participants`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}StartTime`),
                predicate: ActionStatic.$properties.startTime["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class AssessAction extends Action {
  override readonly $type: "AssessAction" | "ChooseAction" | "VoteAction" =
    "AssessAction";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof Action>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): AssessActionStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/AssessAction"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AssessActionStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/AssessAction",
  );
  export type $Identifier = ActionStatic.$Identifier;
  export const $Identifier = ActionStatic.$Identifier;
  export type $Json = ActionStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ActionStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ActionStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, AssessAction> {
    return (
      ChooseActionStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        AssessAction
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new AssessAction(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ActionStatic.$jsonUiSchema({ scopePrefix })],
      label: "AssessAction",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ActionStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["AssessAction", "ChooseAction", "VoteAction"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ActionStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ActionStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/AssessAction)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: AssessActionStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof AssessActionStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, AssessAction> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      ChooseActionStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        AssessAction
      >
    ).altLazy(() =>
      AssessActionStatic.$propertiesFromRdf(parameters).map(
        (properties) => new AssessAction(properties),
      ),
    );
  }

  export const $properties = { ...ActionStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AssessActionStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        AssessActionStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AssessActionStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("assessAction");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "assessAction");
    triples.push(
      ...ActionStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("assessAction");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "assessAction");
    for (const pattern of ActionStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ChooseAction extends AssessAction {
  override readonly $type: "ChooseAction" | "VoteAction" = "ChooseAction";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof AssessAction>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): ChooseActionStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/ChooseAction"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ChooseActionStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/ChooseAction",
  );
  export type $Identifier = AssessActionStatic.$Identifier;
  export const $Identifier = AssessActionStatic.$Identifier;
  export type $Json = AssessActionStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof AssessActionStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = AssessActionStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ChooseAction> {
    return (
      VoteAction.$fromJson(json) as purify.Either<zod.ZodError, ChooseAction>
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new ChooseAction(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [AssessActionStatic.$jsonUiSchema({ scopePrefix })],
      label: "ChooseAction",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return AssessActionStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ChooseAction", "VoteAction"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof AssessActionStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = AssessActionStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/ChooseAction)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ChooseActionStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ChooseActionStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ChooseAction> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      VoteAction.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        ChooseAction
      >
    ).altLazy(() =>
      ChooseActionStatic.$propertiesFromRdf(parameters).map(
        (properties) => new ChooseAction(properties),
      ),
    );
  }

  export const $properties = { ...AssessActionStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ChooseActionStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ChooseActionStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ChooseActionStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("chooseAction");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "chooseAction");
    triples.push(
      ...AssessActionStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("chooseAction");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "chooseAction");
    for (const pattern of AssessActionStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class VoteAction extends ChooseAction {
  override readonly $type = "VoteAction";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof ChooseAction>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): VoteAction.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/VoteAction"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace VoteAction {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/VoteAction",
  );
  export type $Identifier = ChooseActionStatic.$Identifier;
  export const $Identifier = ChooseActionStatic.$Identifier;
  export type $Json = ChooseActionStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ChooseActionStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ChooseActionStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, VoteAction> {
    return $propertiesFromJson(json).map(
      (properties) => new VoteAction(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ChooseActionStatic.$jsonUiSchema({ scopePrefix })],
      label: "VoteAction",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ChooseActionStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("VoteAction"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ChooseActionStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ChooseActionStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/VoteAction)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: VoteAction.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof VoteAction.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, VoteAction> {
    return VoteAction.$propertiesFromRdf(parameters).map(
      (properties) => new VoteAction(properties),
    );
  }

  export const $properties = { ...ChooseActionStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        VoteAction.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        VoteAction.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      VoteAction.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("voteAction");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "voteAction");
    triples.push(
      ...ChooseActionStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("voteAction");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "voteAction");
    for (const pattern of ChooseActionStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ThingStub extends Model {
  protected _$identifier: ThingStubStatic.$Identifier | undefined;
  override readonly $type:
    | "ThingStub"
    | "ActionStub"
    | "ArticleStub"
    | "AssessActionStub"
    | "BroadcastEventStub"
    | "BroadcastServiceStub"
    | "ChooseActionStub"
    | "CreativeWorkSeriesStub"
    | "CreativeWorkStub"
    | "EpisodeStub"
    | "EventStub"
    | "ImageObjectStub"
    | "IntangibleStub"
    | "InvoiceStub"
    | "ItemListStub"
    | "ListItemStub"
    | "MediaObjectStub"
    | "MessageStub"
    | "MonetaryAmountStub"
    | "MusicAlbumStub"
    | "MusicArtistRoleStub"
    | "MusicCompositionStub"
    | "MusicGroupStub"
    | "MusicPlaylistStub"
    | "MusicRecordingStub"
    | "OccupationStub"
    | "OrderStub"
    | "OrganizationStub"
    | "PerformingGroupStub"
    | "PersonStub"
    | "PlaceStub"
    | "PublicationEventStub"
    | "QuantitativeValueStub"
    | "RadioBroadcastServiceStub"
    | "RadioEpisodeStub"
    | "RadioSeriesStub"
    | "ReportStub"
    | "RoleStub"
    | "ServiceStub"
    | "StructuredValueStub"
    | "TextObjectStub"
    | "VoteActionStub" = "ThingStub";
  readonly name: purify.Maybe<string>;
  readonly order: purify.Maybe<number>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly name?: purify.Maybe<string> | string;
      readonly order?: number | purify.Maybe<number>;
    } & ConstructorParameters<typeof Model>[0],
  ) {
    super(parameters);
    if (typeof parameters.$identifier === "object") {
      this._$identifier = parameters.$identifier;
    } else if (typeof parameters.$identifier === "string") {
      this._$identifier = dataFactory.namedNode(parameters.$identifier);
    } else if (typeof parameters.$identifier === "undefined") {
    } else {
      this._$identifier = parameters.$identifier satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.name)) {
      this.name = parameters.name;
    } else if (typeof parameters.name === "string") {
      this.name = purify.Maybe.of(parameters.name);
    } else if (typeof parameters.name === "undefined") {
      this.name = purify.Maybe.empty();
    } else {
      this.name = parameters.name satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.order)) {
      this.order = parameters.order;
    } else if (typeof parameters.order === "number") {
      this.order = purify.Maybe.of(parameters.order);
    } else if (typeof parameters.order === "undefined") {
      this.order = purify.Maybe.empty();
    } else {
      this.order = parameters.order satisfies never;
    }
  }

  override get $identifier(): ThingStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: ThingStub): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.name,
          other.name,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "name",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.order,
          other.order,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "order",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.name.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.order.ifJust((_value0) => {
      _hasher.update(_value0.toString());
    });
    return _hasher;
  }

  override $toJson(): ThingStubStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        name: this.name.map((_item) => _item).extract(),
        order: this.order.map((_item) => _item).extract(),
      } satisfies ThingStubStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Thing"),
      );
    }

    _resource.add(ThingStatic.$properties.name["identifier"], this.name);
    _resource.add(ThingStatic.$properties.order["identifier"], this.order);
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ThingStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Thing",
  );
  export type $Identifier = ModelStatic.$Identifier;
  export const $Identifier = ModelStatic.$Identifier;
  export type $Json = {
    readonly name: string | undefined;
    readonly order: number | undefined;
  } & ModelStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      name: purify.Maybe<string>;
      order: purify.Maybe<number>;
    } & $UnwrapR<ReturnType<typeof ModelStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ModelStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const name = purify.Maybe.fromNullable(_jsonObject["name"]);
    const order = purify.Maybe.fromNullable(_jsonObject["order"]);
    return purify.Either.of({ ...$super0, $identifier, name, order });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ThingStub> {
    return (
      ActionStubStatic.$fromJson(json) as purify.Either<zod.ZodError, ThingStub>
    )
      .altLazy(
        () =>
          OrganizationStubStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            ThingStub
          >,
      )
      .altLazy(
        () =>
          PersonStub.$fromJson(json) as purify.Either<zod.ZodError, ThingStub>,
      )
      .altLazy(
        () =>
          CreativeWorkStubStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            ThingStub
          >,
      )
      .altLazy(
        () =>
          EventStubStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            ThingStub
          >,
      )
      .altLazy(
        () =>
          IntangibleStubStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            ThingStub
          >,
      )
      .altLazy(
        () =>
          PlaceStub.$fromJson(json) as purify.Either<zod.ZodError, ThingStub>,
      )
      .altLazy(() =>
        $propertiesFromJson(json).map(
          (properties) => new ThingStub(properties),
        ),
      );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ModelStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/name`, type: "Control" },
        { scope: `${scopePrefix}/properties/order`, type: "Control" },
      ],
      label: "ThingStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ModelStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "ThingStub",
          "ActionStub",
          "ArticleStub",
          "AssessActionStub",
          "BroadcastEventStub",
          "BroadcastServiceStub",
          "ChooseActionStub",
          "CreativeWorkSeriesStub",
          "CreativeWorkStub",
          "EpisodeStub",
          "EventStub",
          "ImageObjectStub",
          "IntangibleStub",
          "InvoiceStub",
          "ItemListStub",
          "ListItemStub",
          "MediaObjectStub",
          "MessageStub",
          "MonetaryAmountStub",
          "MusicAlbumStub",
          "MusicArtistRoleStub",
          "MusicCompositionStub",
          "MusicGroupStub",
          "MusicPlaylistStub",
          "MusicRecordingStub",
          "OccupationStub",
          "OrderStub",
          "OrganizationStub",
          "PerformingGroupStub",
          "PersonStub",
          "PlaceStub",
          "PublicationEventStub",
          "QuantitativeValueStub",
          "RadioBroadcastServiceStub",
          "RadioEpisodeStub",
          "RadioSeriesStub",
          "ReportStub",
          "RoleStub",
          "ServiceStub",
          "StructuredValueStub",
          "TextObjectStub",
          "VoteActionStub",
        ]),
        name: zod.string().optional(),
        order: zod.number().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      name: purify.Maybe<string>;
      order: purify.Maybe<number>;
    } & $UnwrapR<ReturnType<typeof ModelStatic.$propertiesFromRdf>>
  > {
    const $super0Either = ModelStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Thing)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ThingStubStatic.$Identifier = _resource.identifier;
    const _nameEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.name["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_nameEither.isLeft()) {
      return _nameEither;
    }

    const name = _nameEither.unsafeCoerce();
    const _orderEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<number>
    > = purify.Either.of(
      _resource
        .values($properties.order["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toNumber())
        .toMaybe(),
    );
    if (_orderEither.isLeft()) {
      return _orderEither;
    }

    const order = _orderEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, name, order });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ThingStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ThingStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      ActionStubStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        ThingStub
      >
    )
      .altLazy(
        () =>
          OrganizationStubStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            ThingStub
          >,
      )
      .altLazy(
        () =>
          PersonStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            ThingStub
          >,
      )
      .altLazy(
        () =>
          CreativeWorkStubStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            ThingStub
          >,
      )
      .altLazy(
        () =>
          EventStubStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            ThingStub
          >,
      )
      .altLazy(
        () =>
          IntangibleStubStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            ThingStub
          >,
      )
      .altLazy(
        () =>
          PlaceStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            ThingStub
          >,
      )
      .altLazy(() =>
        ThingStubStatic.$propertiesFromRdf(parameters).map(
          (properties) => new ThingStub(properties),
        ),
      );
  }

  export const $properties = {
    ...ModelStatic.$properties,
    name: { identifier: dataFactory.namedNode("http://schema.org/name") },
    order: {
      identifier: dataFactory.namedNode("http://www.w3.org/ns/shacl#order"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ThingStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ThingStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ThingStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("thingStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "thingStub");
    triples.push(
      ...ModelStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Name`),
      predicate: ThingStatic.$properties.name["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Order`),
      predicate: ThingStatic.$properties.order["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("thingStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "thingStub");
    for (const pattern of ModelStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Name`),
                predicate: ThingStatic.$properties.name["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Order`),
                predicate: ThingStatic.$properties.order["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ActionStub extends ThingStub {
  override readonly $type:
    | "ActionStub"
    | "AssessActionStub"
    | "ChooseActionStub"
    | "VoteActionStub" = "ActionStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof ThingStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): ActionStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Action"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ActionStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Action",
  );
  export type $Identifier = ThingStubStatic.$Identifier;
  export const $Identifier = ThingStubStatic.$Identifier;
  export type $Json = ThingStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ActionStub> {
    return (
      AssessActionStubStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        ActionStub
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map((properties) => new ActionStub(properties)),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ThingStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "ActionStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "ActionStub",
          "AssessActionStub",
          "ChooseActionStub",
          "VoteActionStub",
        ]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ThingStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Action)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ActionStubStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ActionStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ActionStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      AssessActionStubStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        ActionStub
      >
    ).altLazy(() =>
      ActionStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new ActionStub(properties),
      ),
    );
  }

  export const $properties = { ...ThingStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ActionStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ActionStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ActionStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("actionStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "actionStub");
    triples.push(
      ...ThingStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("actionStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "actionStub");
    for (const pattern of ThingStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class AssessActionStub extends ActionStub {
  override readonly $type:
    | "AssessActionStub"
    | "ChooseActionStub"
    | "VoteActionStub" = "AssessActionStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof ActionStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): AssessActionStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/AssessAction"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace AssessActionStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/AssessAction",
  );
  export type $Identifier = ActionStubStatic.$Identifier;
  export const $Identifier = ActionStubStatic.$Identifier;
  export type $Json = ActionStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ActionStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ActionStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, AssessActionStub> {
    return (
      ChooseActionStubStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        AssessActionStub
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new AssessActionStub(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ActionStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "AssessActionStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ActionStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "AssessActionStub",
          "ChooseActionStub",
          "VoteActionStub",
        ]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ActionStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ActionStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/AssessAction)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: AssessActionStubStatic.$Identifier =
      _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof AssessActionStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, AssessActionStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      ChooseActionStubStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        AssessActionStub
      >
    ).altLazy(() =>
      AssessActionStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new AssessActionStub(properties),
      ),
    );
  }

  export const $properties = { ...ActionStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AssessActionStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        AssessActionStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AssessActionStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("assessActionStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "assessActionStub");
    triples.push(
      ...ActionStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("assessActionStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "assessActionStub");
    for (const pattern of ActionStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ChooseActionStub extends AssessActionStub {
  override readonly $type: "ChooseActionStub" | "VoteActionStub" =
    "ChooseActionStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof AssessActionStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): ChooseActionStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/ChooseAction"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ChooseActionStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/ChooseAction",
  );
  export type $Identifier = AssessActionStubStatic.$Identifier;
  export const $Identifier = AssessActionStubStatic.$Identifier;
  export type $Json = AssessActionStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof AssessActionStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      AssessActionStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ChooseActionStub> {
    return (
      VoteActionStub.$fromJson(json) as purify.Either<
        zod.ZodError,
        ChooseActionStub
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new ChooseActionStub(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [AssessActionStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "ChooseActionStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return AssessActionStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ChooseActionStub", "VoteActionStub"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof AssessActionStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = AssessActionStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/ChooseAction)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ChooseActionStubStatic.$Identifier =
      _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ChooseActionStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ChooseActionStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      VoteActionStub.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        ChooseActionStub
      >
    ).altLazy(() =>
      ChooseActionStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new ChooseActionStub(properties),
      ),
    );
  }

  export const $properties = { ...AssessActionStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ChooseActionStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ChooseActionStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ChooseActionStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("chooseActionStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "chooseActionStub");
    triples.push(
      ...AssessActionStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("chooseActionStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "chooseActionStub");
    for (const pattern of AssessActionStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class VoteActionStub extends ChooseActionStub {
  override readonly $type = "VoteActionStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof ChooseActionStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): VoteActionStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/VoteAction"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace VoteActionStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/VoteAction",
  );
  export type $Identifier = ChooseActionStubStatic.$Identifier;
  export const $Identifier = ChooseActionStubStatic.$Identifier;
  export type $Json = ChooseActionStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ChooseActionStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      ChooseActionStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, VoteActionStub> {
    return $propertiesFromJson(json).map(
      (properties) => new VoteActionStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ChooseActionStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "VoteActionStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ChooseActionStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("VoteActionStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ChooseActionStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ChooseActionStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/VoteAction)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: VoteActionStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof VoteActionStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, VoteActionStub> {
    return VoteActionStub.$propertiesFromRdf(parameters).map(
      (properties) => new VoteActionStub(properties),
    );
  }

  export const $properties = { ...ChooseActionStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        VoteActionStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        VoteActionStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      VoteActionStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("voteActionStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "voteActionStub");
    triples.push(
      ...ChooseActionStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("voteActionStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "voteActionStub");
    for (const pattern of ChooseActionStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class CreativeWork extends Thing {
  override readonly $type:
    | "CreativeWork"
    | "Article"
    | "CreativeWorkSeries"
    | "Episode"
    | "ImageObject"
    | "MediaObject"
    | "Message"
    | "MusicAlbum"
    | "MusicComposition"
    | "MusicPlaylist"
    | "MusicRecording"
    | "RadioEpisode"
    | "RadioSeries"
    | "Report"
    | "TextObject" = "CreativeWork";
  readonly about: readonly ThingStub[];
  readonly authors: readonly AgentStub[];
  readonly datePublished: purify.Maybe<Date>;
  hasParts: CreativeWorkStub[];
  readonly isBasedOn: readonly rdfjs.NamedNode[];
  readonly isPartOf: readonly CreativeWorkStub[];
  readonly publication: readonly PublicationEventStub[];

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly about?: readonly ThingStub[];
      readonly authors?: readonly AgentStub[];
      readonly datePublished?: Date | purify.Maybe<Date>;
      readonly hasParts?: readonly CreativeWorkStub[];
      readonly isBasedOn?: readonly rdfjs.NamedNode[];
      readonly isPartOf?: readonly CreativeWorkStub[];
      readonly publication?: readonly PublicationEventStub[];
    } & ConstructorParameters<typeof Thing>[0],
  ) {
    super(parameters);
    if (typeof parameters.about === "undefined") {
      this.about = [];
    } else if (typeof parameters.about === "object") {
      this.about = parameters.about;
    } else {
      this.about = parameters.about satisfies never;
    }

    if (typeof parameters.authors === "undefined") {
      this.authors = [];
    } else if (typeof parameters.authors === "object") {
      this.authors = parameters.authors;
    } else {
      this.authors = parameters.authors satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.datePublished)) {
      this.datePublished = parameters.datePublished;
    } else if (
      typeof parameters.datePublished === "object" &&
      parameters.datePublished instanceof Date
    ) {
      this.datePublished = purify.Maybe.of(parameters.datePublished);
    } else if (typeof parameters.datePublished === "undefined") {
      this.datePublished = purify.Maybe.empty();
    } else {
      this.datePublished = parameters.datePublished satisfies never;
    }

    if (typeof parameters.hasParts === "undefined") {
      this.hasParts = [];
    } else if (typeof parameters.hasParts === "object") {
      this.hasParts = parameters.hasParts.concat();
    } else {
      this.hasParts = parameters.hasParts satisfies never;
    }

    if (typeof parameters.isBasedOn === "undefined") {
      this.isBasedOn = [];
    } else if (typeof parameters.isBasedOn === "object") {
      this.isBasedOn = parameters.isBasedOn;
    } else {
      this.isBasedOn = parameters.isBasedOn satisfies never;
    }

    if (typeof parameters.isPartOf === "undefined") {
      this.isPartOf = [];
    } else if (typeof parameters.isPartOf === "object") {
      this.isPartOf = parameters.isPartOf;
    } else {
      this.isPartOf = parameters.isPartOf satisfies never;
    }

    if (typeof parameters.publication === "undefined") {
      this.publication = [];
    } else if (typeof parameters.publication === "object") {
      this.publication = parameters.publication;
    } else {
      this.publication = parameters.publication satisfies never;
    }
  }

  override get $identifier(): CreativeWorkStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: CreativeWork): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.about,
          other.about,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "about",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, AgentStub.$equals))(
          this.authors,
          other.authors,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "authors",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.datePublished,
          other.datePublished,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "datePublished",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.hasParts,
          other.hasParts,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "hasParts",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, $booleanEquals))(
          this.isBasedOn,
          other.isBasedOn,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "isBasedOn",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.isPartOf,
          other.isPartOf,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "isPartOf",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.publication,
          other.publication,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "publication",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.about) {
      _item0.$hash(_hasher);
    }

    for (const _item0 of this.authors) {
      _item0.$hash(_hasher);
    }

    this.datePublished.ifJust((_value0) => {
      _hasher.update(_value0.toISOString());
    });
    for (const _item0 of this.hasParts) {
      _item0.$hash(_hasher);
    }

    for (const _item0 of this.isBasedOn) {
      _hasher.update(_item0.termType);
      _hasher.update(_item0.value);
    }

    for (const _item0 of this.isPartOf) {
      _item0.$hash(_hasher);
    }

    for (const _item0 of this.publication) {
      _item0.$hash(_hasher);
    }

    return _hasher;
  }

  override $toJson(): CreativeWorkStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        about: this.about.map((_item) => _item.$toJson()),
        authors: this.authors.map((_item) => _item.$toJson()),
        datePublished: this.datePublished
          .map((_item) => _item.toISOString())
          .extract(),
        hasParts: this.hasParts.map((_item) => _item.$toJson()),
        isBasedOn: this.isBasedOn.map((_item) => ({ "@id": _item.value })),
        isPartOf: this.isPartOf.map((_item) => _item.$toJson()),
        publication: this.publication.map((_item) => _item.$toJson()),
      } satisfies CreativeWorkStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/CreativeWork"),
      );
    }

    _resource.add(
      CreativeWorkStatic.$properties.about["identifier"],
      this.about.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      CreativeWorkStatic.$properties.authors["identifier"],
      this.authors.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      CreativeWorkStatic.$properties.datePublished["identifier"],
      this.datePublished.map((_value) =>
        rdfLiteral.toRdf(_value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.dateTime,
        }),
      ),
    );
    _resource.add(
      CreativeWorkStatic.$properties.hasParts["identifier"],
      this.hasParts.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      CreativeWorkStatic.$properties.isBasedOn["identifier"],
      this.isBasedOn.map((_item) => _item),
    );
    _resource.add(
      CreativeWorkStatic.$properties.isPartOf["identifier"],
      this.isPartOf.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      CreativeWorkStatic.$properties.publication["identifier"],
      this.publication.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace CreativeWorkStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/CreativeWork",
  );
  export type $Identifier = ThingStatic.$Identifier;
  export const $Identifier = ThingStatic.$Identifier;
  export type $Json = {
    readonly about: readonly ThingStubStatic.$Json[];
    readonly authors: readonly (
      | OrganizationStubStatic.$Json
      | PersonStub.$Json
    )[];
    readonly datePublished: string | undefined;
    readonly hasParts: readonly CreativeWorkStubStatic.$Json[];
    readonly isBasedOn: readonly { readonly "@id": string }[];
    readonly isPartOf: readonly CreativeWorkStubStatic.$Json[];
    readonly publication: readonly PublicationEventStubStatic.$Json[];
  } & ThingStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      about: readonly ThingStub[];
      authors: readonly AgentStub[];
      datePublished: purify.Maybe<Date>;
      hasParts: CreativeWorkStub[];
      isBasedOn: readonly rdfjs.NamedNode[];
      isPartOf: readonly CreativeWorkStub[];
      publication: readonly PublicationEventStub[];
    } & $UnwrapR<ReturnType<typeof ThingStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const about = _jsonObject["about"].map((_item) =>
      ThingStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    const authors = _jsonObject["authors"].map((_item) =>
      AgentStub.$fromJson(_item).unsafeCoerce(),
    );
    const datePublished = purify.Maybe.fromNullable(
      _jsonObject["datePublished"],
    ).map((_item) => new Date(_item));
    const hasParts = _jsonObject["hasParts"].map((_item) =>
      CreativeWorkStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    const isBasedOn = _jsonObject["isBasedOn"].map((_item) =>
      dataFactory.namedNode(_item["@id"]),
    );
    const isPartOf = _jsonObject["isPartOf"].map((_item) =>
      CreativeWorkStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    const publication = _jsonObject["publication"].map((_item) =>
      PublicationEventStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({
      ...$super0,
      $identifier,
      about,
      authors,
      datePublished,
      hasParts,
      isBasedOn,
      isPartOf,
      publication,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, CreativeWork> {
    return (
      ArticleStatic.$fromJson(json) as purify.Either<zod.ZodError, CreativeWork>
    )
      .altLazy(
        () =>
          CreativeWorkSeriesStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          EpisodeStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          MediaObjectStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          Message.$fromJson(json) as purify.Either<zod.ZodError, CreativeWork>,
      )
      .altLazy(
        () =>
          MusicAlbum.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          MusicComposition.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          MusicPlaylist.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          MusicRecording.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWork
          >,
      )
      .altLazy(() =>
        $propertiesFromJson(json).map(
          (properties) => new CreativeWork(properties),
        ),
      );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ThingStatic.$jsonUiSchema({ scopePrefix }),
        ThingStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/about`,
        }),
        { scope: `${scopePrefix}/properties/authors`, type: "Control" },
        { scope: `${scopePrefix}/properties/datePublished`, type: "Control" },
        CreativeWorkStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/hasParts`,
        }),
        { scope: `${scopePrefix}/properties/isBasedOn`, type: "Control" },
        CreativeWorkStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/isPartOf`,
        }),
        PublicationEventStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/publication`,
        }),
      ],
      label: "CreativeWork",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "CreativeWork",
          "Article",
          "CreativeWorkSeries",
          "Episode",
          "ImageObject",
          "MediaObject",
          "Message",
          "MusicAlbum",
          "MusicComposition",
          "MusicPlaylist",
          "MusicRecording",
          "RadioEpisode",
          "RadioSeries",
          "Report",
          "TextObject",
        ]),
        about: ThingStubStatic.$jsonZodSchema()
          .array()
          .default(() => []),
        authors: AgentStub.$jsonZodSchema()
          .array()
          .default(() => []),
        datePublished: zod.string().datetime().optional(),
        hasParts: CreativeWorkStubStatic.$jsonZodSchema()
          .array()
          .default(() => []),
        isBasedOn: zod
          .object({ "@id": zod.string().min(1) })
          .array()
          .default(() => []),
        isPartOf: CreativeWorkStubStatic.$jsonZodSchema()
          .array()
          .default(() => []),
        publication: PublicationEventStubStatic.$jsonZodSchema()
          .array()
          .default(() => []),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      about: readonly ThingStub[];
      authors: readonly AgentStub[];
      datePublished: purify.Maybe<Date>;
      hasParts: CreativeWorkStub[];
      isBasedOn: readonly rdfjs.NamedNode[];
      isPartOf: readonly CreativeWorkStub[];
      publication: readonly PublicationEventStub[];
    } & $UnwrapR<ReturnType<typeof ThingStatic.$propertiesFromRdf>>
  > {
    const $super0Either = ThingStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/CreativeWork)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: CreativeWorkStatic.$Identifier = _resource.identifier;
    const _aboutEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly ThingStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.about["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              ThingStubStatic.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_aboutEither.isLeft()) {
      return _aboutEither;
    }

    const about = _aboutEither.unsafeCoerce();
    const _authorsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly AgentStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.authors["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              AgentStub.$fromRdf({
                ..._context,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_authorsEither.isLeft()) {
      return _authorsEither;
    }

    const authors = _authorsEither.unsafeCoerce();
    const _datePublishedEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<Date>
    > = purify.Either.of(
      _resource
        .values($properties.datePublished["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toDate())
        .toMaybe(),
    );
    if (_datePublishedEither.isLeft()) {
      return _datePublishedEither;
    }

    const datePublished = _datePublishedEither.unsafeCoerce();
    const _hasPartsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      CreativeWorkStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.hasParts["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              CreativeWorkStubStatic.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_hasPartsEither.isLeft()) {
      return _hasPartsEither;
    }

    const hasParts = _hasPartsEither.unsafeCoerce();
    const _isBasedOnEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly rdfjs.NamedNode[]
    > = purify.Either.of([
      ..._resource
        .values($properties.isBasedOn["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((_value) => _value.toIri())
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_isBasedOnEither.isLeft()) {
      return _isBasedOnEither;
    }

    const isBasedOn = _isBasedOnEither.unsafeCoerce();
    const _isPartOfEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly CreativeWorkStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.isPartOf["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              CreativeWorkStubStatic.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_isPartOfEither.isLeft()) {
      return _isPartOfEither;
    }

    const isPartOf = _isPartOfEither.unsafeCoerce();
    const _publicationEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly PublicationEventStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.publication["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              PublicationEventStubStatic.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_publicationEither.isLeft()) {
      return _publicationEither;
    }

    const publication = _publicationEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      about,
      authors,
      datePublished,
      hasParts,
      isBasedOn,
      isPartOf,
      publication,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof CreativeWorkStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, CreativeWork> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      ArticleStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        CreativeWork
      >
    )
      .altLazy(
        () =>
          CreativeWorkSeriesStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          EpisodeStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          MediaObjectStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          Message.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          MusicAlbum.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          MusicComposition.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          MusicPlaylist.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWork
          >,
      )
      .altLazy(
        () =>
          MusicRecording.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWork
          >,
      )
      .altLazy(() =>
        CreativeWorkStatic.$propertiesFromRdf(parameters).map(
          (properties) => new CreativeWork(properties),
        ),
      );
  }

  export const $properties = {
    ...ThingStatic.$properties,
    about: { identifier: dataFactory.namedNode("http://schema.org/about") },
    authors: { identifier: dataFactory.namedNode("http://schema.org/author") },
    datePublished: {
      identifier: dataFactory.namedNode("http://schema.org/datePublished"),
    },
    hasParts: {
      identifier: dataFactory.namedNode("http://schema.org/hasPart"),
    },
    isBasedOn: {
      identifier: dataFactory.namedNode("http://schema.org/isBasedOn"),
    },
    isPartOf: {
      identifier: dataFactory.namedNode("http://schema.org/isPartOf"),
    },
    publication: {
      identifier: dataFactory.namedNode("http://schema.org/publication"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        CreativeWorkStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        CreativeWorkStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      CreativeWorkStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("creativeWork");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "creativeWork");
    triples.push(
      ...ThingStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}About`),
      predicate: CreativeWorkStatic.$properties.about["identifier"],
      subject,
    });
    triples.push(
      ...ThingStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}About`),
        variablePrefix: `${variablePrefix}About`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Authors`),
      predicate: CreativeWorkStatic.$properties.authors["identifier"],
      subject,
    });
    triples.push(
      ...AgentStub.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(`${variablePrefix}Authors`),
        variablePrefix: `${variablePrefix}Authors`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}DatePublished`),
      predicate: CreativeWorkStatic.$properties.datePublished["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}HasParts`),
      predicate: CreativeWorkStatic.$properties.hasParts["identifier"],
      subject,
    });
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}HasParts`),
        variablePrefix: `${variablePrefix}HasParts`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}IsBasedOn`),
      predicate: CreativeWorkStatic.$properties.isBasedOn["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}IsPartOf`),
      predicate: CreativeWorkStatic.$properties.isPartOf["identifier"],
      subject,
    });
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}IsPartOf`),
        variablePrefix: `${variablePrefix}IsPartOf`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Publication`),
      predicate: CreativeWorkStatic.$properties.publication["identifier"],
      subject,
    });
    triples.push(
      ...PublicationEventStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Publication`),
        variablePrefix: `${variablePrefix}Publication`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("creativeWork");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "creativeWork");
    for (const pattern of ThingStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}About`),
                predicate: CreativeWorkStatic.$properties.about["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...ThingStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}About`),
            variablePrefix: `${variablePrefix}About`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Authors`),
                predicate: CreativeWorkStatic.$properties.authors["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...AgentStub.$sparqlWherePatterns({
            subject: dataFactory.variable!(`${variablePrefix}Authors`),
            variablePrefix: `${variablePrefix}Authors`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}DatePublished`),
                predicate:
                  CreativeWorkStatic.$properties.datePublished["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}HasParts`),
                predicate:
                  CreativeWorkStatic.$properties.hasParts["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...CreativeWorkStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}HasParts`),
            variablePrefix: `${variablePrefix}HasParts`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}IsBasedOn`),
                predicate:
                  CreativeWorkStatic.$properties.isBasedOn["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}IsPartOf`),
                predicate:
                  CreativeWorkStatic.$properties.isPartOf["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...CreativeWorkStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}IsPartOf`),
            variablePrefix: `${variablePrefix}IsPartOf`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Publication`),
                predicate:
                  CreativeWorkStatic.$properties.publication["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...PublicationEventStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}Publication`),
            variablePrefix: `${variablePrefix}Publication`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MediaObject extends CreativeWork {
  override readonly $type: "MediaObject" | "ImageObject" | "TextObject" =
    "MediaObject";
  readonly contentUrl: purify.Maybe<rdfjs.NamedNode>;
  readonly encodingFormat: purify.Maybe<string>;
  readonly height: purify.Maybe<QuantitativeValueStub>;
  readonly width: purify.Maybe<QuantitativeValueStub>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly contentUrl?:
        | rdfjs.NamedNode
        | purify.Maybe<rdfjs.NamedNode>
        | string;
      readonly encodingFormat?: purify.Maybe<string> | string;
      readonly height?:
        | QuantitativeValueStub
        | purify.Maybe<QuantitativeValueStub>;
      readonly width?:
        | QuantitativeValueStub
        | purify.Maybe<QuantitativeValueStub>;
    } & ConstructorParameters<typeof CreativeWork>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.contentUrl)) {
      this.contentUrl = parameters.contentUrl;
    } else if (typeof parameters.contentUrl === "object") {
      this.contentUrl = purify.Maybe.of(parameters.contentUrl);
    } else if (typeof parameters.contentUrl === "string") {
      this.contentUrl = purify.Maybe.of(
        dataFactory.namedNode(parameters.contentUrl),
      );
    } else if (typeof parameters.contentUrl === "undefined") {
      this.contentUrl = purify.Maybe.empty();
    } else {
      this.contentUrl = parameters.contentUrl satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.encodingFormat)) {
      this.encodingFormat = parameters.encodingFormat;
    } else if (typeof parameters.encodingFormat === "string") {
      this.encodingFormat = purify.Maybe.of(parameters.encodingFormat);
    } else if (typeof parameters.encodingFormat === "undefined") {
      this.encodingFormat = purify.Maybe.empty();
    } else {
      this.encodingFormat = parameters.encodingFormat satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.height)) {
      this.height = parameters.height;
    } else if (
      typeof parameters.height === "object" &&
      parameters.height instanceof QuantitativeValueStub
    ) {
      this.height = purify.Maybe.of(parameters.height);
    } else if (typeof parameters.height === "undefined") {
      this.height = purify.Maybe.empty();
    } else {
      this.height = parameters.height satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.width)) {
      this.width = parameters.width;
    } else if (
      typeof parameters.width === "object" &&
      parameters.width instanceof QuantitativeValueStub
    ) {
      this.width = purify.Maybe.of(parameters.width);
    } else if (typeof parameters.width === "undefined") {
      this.width = purify.Maybe.empty();
    } else {
      this.width = parameters.width satisfies never;
    }
  }

  override get $identifier(): MediaObjectStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: MediaObject): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.contentUrl,
          other.contentUrl,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "contentUrl",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.encodingFormat,
          other.encodingFormat,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "encodingFormat",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.height,
          other.height,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "height",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.width,
          other.width,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "width",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.contentUrl.ifJust((_value0) => {
      _hasher.update(_value0.termType);
      _hasher.update(_value0.value);
    });
    this.encodingFormat.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.height.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    this.width.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    return _hasher;
  }

  override $toJson(): MediaObjectStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        contentUrl: this.contentUrl
          .map((_item) => ({ "@id": _item.value }))
          .extract(),
        encodingFormat: this.encodingFormat.map((_item) => _item).extract(),
        height: this.height.map((_item) => _item.$toJson()).extract(),
        width: this.width.map((_item) => _item.$toJson()).extract(),
      } satisfies MediaObjectStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MediaObject"),
      );
    }

    _resource.add(
      MediaObjectStatic.$properties.contentUrl["identifier"],
      this.contentUrl,
    );
    _resource.add(
      MediaObjectStatic.$properties.encodingFormat["identifier"],
      this.encodingFormat,
    );
    _resource.add(
      MediaObjectStatic.$properties.height["identifier"],
      this.height.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      MediaObjectStatic.$properties.width["identifier"],
      this.width.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MediaObjectStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MediaObject",
  );
  export type $Identifier = CreativeWorkStatic.$Identifier;
  export const $Identifier = CreativeWorkStatic.$Identifier;
  export type $Json = {
    readonly contentUrl: { readonly "@id": string } | undefined;
    readonly encodingFormat: string | undefined;
    readonly height: QuantitativeValueStub.$Json | undefined;
    readonly width: QuantitativeValueStub.$Json | undefined;
  } & CreativeWorkStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      contentUrl: purify.Maybe<rdfjs.NamedNode>;
      encodingFormat: purify.Maybe<string>;
      height: purify.Maybe<QuantitativeValueStub>;
      width: purify.Maybe<QuantitativeValueStub>;
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = CreativeWorkStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const contentUrl = purify.Maybe.fromNullable(_jsonObject["contentUrl"]).map(
      (_item) => dataFactory.namedNode(_item["@id"]),
    );
    const encodingFormat = purify.Maybe.fromNullable(
      _jsonObject["encodingFormat"],
    );
    const height = purify.Maybe.fromNullable(_jsonObject["height"]).map(
      (_item) => QuantitativeValueStub.$fromJson(_item).unsafeCoerce(),
    );
    const width = purify.Maybe.fromNullable(_jsonObject["width"]).map((_item) =>
      QuantitativeValueStub.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({
      ...$super0,
      $identifier,
      contentUrl,
      encodingFormat,
      height,
      width,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MediaObject> {
    return (
      ImageObject.$fromJson(json) as purify.Either<zod.ZodError, MediaObject>
    )
      .altLazy(
        () =>
          TextObject.$fromJson(json) as purify.Either<
            zod.ZodError,
            MediaObject
          >,
      )
      .altLazy(() =>
        $propertiesFromJson(json).map(
          (properties) => new MediaObject(properties),
        ),
      );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        CreativeWorkStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/contentUrl`, type: "Control" },
        { scope: `${scopePrefix}/properties/encodingFormat`, type: "Control" },
        QuantitativeValueStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/height`,
        }),
        QuantitativeValueStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/width`,
        }),
      ],
      label: "MediaObject",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["MediaObject", "ImageObject", "TextObject"]),
        contentUrl: zod.object({ "@id": zod.string().min(1) }).optional(),
        encodingFormat: zod.string().optional(),
        height: QuantitativeValueStub.$jsonZodSchema().optional(),
        width: QuantitativeValueStub.$jsonZodSchema().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      contentUrl: purify.Maybe<rdfjs.NamedNode>;
      encodingFormat: purify.Maybe<string>;
      height: purify.Maybe<QuantitativeValueStub>;
      width: purify.Maybe<QuantitativeValueStub>;
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromRdf>>
  > {
    const $super0Either = CreativeWorkStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MediaObject)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MediaObjectStatic.$Identifier = _resource.identifier;
    const _contentUrlEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<rdfjs.NamedNode>
    > = purify.Either.of(
      _resource
        .values($properties.contentUrl["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toIri())
        .toMaybe(),
    );
    if (_contentUrlEither.isLeft()) {
      return _contentUrlEither;
    }

    const contentUrl = _contentUrlEither.unsafeCoerce();
    const _encodingFormatEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.encodingFormat["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_encodingFormatEither.isLeft()) {
      return _encodingFormatEither;
    }

    const encodingFormat = _encodingFormatEither.unsafeCoerce();
    const _heightEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<QuantitativeValueStub>
    > = purify.Either.of(
      _resource
        .values($properties.height["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          QuantitativeValueStub.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_heightEither.isLeft()) {
      return _heightEither;
    }

    const height = _heightEither.unsafeCoerce();
    const _widthEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<QuantitativeValueStub>
    > = purify.Either.of(
      _resource
        .values($properties.width["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          QuantitativeValueStub.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_widthEither.isLeft()) {
      return _widthEither;
    }

    const width = _widthEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      contentUrl,
      encodingFormat,
      height,
      width,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MediaObjectStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MediaObject> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      ImageObject.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        MediaObject
      >
    )
      .altLazy(
        () =>
          TextObject.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            MediaObject
          >,
      )
      .altLazy(() =>
        MediaObjectStatic.$propertiesFromRdf(parameters).map(
          (properties) => new MediaObject(properties),
        ),
      );
  }

  export const $properties = {
    ...CreativeWorkStatic.$properties,
    contentUrl: {
      identifier: dataFactory.namedNode("http://schema.org/contentUrl"),
    },
    encodingFormat: {
      identifier: dataFactory.namedNode("http://schema.org/encodingFormat"),
    },
    height: { identifier: dataFactory.namedNode("http://schema.org/height") },
    width: { identifier: dataFactory.namedNode("http://schema.org/width") },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MediaObjectStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MediaObjectStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MediaObjectStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("mediaObject");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "mediaObject");
    triples.push(
      ...CreativeWorkStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ContentUrl`),
      predicate: MediaObjectStatic.$properties.contentUrl["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}EncodingFormat`),
      predicate: MediaObjectStatic.$properties.encodingFormat["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Height`),
      predicate: MediaObjectStatic.$properties.height["identifier"],
      subject,
    });
    triples.push(
      ...QuantitativeValueStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Height`),
        variablePrefix: `${variablePrefix}Height`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Width`),
      predicate: MediaObjectStatic.$properties.width["identifier"],
      subject,
    });
    triples.push(
      ...QuantitativeValueStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Width`),
        variablePrefix: `${variablePrefix}Width`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("mediaObject");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "mediaObject");
    for (const pattern of CreativeWorkStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}ContentUrl`),
                predicate:
                  MediaObjectStatic.$properties.contentUrl["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}EncodingFormat`,
                ),
                predicate:
                  MediaObjectStatic.$properties.encodingFormat["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Height`),
                predicate: MediaObjectStatic.$properties.height["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...QuantitativeValueStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}Height`),
            variablePrefix: `${variablePrefix}Height`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Width`),
                predicate: MediaObjectStatic.$properties.width["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...QuantitativeValueStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}Width`),
            variablePrefix: `${variablePrefix}Width`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class TextObject extends MediaObject {
  override readonly $type = "TextObject";
  readonly uriSpace: purify.Maybe<string>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly uriSpace?: purify.Maybe<string> | string;
    } & ConstructorParameters<typeof MediaObject>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.uriSpace)) {
      this.uriSpace = parameters.uriSpace;
    } else if (typeof parameters.uriSpace === "string") {
      this.uriSpace = purify.Maybe.of(parameters.uriSpace);
    } else if (typeof parameters.uriSpace === "undefined") {
      this.uriSpace = purify.Maybe.empty();
    } else {
      this.uriSpace = parameters.uriSpace satisfies never;
    }
  }

  override get $identifier(): TextObject.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: TextObject): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.uriSpace,
          other.uriSpace,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "uriSpace",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.uriSpace.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    return _hasher;
  }

  override $toJson(): TextObject.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        uriSpace: this.uriSpace.map((_item) => _item).extract(),
      } satisfies TextObject.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/TextObject"),
      );
    }

    _resource.add(TextObject.$properties.uriSpace["identifier"], this.uriSpace);
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace TextObject {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/TextObject",
  );
  export type $Identifier = MediaObjectStatic.$Identifier;
  export const $Identifier = MediaObjectStatic.$Identifier;
  export type $Json = {
    readonly uriSpace: string | undefined;
  } & MediaObjectStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      uriSpace: purify.Maybe<string>;
    } & $UnwrapR<ReturnType<typeof MediaObjectStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = MediaObjectStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const uriSpace = purify.Maybe.fromNullable(_jsonObject["uriSpace"]);
    return purify.Either.of({ ...$super0, $identifier, uriSpace });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, TextObject> {
    return $propertiesFromJson(json).map(
      (properties) => new TextObject(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        MediaObjectStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/uriSpace`, type: "Control" },
      ],
      label: "TextObject",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return MediaObjectStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("TextObject"),
        uriSpace: zod.string().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      uriSpace: purify.Maybe<string>;
    } & $UnwrapR<ReturnType<typeof MediaObjectStatic.$propertiesFromRdf>>
  > {
    const $super0Either = MediaObjectStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/TextObject)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: TextObject.$Identifier = _resource.identifier;
    const _uriSpaceEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.uriSpace["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_uriSpaceEither.isLeft()) {
      return _uriSpaceEither;
    }

    const uriSpace = _uriSpaceEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, uriSpace });
  }

  export function $fromRdf(
    parameters: Parameters<typeof TextObject.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, TextObject> {
    return TextObject.$propertiesFromRdf(parameters).map(
      (properties) => new TextObject(properties),
    );
  }

  export const $properties = {
    ...MediaObjectStatic.$properties,
    uriSpace: {
      identifier: dataFactory.namedNode("http://rdfs.org/ns/void#uriSpace"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        TextObject.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        TextObject.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      TextObject.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("textObject");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "textObject");
    triples.push(
      ...MediaObjectStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}UriSpace`),
      predicate: TextObject.$properties.uriSpace["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("textObject");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "textObject");
    for (const pattern of MediaObjectStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}UriSpace`),
                predicate: TextObject.$properties.uriSpace["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class CreativeWorkStub extends ThingStub {
  override readonly $type:
    | "CreativeWorkStub"
    | "ArticleStub"
    | "CreativeWorkSeriesStub"
    | "EpisodeStub"
    | "ImageObjectStub"
    | "MediaObjectStub"
    | "MessageStub"
    | "MusicAlbumStub"
    | "MusicCompositionStub"
    | "MusicPlaylistStub"
    | "MusicRecordingStub"
    | "RadioEpisodeStub"
    | "RadioSeriesStub"
    | "ReportStub"
    | "TextObjectStub" = "CreativeWorkStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof ThingStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): CreativeWorkStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/CreativeWork"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace CreativeWorkStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/CreativeWork",
  );
  export type $Identifier = ThingStubStatic.$Identifier;
  export const $Identifier = ThingStubStatic.$Identifier;
  export type $Json = ThingStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, CreativeWorkStub> {
    return (
      ArticleStubStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        CreativeWorkStub
      >
    )
      .altLazy(
        () =>
          CreativeWorkSeriesStubStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          EpisodeStubStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MediaObjectStubStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MessageStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MusicAlbumStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MusicCompositionStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MusicPlaylistStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MusicRecordingStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            CreativeWorkStub
          >,
      )
      .altLazy(() =>
        $propertiesFromJson(json).map(
          (properties) => new CreativeWorkStub(properties),
        ),
      );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ThingStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "CreativeWorkStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "CreativeWorkStub",
          "ArticleStub",
          "CreativeWorkSeriesStub",
          "EpisodeStub",
          "ImageObjectStub",
          "MediaObjectStub",
          "MessageStub",
          "MusicAlbumStub",
          "MusicCompositionStub",
          "MusicPlaylistStub",
          "MusicRecordingStub",
          "RadioEpisodeStub",
          "RadioSeriesStub",
          "ReportStub",
          "TextObjectStub",
        ]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ThingStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/CreativeWork)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: CreativeWorkStubStatic.$Identifier =
      _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof CreativeWorkStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, CreativeWorkStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      ArticleStubStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        CreativeWorkStub
      >
    )
      .altLazy(
        () =>
          CreativeWorkSeriesStubStatic.$fromRdf(
            otherParameters,
          ) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          EpisodeStubStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MediaObjectStubStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MessageStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MusicAlbumStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MusicCompositionStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MusicPlaylistStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWorkStub
          >,
      )
      .altLazy(
        () =>
          MusicRecordingStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            CreativeWorkStub
          >,
      )
      .altLazy(() =>
        CreativeWorkStubStatic.$propertiesFromRdf(parameters).map(
          (properties) => new CreativeWorkStub(properties),
        ),
      );
  }

  export const $properties = { ...ThingStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        CreativeWorkStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      CreativeWorkStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("creativeWorkStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "creativeWorkStub");
    triples.push(
      ...ThingStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("creativeWorkStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "creativeWorkStub");
    for (const pattern of ThingStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MediaObjectStub extends CreativeWorkStub {
  override readonly $type:
    | "MediaObjectStub"
    | "ImageObjectStub"
    | "TextObjectStub" = "MediaObjectStub";
  readonly contentUrl: purify.Maybe<rdfjs.NamedNode>;
  readonly encodingFormat: purify.Maybe<string>;
  readonly height: purify.Maybe<QuantitativeValueStub>;
  readonly width: purify.Maybe<QuantitativeValueStub>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly contentUrl?:
        | rdfjs.NamedNode
        | purify.Maybe<rdfjs.NamedNode>
        | string;
      readonly encodingFormat?: purify.Maybe<string> | string;
      readonly height?:
        | QuantitativeValueStub
        | purify.Maybe<QuantitativeValueStub>;
      readonly width?:
        | QuantitativeValueStub
        | purify.Maybe<QuantitativeValueStub>;
    } & ConstructorParameters<typeof CreativeWorkStub>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.contentUrl)) {
      this.contentUrl = parameters.contentUrl;
    } else if (typeof parameters.contentUrl === "object") {
      this.contentUrl = purify.Maybe.of(parameters.contentUrl);
    } else if (typeof parameters.contentUrl === "string") {
      this.contentUrl = purify.Maybe.of(
        dataFactory.namedNode(parameters.contentUrl),
      );
    } else if (typeof parameters.contentUrl === "undefined") {
      this.contentUrl = purify.Maybe.empty();
    } else {
      this.contentUrl = parameters.contentUrl satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.encodingFormat)) {
      this.encodingFormat = parameters.encodingFormat;
    } else if (typeof parameters.encodingFormat === "string") {
      this.encodingFormat = purify.Maybe.of(parameters.encodingFormat);
    } else if (typeof parameters.encodingFormat === "undefined") {
      this.encodingFormat = purify.Maybe.empty();
    } else {
      this.encodingFormat = parameters.encodingFormat satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.height)) {
      this.height = parameters.height;
    } else if (
      typeof parameters.height === "object" &&
      parameters.height instanceof QuantitativeValueStub
    ) {
      this.height = purify.Maybe.of(parameters.height);
    } else if (typeof parameters.height === "undefined") {
      this.height = purify.Maybe.empty();
    } else {
      this.height = parameters.height satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.width)) {
      this.width = parameters.width;
    } else if (
      typeof parameters.width === "object" &&
      parameters.width instanceof QuantitativeValueStub
    ) {
      this.width = purify.Maybe.of(parameters.width);
    } else if (typeof parameters.width === "undefined") {
      this.width = purify.Maybe.empty();
    } else {
      this.width = parameters.width satisfies never;
    }
  }

  override get $identifier(): MediaObjectStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: MediaObjectStub): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.contentUrl,
          other.contentUrl,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "contentUrl",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.encodingFormat,
          other.encodingFormat,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "encodingFormat",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.height,
          other.height,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "height",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.width,
          other.width,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "width",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.contentUrl.ifJust((_value0) => {
      _hasher.update(_value0.termType);
      _hasher.update(_value0.value);
    });
    this.encodingFormat.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.height.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    this.width.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    return _hasher;
  }

  override $toJson(): MediaObjectStubStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        contentUrl: this.contentUrl
          .map((_item) => ({ "@id": _item.value }))
          .extract(),
        encodingFormat: this.encodingFormat.map((_item) => _item).extract(),
        height: this.height.map((_item) => _item.$toJson()).extract(),
        width: this.width.map((_item) => _item.$toJson()).extract(),
      } satisfies MediaObjectStubStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MediaObject"),
      );
    }

    _resource.add(
      MediaObjectStatic.$properties.contentUrl["identifier"],
      this.contentUrl,
    );
    _resource.add(
      MediaObjectStatic.$properties.encodingFormat["identifier"],
      this.encodingFormat,
    );
    _resource.add(
      MediaObjectStatic.$properties.height["identifier"],
      this.height.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      MediaObjectStatic.$properties.width["identifier"],
      this.width.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MediaObjectStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MediaObject",
  );
  export type $Identifier = CreativeWorkStubStatic.$Identifier;
  export const $Identifier = CreativeWorkStubStatic.$Identifier;
  export type $Json = {
    readonly contentUrl: { readonly "@id": string } | undefined;
    readonly encodingFormat: string | undefined;
    readonly height: QuantitativeValueStub.$Json | undefined;
    readonly width: QuantitativeValueStub.$Json | undefined;
  } & CreativeWorkStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      contentUrl: purify.Maybe<rdfjs.NamedNode>;
      encodingFormat: purify.Maybe<string>;
      height: purify.Maybe<QuantitativeValueStub>;
      width: purify.Maybe<QuantitativeValueStub>;
    } & $UnwrapR<ReturnType<typeof CreativeWorkStubStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      CreativeWorkStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const contentUrl = purify.Maybe.fromNullable(_jsonObject["contentUrl"]).map(
      (_item) => dataFactory.namedNode(_item["@id"]),
    );
    const encodingFormat = purify.Maybe.fromNullable(
      _jsonObject["encodingFormat"],
    );
    const height = purify.Maybe.fromNullable(_jsonObject["height"]).map(
      (_item) => QuantitativeValueStub.$fromJson(_item).unsafeCoerce(),
    );
    const width = purify.Maybe.fromNullable(_jsonObject["width"]).map((_item) =>
      QuantitativeValueStub.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({
      ...$super0,
      $identifier,
      contentUrl,
      encodingFormat,
      height,
      width,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MediaObjectStub> {
    return (
      ImageObjectStub.$fromJson(json) as purify.Either<
        zod.ZodError,
        MediaObjectStub
      >
    )
      .altLazy(
        () =>
          TextObjectStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            MediaObjectStub
          >,
      )
      .altLazy(() =>
        $propertiesFromJson(json).map(
          (properties) => new MediaObjectStub(properties),
        ),
      );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        CreativeWorkStubStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/contentUrl`, type: "Control" },
        { scope: `${scopePrefix}/properties/encodingFormat`, type: "Control" },
        QuantitativeValueStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/height`,
        }),
        QuantitativeValueStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/width`,
        }),
      ],
      label: "MediaObjectStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "MediaObjectStub",
          "ImageObjectStub",
          "TextObjectStub",
        ]),
        contentUrl: zod.object({ "@id": zod.string().min(1) }).optional(),
        encodingFormat: zod.string().optional(),
        height: QuantitativeValueStub.$jsonZodSchema().optional(),
        width: QuantitativeValueStub.$jsonZodSchema().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      contentUrl: purify.Maybe<rdfjs.NamedNode>;
      encodingFormat: purify.Maybe<string>;
      height: purify.Maybe<QuantitativeValueStub>;
      width: purify.Maybe<QuantitativeValueStub>;
    } & $UnwrapR<ReturnType<typeof CreativeWorkStubStatic.$propertiesFromRdf>>
  > {
    const $super0Either = CreativeWorkStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MediaObject)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MediaObjectStubStatic.$Identifier = _resource.identifier;
    const _contentUrlEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<rdfjs.NamedNode>
    > = purify.Either.of(
      _resource
        .values($properties.contentUrl["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toIri())
        .toMaybe(),
    );
    if (_contentUrlEither.isLeft()) {
      return _contentUrlEither;
    }

    const contentUrl = _contentUrlEither.unsafeCoerce();
    const _encodingFormatEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.encodingFormat["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_encodingFormatEither.isLeft()) {
      return _encodingFormatEither;
    }

    const encodingFormat = _encodingFormatEither.unsafeCoerce();
    const _heightEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<QuantitativeValueStub>
    > = purify.Either.of(
      _resource
        .values($properties.height["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          QuantitativeValueStub.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_heightEither.isLeft()) {
      return _heightEither;
    }

    const height = _heightEither.unsafeCoerce();
    const _widthEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<QuantitativeValueStub>
    > = purify.Either.of(
      _resource
        .values($properties.width["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          QuantitativeValueStub.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_widthEither.isLeft()) {
      return _widthEither;
    }

    const width = _widthEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      contentUrl,
      encodingFormat,
      height,
      width,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MediaObjectStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MediaObjectStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      ImageObjectStub.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        MediaObjectStub
      >
    )
      .altLazy(
        () =>
          TextObjectStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            MediaObjectStub
          >,
      )
      .altLazy(() =>
        MediaObjectStubStatic.$propertiesFromRdf(parameters).map(
          (properties) => new MediaObjectStub(properties),
        ),
      );
  }

  export const $properties = {
    ...CreativeWorkStubStatic.$properties,
    contentUrl: {
      identifier: dataFactory.namedNode("http://schema.org/contentUrl"),
    },
    encodingFormat: {
      identifier: dataFactory.namedNode("http://schema.org/encodingFormat"),
    },
    height: { identifier: dataFactory.namedNode("http://schema.org/height") },
    width: { identifier: dataFactory.namedNode("http://schema.org/width") },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MediaObjectStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MediaObjectStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MediaObjectStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("mediaObjectStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "mediaObjectStub");
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ContentUrl`),
      predicate: MediaObjectStatic.$properties.contentUrl["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}EncodingFormat`),
      predicate: MediaObjectStatic.$properties.encodingFormat["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Height`),
      predicate: MediaObjectStatic.$properties.height["identifier"],
      subject,
    });
    triples.push(
      ...QuantitativeValueStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Height`),
        variablePrefix: `${variablePrefix}Height`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Width`),
      predicate: MediaObjectStatic.$properties.width["identifier"],
      subject,
    });
    triples.push(
      ...QuantitativeValueStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Width`),
        variablePrefix: `${variablePrefix}Width`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("mediaObjectStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "mediaObjectStub");
    for (const pattern of CreativeWorkStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}ContentUrl`),
                predicate:
                  MediaObjectStatic.$properties.contentUrl["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}EncodingFormat`,
                ),
                predicate:
                  MediaObjectStatic.$properties.encodingFormat["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Height`),
                predicate: MediaObjectStatic.$properties.height["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...QuantitativeValueStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}Height`),
            variablePrefix: `${variablePrefix}Height`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Width`),
                predicate: MediaObjectStatic.$properties.width["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...QuantitativeValueStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}Width`),
            variablePrefix: `${variablePrefix}Width`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class TextObjectStub extends MediaObjectStub {
  override readonly $type = "TextObjectStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof MediaObjectStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): TextObjectStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/TextObject"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace TextObjectStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/TextObject",
  );
  export type $Identifier = MediaObjectStubStatic.$Identifier;
  export const $Identifier = MediaObjectStubStatic.$Identifier;
  export type $Json = MediaObjectStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof MediaObjectStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      MediaObjectStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, TextObjectStub> {
    return $propertiesFromJson(json).map(
      (properties) => new TextObjectStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [MediaObjectStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "TextObjectStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return MediaObjectStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("TextObjectStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof MediaObjectStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = MediaObjectStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/TextObject)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: TextObjectStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof TextObjectStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, TextObjectStub> {
    return TextObjectStub.$propertiesFromRdf(parameters).map(
      (properties) => new TextObjectStub(properties),
    );
  }

  export const $properties = { ...MediaObjectStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        TextObjectStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        TextObjectStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      TextObjectStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("textObjectStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "textObjectStub");
    triples.push(
      ...MediaObjectStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("textObjectStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "textObjectStub");
    for (const pattern of MediaObjectStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class StructuredValue extends Intangible {
  override readonly $type:
    | "StructuredValue"
    | "MonetaryAmount"
    | "QuantitativeValue" = "StructuredValue";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof Intangible>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): StructuredValueStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/StructuredValue"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace StructuredValueStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/StructuredValue",
  );
  export type $Identifier = IntangibleStatic.$Identifier;
  export const $Identifier = IntangibleStatic.$Identifier;
  export type $Json = IntangibleStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, StructuredValue> {
    return (
      MonetaryAmount.$fromJson(json) as purify.Either<
        zod.ZodError,
        StructuredValue
      >
    )
      .altLazy(
        () =>
          QuantitativeValue.$fromJson(json) as purify.Either<
            zod.ZodError,
            StructuredValue
          >,
      )
      .altLazy(() =>
        $propertiesFromJson(json).map(
          (properties) => new StructuredValue(properties),
        ),
      );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IntangibleStatic.$jsonUiSchema({ scopePrefix })],
      label: "StructuredValue",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "StructuredValue",
          "MonetaryAmount",
          "QuantitativeValue",
        ]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IntangibleStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/StructuredValue)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: StructuredValueStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof StructuredValueStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, StructuredValue> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      MonetaryAmount.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        StructuredValue
      >
    )
      .altLazy(
        () =>
          QuantitativeValue.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            StructuredValue
          >,
      )
      .altLazy(() =>
        StructuredValueStatic.$propertiesFromRdf(parameters).map(
          (properties) => new StructuredValue(properties),
        ),
      );
  }

  export const $properties = { ...IntangibleStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        StructuredValueStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        StructuredValueStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      StructuredValueStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("structuredValue");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "structuredValue");
    triples.push(
      ...IntangibleStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("structuredValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "structuredValue");
    for (const pattern of IntangibleStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Service extends Intangible {
  override readonly $type:
    | "Service"
    | "BroadcastService"
    | "RadioBroadcastService" = "Service";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof Intangible>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): ServiceStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Service"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ServiceStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Service",
  );
  export type $Identifier = IntangibleStatic.$Identifier;
  export const $Identifier = IntangibleStatic.$Identifier;
  export type $Json = IntangibleStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Service> {
    return (
      BroadcastServiceStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        Service
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map((properties) => new Service(properties)),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IntangibleStatic.$jsonUiSchema({ scopePrefix })],
      label: "Service",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "Service",
          "BroadcastService",
          "RadioBroadcastService",
        ]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IntangibleStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Service)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ServiceStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ServiceStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Service> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      BroadcastServiceStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Service
      >
    ).altLazy(() =>
      ServiceStatic.$propertiesFromRdf(parameters).map(
        (properties) => new Service(properties),
      ),
    );
  }

  export const $properties = { ...IntangibleStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ServiceStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ServiceStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ServiceStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("service");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "service");
    triples.push(
      ...IntangibleStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("service");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "service");
    for (const pattern of IntangibleStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class IntangibleStub extends ThingStub {
  override readonly $type:
    | "IntangibleStub"
    | "BroadcastServiceStub"
    | "InvoiceStub"
    | "ItemListStub"
    | "ListItemStub"
    | "MonetaryAmountStub"
    | "MusicArtistRoleStub"
    | "OccupationStub"
    | "OrderStub"
    | "QuantitativeValueStub"
    | "RadioBroadcastServiceStub"
    | "RoleStub"
    | "ServiceStub"
    | "StructuredValueStub" = "IntangibleStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof ThingStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): IntangibleStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Intangible"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace IntangibleStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Intangible",
  );
  export type $Identifier = ThingStubStatic.$Identifier;
  export const $Identifier = ThingStubStatic.$Identifier;
  export type $Json = ThingStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, IntangibleStub> {
    return (
      ServiceStubStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        IntangibleStub
      >
    )
      .altLazy(
        () =>
          InvoiceStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          ItemListStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          ListItemStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          StructuredValueStubStatic.$fromJson(json) as purify.Either<
            zod.ZodError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          MusicArtistRoleStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          OccupationStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          OrderStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          RoleStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            IntangibleStub
          >,
      )
      .altLazy(() =>
        $propertiesFromJson(json).map(
          (properties) => new IntangibleStub(properties),
        ),
      );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ThingStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "IntangibleStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "IntangibleStub",
          "BroadcastServiceStub",
          "InvoiceStub",
          "ItemListStub",
          "ListItemStub",
          "MonetaryAmountStub",
          "MusicArtistRoleStub",
          "OccupationStub",
          "OrderStub",
          "QuantitativeValueStub",
          "RadioBroadcastServiceStub",
          "RoleStub",
          "ServiceStub",
          "StructuredValueStub",
        ]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ThingStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Intangible)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: IntangibleStubStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof IntangibleStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, IntangibleStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      ServiceStubStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        IntangibleStub
      >
    )
      .altLazy(
        () =>
          InvoiceStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          ItemListStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          ListItemStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          StructuredValueStubStatic.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          MusicArtistRoleStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          OccupationStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          OrderStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            IntangibleStub
          >,
      )
      .altLazy(
        () =>
          RoleStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            IntangibleStub
          >,
      )
      .altLazy(() =>
        IntangibleStubStatic.$propertiesFromRdf(parameters).map(
          (properties) => new IntangibleStub(properties),
        ),
      );
  }

  export const $properties = { ...ThingStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        IntangibleStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        IntangibleStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      IntangibleStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("intangibleStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "intangibleStub");
    triples.push(
      ...ThingStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("intangibleStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "intangibleStub");
    for (const pattern of ThingStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class RoleStub extends IntangibleStub {
  protected readonly _$identifierPrefix?: string;
  override readonly $type = "RoleStub";
  readonly endDate: purify.Maybe<Date>;
  readonly roleName: purify.Maybe<rdfjs.NamedNode>;
  readonly startDate: purify.Maybe<Date>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly $identifierPrefix?: string;
      readonly endDate?: Date | purify.Maybe<Date>;
      readonly roleName?:
        | rdfjs.NamedNode
        | purify.Maybe<rdfjs.NamedNode>
        | string;
      readonly startDate?: Date | purify.Maybe<Date>;
    } & ConstructorParameters<typeof IntangibleStub>[0],
  ) {
    super(parameters);
    this._$identifierPrefix = parameters.$identifierPrefix;
    if (purify.Maybe.isMaybe(parameters.endDate)) {
      this.endDate = parameters.endDate;
    } else if (
      typeof parameters.endDate === "object" &&
      parameters.endDate instanceof Date
    ) {
      this.endDate = purify.Maybe.of(parameters.endDate);
    } else if (typeof parameters.endDate === "undefined") {
      this.endDate = purify.Maybe.empty();
    } else {
      this.endDate = parameters.endDate satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.roleName)) {
      this.roleName = parameters.roleName;
    } else if (typeof parameters.roleName === "object") {
      this.roleName = purify.Maybe.of(parameters.roleName);
    } else if (typeof parameters.roleName === "string") {
      this.roleName = purify.Maybe.of(
        dataFactory.namedNode(parameters.roleName),
      );
    } else if (typeof parameters.roleName === "undefined") {
      this.roleName = purify.Maybe.empty();
    } else {
      this.roleName = parameters.roleName satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.startDate)) {
      this.startDate = parameters.startDate;
    } else if (
      typeof parameters.startDate === "object" &&
      parameters.startDate instanceof Date
    ) {
      this.startDate = purify.Maybe.of(parameters.startDate);
    } else if (typeof parameters.startDate === "undefined") {
      this.startDate = purify.Maybe.empty();
    } else {
      this.startDate = parameters.startDate satisfies never;
    }
  }

  override get $identifier(): RoleStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $equals(other: RoleStub): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.endDate,
          other.endDate,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "endDate",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.roleName,
          other.roleName,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "roleName",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.startDate,
          other.startDate,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "startDate",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.endDate.ifJust((_value0) => {
      _hasher.update(_value0.toISOString());
    });
    this.roleName.ifJust((_value0) => {
      _hasher.update(_value0.termType);
      _hasher.update(_value0.value);
    });
    this.startDate.ifJust((_value0) => {
      _hasher.update(_value0.toISOString());
    });
    return _hasher;
  }

  override $toJson(): RoleStub.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        endDate: this.endDate
          .map((_item) => _item.toISOString().replace(/T.*$/, ""))
          .extract(),
        roleName: this.roleName
          .map((_item) => ({ "@id": _item.value }))
          .extract(),
        startDate: this.startDate
          .map((_item) => _item.toISOString().replace(/T.*$/, ""))
          .extract(),
      } satisfies RoleStub.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Role"),
      );
    }

    _resource.add(
      RoleStub.$properties.endDate["identifier"],
      this.endDate.map((_value) =>
        rdfLiteral.toRdf(_value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.date,
        }),
      ),
    );
    _resource.add(RoleStub.$properties.roleName["identifier"], this.roleName);
    _resource.add(
      RoleStub.$properties.startDate["identifier"],
      this.startDate.map((_value) =>
        rdfLiteral.toRdf(_value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.date,
        }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RoleStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Role",
  );
  export type $Identifier = IntangibleStubStatic.$Identifier;
  export const $Identifier = IntangibleStubStatic.$Identifier;
  export type $Json = {
    readonly endDate: string | undefined;
    readonly roleName: { readonly "@id": string } | undefined;
    readonly startDate: string | undefined;
  } & IntangibleStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      endDate: purify.Maybe<Date>;
      roleName: purify.Maybe<rdfjs.NamedNode>;
      startDate: purify.Maybe<Date>;
    } & $UnwrapR<ReturnType<typeof IntangibleStubStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const endDate = purify.Maybe.fromNullable(_jsonObject["endDate"]).map(
      (_item) => new Date(_item),
    );
    const roleName = purify.Maybe.fromNullable(_jsonObject["roleName"]).map(
      (_item) => dataFactory.namedNode(_item["@id"]),
    );
    const startDate = purify.Maybe.fromNullable(_jsonObject["startDate"]).map(
      (_item) => new Date(_item),
    );
    return purify.Either.of({
      ...$super0,
      $identifier,
      endDate,
      roleName,
      startDate,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RoleStub> {
    return $propertiesFromJson(json).map(
      (properties) => new RoleStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        IntangibleStubStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/endDate`, type: "Control" },
        { scope: `${scopePrefix}/properties/roleName`, type: "Control" },
        { scope: `${scopePrefix}/properties/startDate`, type: "Control" },
      ],
      label: "RoleStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("RoleStub"),
        endDate: zod.string().date().optional(),
        roleName: zod.object({ "@id": zod.string().min(1) }).optional(),
        startDate: zod.string().date().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      endDate: purify.Maybe<Date>;
      roleName: purify.Maybe<rdfjs.NamedNode>;
      startDate: purify.Maybe<Date>;
    } & $UnwrapR<ReturnType<typeof IntangibleStubStatic.$propertiesFromRdf>>
  > {
    const $super0Either = IntangibleStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Role)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: RoleStub.$Identifier = _resource.identifier;
    const _endDateEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<Date>
    > = purify.Either.of(
      _resource
        .values($properties.endDate["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toDate())
        .toMaybe(),
    );
    if (_endDateEither.isLeft()) {
      return _endDateEither;
    }

    const endDate = _endDateEither.unsafeCoerce();
    const _roleNameEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<rdfjs.NamedNode>
    > = purify.Either.of(
      _resource
        .values($properties.roleName["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toIri())
        .toMaybe(),
    );
    if (_roleNameEither.isLeft()) {
      return _roleNameEither;
    }

    const roleName = _roleNameEither.unsafeCoerce();
    const _startDateEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<Date>
    > = purify.Either.of(
      _resource
        .values($properties.startDate["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toDate())
        .toMaybe(),
    );
    if (_startDateEither.isLeft()) {
      return _startDateEither;
    }

    const startDate = _startDateEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      endDate,
      roleName,
      startDate,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof RoleStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, RoleStub> {
    return RoleStub.$propertiesFromRdf(parameters).map(
      (properties) => new RoleStub(properties),
    );
  }

  export const $properties = {
    ...IntangibleStubStatic.$properties,
    endDate: { identifier: dataFactory.namedNode("http://schema.org/endDate") },
    roleName: {
      identifier: dataFactory.namedNode("http://schema.org/roleName"),
    },
    startDate: {
      identifier: dataFactory.namedNode("http://schema.org/startDate"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RoleStub.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RoleStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RoleStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("roleStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "roleStub");
    triples.push(
      ...IntangibleStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}EndDate`),
      predicate: RoleStub.$properties.endDate["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}RoleName`),
      predicate: RoleStub.$properties.roleName["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}StartDate`),
      predicate: RoleStub.$properties.startDate["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("roleStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "roleStub");
    for (const pattern of IntangibleStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}EndDate`),
                predicate: RoleStub.$properties.endDate["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}RoleName`),
                predicate: RoleStub.$properties.roleName["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}StartDate`),
                predicate: RoleStub.$properties.startDate["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Article extends CreativeWork {
  override readonly $type: "Article" | "Report" = "Article";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof CreativeWork>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): ArticleStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Article"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ArticleStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Article",
  );
  export type $Identifier = CreativeWorkStatic.$Identifier;
  export const $Identifier = CreativeWorkStatic.$Identifier;
  export type $Json = CreativeWorkStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = CreativeWorkStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Article> {
    return (
      Report.$fromJson(json) as purify.Either<zod.ZodError, Article>
    ).altLazy(() =>
      $propertiesFromJson(json).map((properties) => new Article(properties)),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [CreativeWorkStatic.$jsonUiSchema({ scopePrefix })],
      label: "Article",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["Article", "Report"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = CreativeWorkStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Article)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ArticleStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ArticleStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Article> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      Report.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Article
      >
    ).altLazy(() =>
      ArticleStatic.$propertiesFromRdf(parameters).map(
        (properties) => new Article(properties),
      ),
    );
  }

  export const $properties = { ...CreativeWorkStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ArticleStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ArticleStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ArticleStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("article");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "article");
    triples.push(
      ...CreativeWorkStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("article");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "article");
    for (const pattern of CreativeWorkStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Report extends Article {
  override readonly $type = "Report";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof Article>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): Report.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Report"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace Report {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Report",
  );
  export type $Identifier = ArticleStatic.$Identifier;
  export const $Identifier = ArticleStatic.$Identifier;
  export type $Json = ArticleStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ArticleStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ArticleStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Report> {
    return $propertiesFromJson(json).map(
      (properties) => new Report(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ArticleStatic.$jsonUiSchema({ scopePrefix })],
      label: "Report",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ArticleStatic.$jsonZodSchema().merge(
      zod.object({ "@id": zod.string().min(1), $type: zod.literal("Report") }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ArticleStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ArticleStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Report)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: Report.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof Report.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Report> {
    return Report.$propertiesFromRdf(parameters).map(
      (properties) => new Report(properties),
    );
  }

  export const $properties = { ...ArticleStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Report.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Report.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Report.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("report");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "report");
    triples.push(
      ...ArticleStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("report");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "report");
    for (const pattern of ArticleStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ArticleStub extends CreativeWorkStub {
  override readonly $type: "ArticleStub" | "ReportStub" = "ArticleStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof CreativeWorkStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): ArticleStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Article"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ArticleStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Article",
  );
  export type $Identifier = CreativeWorkStubStatic.$Identifier;
  export const $Identifier = CreativeWorkStubStatic.$Identifier;
  export type $Json = CreativeWorkStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      CreativeWorkStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ArticleStub> {
    return (
      ReportStub.$fromJson(json) as purify.Either<zod.ZodError, ArticleStub>
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new ArticleStub(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [CreativeWorkStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "ArticleStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["ArticleStub", "ReportStub"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = CreativeWorkStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Article)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ArticleStubStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ArticleStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ArticleStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      ReportStub.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        ArticleStub
      >
    ).altLazy(() =>
      ArticleStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new ArticleStub(properties),
      ),
    );
  }

  export const $properties = { ...CreativeWorkStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ArticleStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ArticleStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ArticleStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("articleStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "articleStub");
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("articleStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "articleStub");
    for (const pattern of CreativeWorkStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ReportStub extends ArticleStub {
  override readonly $type = "ReportStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof ArticleStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): ReportStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Report"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ReportStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Report",
  );
  export type $Identifier = ArticleStubStatic.$Identifier;
  export const $Identifier = ArticleStubStatic.$Identifier;
  export type $Json = ArticleStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ArticleStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ArticleStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ReportStub> {
    return $propertiesFromJson(json).map(
      (properties) => new ReportStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ArticleStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "ReportStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ArticleStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ReportStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ArticleStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ArticleStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Report)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ReportStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ReportStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ReportStub> {
    return ReportStub.$propertiesFromRdf(parameters).map(
      (properties) => new ReportStub(properties),
    );
  }

  export const $properties = { ...ArticleStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ReportStub.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ReportStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ReportStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("reportStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "reportStub");
    triples.push(
      ...ArticleStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("reportStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "reportStub");
    for (const pattern of ArticleStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class CreativeWorkSeries extends CreativeWork {
  override readonly $type: "CreativeWorkSeries" | "RadioSeries" =
    "CreativeWorkSeries";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof CreativeWork>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): CreativeWorkSeriesStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/CreativeWorkSeries"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace CreativeWorkSeriesStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/CreativeWorkSeries",
  );
  export type $Identifier = CreativeWorkStatic.$Identifier;
  export const $Identifier = CreativeWorkStatic.$Identifier;
  export type $Json = CreativeWorkStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = CreativeWorkStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, CreativeWorkSeries> {
    return (
      RadioSeries.$fromJson(json) as purify.Either<
        zod.ZodError,
        CreativeWorkSeries
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new CreativeWorkSeries(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [CreativeWorkStatic.$jsonUiSchema({ scopePrefix })],
      label: "CreativeWorkSeries",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["CreativeWorkSeries", "RadioSeries"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = CreativeWorkStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/CreativeWorkSeries)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: CreativeWorkSeriesStatic.$Identifier =
      _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<
      typeof CreativeWorkSeriesStatic.$propertiesFromRdf
    >[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, CreativeWorkSeries> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      RadioSeries.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        CreativeWorkSeries
      >
    ).altLazy(() =>
      CreativeWorkSeriesStatic.$propertiesFromRdf(parameters).map(
        (properties) => new CreativeWorkSeries(properties),
      ),
    );
  }

  export const $properties = { ...CreativeWorkStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        CreativeWorkSeriesStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        CreativeWorkSeriesStatic.$sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      CreativeWorkSeriesStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("creativeWorkSeries");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "creativeWorkSeries");
    triples.push(
      ...CreativeWorkStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("creativeWorkSeries");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "creativeWorkSeries");
    for (const pattern of CreativeWorkStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class RadioSeries extends CreativeWorkSeries {
  override readonly $type = "RadioSeries";
  episodes: RadioEpisodeStub[];

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly episodes?: readonly RadioEpisodeStub[];
    } & ConstructorParameters<typeof CreativeWorkSeries>[0],
  ) {
    super(parameters);
    if (typeof parameters.episodes === "undefined") {
      this.episodes = [];
    } else if (typeof parameters.episodes === "object") {
      this.episodes = parameters.episodes.concat();
    } else {
      this.episodes = parameters.episodes satisfies never;
    }
  }

  override get $identifier(): RadioSeries.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: RadioSeries): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.episodes,
          other.episodes,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "episodes",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.episodes) {
      _item0.$hash(_hasher);
    }

    return _hasher;
  }

  override $toJson(): RadioSeries.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        episodes: this.episodes.map((_item) => _item.$toJson()),
      } satisfies RadioSeries.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/RadioSeries"),
      );
    }

    _resource.add(
      RadioSeries.$properties.episodes["identifier"],
      this.episodes.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RadioSeries {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/RadioSeries",
  );
  export type $Identifier = CreativeWorkSeriesStatic.$Identifier;
  export const $Identifier = CreativeWorkSeriesStatic.$Identifier;
  export type $Json = {
    readonly episodes: readonly RadioEpisodeStub.$Json[];
  } & CreativeWorkSeriesStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      episodes: RadioEpisodeStub[];
    } & $UnwrapR<
      ReturnType<typeof CreativeWorkSeriesStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      CreativeWorkSeriesStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const episodes = _jsonObject["episodes"].map((_item) =>
      RadioEpisodeStub.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ...$super0, $identifier, episodes });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RadioSeries> {
    return $propertiesFromJson(json).map(
      (properties) => new RadioSeries(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        CreativeWorkSeriesStatic.$jsonUiSchema({ scopePrefix }),
        RadioEpisodeStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/episodes`,
        }),
      ],
      label: "RadioSeries",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkSeriesStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("RadioSeries"),
        episodes: RadioEpisodeStub.$jsonZodSchema()
          .array()
          .default(() => []),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      episodes: RadioEpisodeStub[];
    } & $UnwrapR<ReturnType<typeof CreativeWorkSeriesStatic.$propertiesFromRdf>>
  > {
    const $super0Either = CreativeWorkSeriesStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/RadioSeries)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: RadioSeries.$Identifier = _resource.identifier;
    const _episodesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      RadioEpisodeStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.episodes["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              RadioEpisodeStub.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_episodesEither.isLeft()) {
      return _episodesEither;
    }

    const episodes = _episodesEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, episodes });
  }

  export function $fromRdf(
    parameters: Parameters<typeof RadioSeries.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, RadioSeries> {
    return RadioSeries.$propertiesFromRdf(parameters).map(
      (properties) => new RadioSeries(properties),
    );
  }

  export const $properties = {
    ...CreativeWorkSeriesStatic.$properties,
    episodes: {
      identifier: dataFactory.namedNode("http://schema.org/episode"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RadioSeries.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RadioSeries.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RadioSeries.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("radioSeries");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "radioSeries");
    triples.push(
      ...CreativeWorkSeriesStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Episodes`),
      predicate: RadioSeries.$properties.episodes["identifier"],
      subject,
    });
    triples.push(
      ...RadioEpisodeStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Episodes`),
        variablePrefix: `${variablePrefix}Episodes`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("radioSeries");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "radioSeries");
    for (const pattern of CreativeWorkSeriesStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Episodes`),
                predicate: RadioSeries.$properties.episodes["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...RadioEpisodeStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}Episodes`),
            variablePrefix: `${variablePrefix}Episodes`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class CreativeWorkSeriesStub extends CreativeWorkStub {
  override readonly $type: "CreativeWorkSeriesStub" | "RadioSeriesStub" =
    "CreativeWorkSeriesStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof CreativeWorkStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): CreativeWorkSeriesStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/CreativeWorkSeries"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace CreativeWorkSeriesStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/CreativeWorkSeries",
  );
  export type $Identifier = CreativeWorkStubStatic.$Identifier;
  export const $Identifier = CreativeWorkStubStatic.$Identifier;
  export type $Json = CreativeWorkStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      CreativeWorkStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, CreativeWorkSeriesStub> {
    return (
      RadioSeriesStub.$fromJson(json) as purify.Either<
        zod.ZodError,
        CreativeWorkSeriesStub
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new CreativeWorkSeriesStub(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [CreativeWorkStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "CreativeWorkSeriesStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["CreativeWorkSeriesStub", "RadioSeriesStub"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = CreativeWorkStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/CreativeWorkSeries)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: CreativeWorkSeriesStubStatic.$Identifier =
      _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<
      typeof CreativeWorkSeriesStubStatic.$propertiesFromRdf
    >[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, CreativeWorkSeriesStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      RadioSeriesStub.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        CreativeWorkSeriesStub
      >
    ).altLazy(() =>
      CreativeWorkSeriesStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new CreativeWorkSeriesStub(properties),
      ),
    );
  }

  export const $properties = { ...CreativeWorkStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        CreativeWorkSeriesStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        CreativeWorkSeriesStubStatic.$sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      CreativeWorkSeriesStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("creativeWorkSeriesStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "creativeWorkSeriesStub");
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("creativeWorkSeriesStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "creativeWorkSeriesStub");
    for (const pattern of CreativeWorkStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class RadioSeriesStub extends CreativeWorkSeriesStub {
  override readonly $type = "RadioSeriesStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof CreativeWorkSeriesStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): RadioSeriesStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/RadioSeries"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RadioSeriesStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/RadioSeries",
  );
  export type $Identifier = CreativeWorkSeriesStubStatic.$Identifier;
  export const $Identifier = CreativeWorkSeriesStubStatic.$Identifier;
  export type $Json = CreativeWorkSeriesStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkSeriesStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      CreativeWorkSeriesStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RadioSeriesStub> {
    return $propertiesFromJson(json).map(
      (properties) => new RadioSeriesStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [CreativeWorkSeriesStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "RadioSeriesStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkSeriesStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("RadioSeriesStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkSeriesStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = CreativeWorkSeriesStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/RadioSeries)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: RadioSeriesStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof RadioSeriesStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, RadioSeriesStub> {
    return RadioSeriesStub.$propertiesFromRdf(parameters).map(
      (properties) => new RadioSeriesStub(properties),
    );
  }

  export const $properties = { ...CreativeWorkSeriesStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RadioSeriesStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RadioSeriesStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RadioSeriesStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("radioSeriesStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "radioSeriesStub");
    triples.push(
      ...CreativeWorkSeriesStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("radioSeriesStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "radioSeriesStub");
    for (const pattern of CreativeWorkSeriesStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Episode extends CreativeWork {
  override readonly $type: "Episode" | "RadioEpisode" = "Episode";
  readonly partOfSeries: purify.Maybe<CreativeWorkSeriesStub>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly partOfSeries?:
        | CreativeWorkSeriesStub
        | purify.Maybe<CreativeWorkSeriesStub>;
    } & ConstructorParameters<typeof CreativeWork>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.partOfSeries)) {
      this.partOfSeries = parameters.partOfSeries;
    } else if (
      typeof parameters.partOfSeries === "object" &&
      parameters.partOfSeries instanceof CreativeWorkSeriesStub
    ) {
      this.partOfSeries = purify.Maybe.of(parameters.partOfSeries);
    } else if (typeof parameters.partOfSeries === "undefined") {
      this.partOfSeries = purify.Maybe.empty();
    } else {
      this.partOfSeries = parameters.partOfSeries satisfies never;
    }
  }

  override get $identifier(): EpisodeStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: Episode): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.partOfSeries,
          other.partOfSeries,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "partOfSeries",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.partOfSeries.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    return _hasher;
  }

  override $toJson(): EpisodeStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        partOfSeries: this.partOfSeries
          .map((_item) => _item.$toJson())
          .extract(),
      } satisfies EpisodeStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Episode"),
      );
    }

    _resource.add(
      EpisodeStatic.$properties.partOfSeries["identifier"],
      this.partOfSeries.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace EpisodeStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Episode",
  );
  export type $Identifier = CreativeWorkStatic.$Identifier;
  export const $Identifier = CreativeWorkStatic.$Identifier;
  export type $Json = {
    readonly partOfSeries: CreativeWorkSeriesStubStatic.$Json | undefined;
  } & CreativeWorkStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      partOfSeries: purify.Maybe<CreativeWorkSeriesStub>;
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = CreativeWorkStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const partOfSeries = purify.Maybe.fromNullable(
      _jsonObject["partOfSeries"],
    ).map((_item) =>
      CreativeWorkSeriesStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ...$super0, $identifier, partOfSeries });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Episode> {
    return (
      RadioEpisode.$fromJson(json) as purify.Either<zod.ZodError, Episode>
    ).altLazy(() =>
      $propertiesFromJson(json).map((properties) => new Episode(properties)),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        CreativeWorkStatic.$jsonUiSchema({ scopePrefix }),
        CreativeWorkSeriesStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/partOfSeries`,
        }),
      ],
      label: "Episode",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["Episode", "RadioEpisode"]),
        partOfSeries: CreativeWorkSeriesStubStatic.$jsonZodSchema().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      partOfSeries: purify.Maybe<CreativeWorkSeriesStub>;
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromRdf>>
  > {
    const $super0Either = CreativeWorkStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Episode)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: EpisodeStatic.$Identifier = _resource.identifier;
    const _partOfSeriesEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<CreativeWorkSeriesStub>
    > = purify.Either.of(
      _resource
        .values($properties.partOfSeries["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          CreativeWorkSeriesStubStatic.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_partOfSeriesEither.isLeft()) {
      return _partOfSeriesEither;
    }

    const partOfSeries = _partOfSeriesEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, partOfSeries });
  }

  export function $fromRdf(
    parameters: Parameters<typeof EpisodeStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Episode> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      RadioEpisode.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Episode
      >
    ).altLazy(() =>
      EpisodeStatic.$propertiesFromRdf(parameters).map(
        (properties) => new Episode(properties),
      ),
    );
  }

  export const $properties = {
    ...CreativeWorkStatic.$properties,
    partOfSeries: {
      identifier: dataFactory.namedNode("http://schema.org/partOfSeries"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        EpisodeStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        EpisodeStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      EpisodeStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("episode");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "episode");
    triples.push(
      ...CreativeWorkStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}PartOfSeries`),
      predicate: EpisodeStatic.$properties.partOfSeries["identifier"],
      subject,
    });
    triples.push(
      ...CreativeWorkSeriesStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}PartOfSeries`),
        variablePrefix: `${variablePrefix}PartOfSeries`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("episode");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "episode");
    for (const pattern of CreativeWorkStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}PartOfSeries`),
                predicate: EpisodeStatic.$properties.partOfSeries["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...CreativeWorkSeriesStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}PartOfSeries`),
            variablePrefix: `${variablePrefix}PartOfSeries`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class RadioEpisode extends Episode {
  override readonly $type = "RadioEpisode";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof Episode>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): RadioEpisode.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/RadioEpisode"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RadioEpisode {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/RadioEpisode",
  );
  export type $Identifier = EpisodeStatic.$Identifier;
  export const $Identifier = EpisodeStatic.$Identifier;
  export type $Json = EpisodeStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof EpisodeStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = EpisodeStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RadioEpisode> {
    return $propertiesFromJson(json).map(
      (properties) => new RadioEpisode(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [EpisodeStatic.$jsonUiSchema({ scopePrefix })],
      label: "RadioEpisode",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return EpisodeStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("RadioEpisode"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof EpisodeStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = EpisodeStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/RadioEpisode)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: RadioEpisode.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof RadioEpisode.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, RadioEpisode> {
    return RadioEpisode.$propertiesFromRdf(parameters).map(
      (properties) => new RadioEpisode(properties),
    );
  }

  export const $properties = { ...EpisodeStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RadioEpisode.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RadioEpisode.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RadioEpisode.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("radioEpisode");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "radioEpisode");
    triples.push(
      ...EpisodeStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("radioEpisode");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "radioEpisode");
    for (const pattern of EpisodeStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class EpisodeStub extends CreativeWorkStub {
  override readonly $type: "EpisodeStub" | "RadioEpisodeStub" = "EpisodeStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof CreativeWorkStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): EpisodeStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Episode"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace EpisodeStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Episode",
  );
  export type $Identifier = CreativeWorkStubStatic.$Identifier;
  export const $Identifier = CreativeWorkStubStatic.$Identifier;
  export type $Json = CreativeWorkStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      CreativeWorkStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, EpisodeStub> {
    return (
      RadioEpisodeStub.$fromJson(json) as purify.Either<
        zod.ZodError,
        EpisodeStub
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new EpisodeStub(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [CreativeWorkStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "EpisodeStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["EpisodeStub", "RadioEpisodeStub"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = CreativeWorkStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Episode)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: EpisodeStubStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof EpisodeStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, EpisodeStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      RadioEpisodeStub.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        EpisodeStub
      >
    ).altLazy(() =>
      EpisodeStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new EpisodeStub(properties),
      ),
    );
  }

  export const $properties = { ...CreativeWorkStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        EpisodeStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        EpisodeStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      EpisodeStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("episodeStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "episodeStub");
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("episodeStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "episodeStub");
    for (const pattern of CreativeWorkStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class RadioEpisodeStub extends EpisodeStub {
  override readonly $type = "RadioEpisodeStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof EpisodeStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): RadioEpisodeStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/RadioEpisode"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RadioEpisodeStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/RadioEpisode",
  );
  export type $Identifier = EpisodeStubStatic.$Identifier;
  export const $Identifier = EpisodeStubStatic.$Identifier;
  export type $Json = EpisodeStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof EpisodeStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = EpisodeStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RadioEpisodeStub> {
    return $propertiesFromJson(json).map(
      (properties) => new RadioEpisodeStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [EpisodeStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "RadioEpisodeStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return EpisodeStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("RadioEpisodeStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof EpisodeStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = EpisodeStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/RadioEpisode)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: RadioEpisodeStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof RadioEpisodeStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, RadioEpisodeStub> {
    return RadioEpisodeStub.$propertiesFromRdf(parameters).map(
      (properties) => new RadioEpisodeStub(properties),
    );
  }

  export const $properties = { ...EpisodeStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RadioEpisodeStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RadioEpisodeStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RadioEpisodeStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("radioEpisodeStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "radioEpisodeStub");
    triples.push(
      ...EpisodeStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("radioEpisodeStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "radioEpisodeStub");
    for (const pattern of EpisodeStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class BroadcastService extends Service {
  override readonly $type: "BroadcastService" | "RadioBroadcastService" =
    "BroadcastService";
  readonly broadcastTimezone: purify.Maybe<string>;
  readonly callSign: purify.Maybe<string>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly broadcastTimezone?: purify.Maybe<string> | string;
      readonly callSign?: purify.Maybe<string> | string;
    } & ConstructorParameters<typeof Service>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.broadcastTimezone)) {
      this.broadcastTimezone = parameters.broadcastTimezone;
    } else if (typeof parameters.broadcastTimezone === "string") {
      this.broadcastTimezone = purify.Maybe.of(parameters.broadcastTimezone);
    } else if (typeof parameters.broadcastTimezone === "undefined") {
      this.broadcastTimezone = purify.Maybe.empty();
    } else {
      this.broadcastTimezone = parameters.broadcastTimezone satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.callSign)) {
      this.callSign = parameters.callSign;
    } else if (typeof parameters.callSign === "string") {
      this.callSign = purify.Maybe.of(parameters.callSign);
    } else if (typeof parameters.callSign === "undefined") {
      this.callSign = purify.Maybe.empty();
    } else {
      this.callSign = parameters.callSign satisfies never;
    }
  }

  override get $identifier(): BroadcastServiceStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: BroadcastService): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.broadcastTimezone,
          other.broadcastTimezone,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "broadcastTimezone",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.callSign,
          other.callSign,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "callSign",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.broadcastTimezone.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.callSign.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    return _hasher;
  }

  override $toJson(): BroadcastServiceStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        broadcastTimezone: this.broadcastTimezone
          .map((_item) => _item)
          .extract(),
        callSign: this.callSign.map((_item) => _item).extract(),
      } satisfies BroadcastServiceStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/BroadcastService"),
      );
    }

    _resource.add(
      BroadcastServiceStatic.$properties.broadcastTimezone["identifier"],
      this.broadcastTimezone,
    );
    _resource.add(
      BroadcastServiceStatic.$properties.callSign["identifier"],
      this.callSign,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace BroadcastServiceStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/BroadcastService",
  );
  export type $Identifier = ServiceStatic.$Identifier;
  export const $Identifier = ServiceStatic.$Identifier;
  export type $Json = {
    readonly broadcastTimezone: string | undefined;
    readonly callSign: string | undefined;
  } & ServiceStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      broadcastTimezone: purify.Maybe<string>;
      callSign: purify.Maybe<string>;
    } & $UnwrapR<ReturnType<typeof ServiceStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ServiceStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const broadcastTimezone = purify.Maybe.fromNullable(
      _jsonObject["broadcastTimezone"],
    );
    const callSign = purify.Maybe.fromNullable(_jsonObject["callSign"]);
    return purify.Either.of({
      ...$super0,
      $identifier,
      broadcastTimezone,
      callSign,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BroadcastService> {
    return (
      RadioBroadcastService.$fromJson(json) as purify.Either<
        zod.ZodError,
        BroadcastService
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new BroadcastService(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ServiceStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/broadcastTimezone`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/callSign`, type: "Control" },
      ],
      label: "BroadcastService",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ServiceStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["BroadcastService", "RadioBroadcastService"]),
        broadcastTimezone: zod.string().optional(),
        callSign: zod.string().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      broadcastTimezone: purify.Maybe<string>;
      callSign: purify.Maybe<string>;
    } & $UnwrapR<ReturnType<typeof ServiceStatic.$propertiesFromRdf>>
  > {
    const $super0Either = ServiceStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/BroadcastService)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: BroadcastServiceStatic.$Identifier =
      _resource.identifier;
    const _broadcastTimezoneEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.broadcastTimezone["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_broadcastTimezoneEither.isLeft()) {
      return _broadcastTimezoneEither;
    }

    const broadcastTimezone = _broadcastTimezoneEither.unsafeCoerce();
    const _callSignEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.callSign["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_callSignEither.isLeft()) {
      return _callSignEither;
    }

    const callSign = _callSignEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      broadcastTimezone,
      callSign,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof BroadcastServiceStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, BroadcastService> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      RadioBroadcastService.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        BroadcastService
      >
    ).altLazy(() =>
      BroadcastServiceStatic.$propertiesFromRdf(parameters).map(
        (properties) => new BroadcastService(properties),
      ),
    );
  }

  export const $properties = {
    ...ServiceStatic.$properties,
    broadcastTimezone: {
      identifier: dataFactory.namedNode("http://schema.org/broadcastTimezone"),
    },
    callSign: {
      identifier: dataFactory.namedNode("http://schema.org/callSign"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BroadcastServiceStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BroadcastServiceStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BroadcastServiceStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("broadcastService");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "broadcastService");
    triples.push(
      ...ServiceStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}BroadcastTimezone`),
      predicate:
        BroadcastServiceStatic.$properties.broadcastTimezone["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}CallSign`),
      predicate: BroadcastServiceStatic.$properties.callSign["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("broadcastService");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "broadcastService");
    for (const pattern of ServiceStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}BroadcastTimezone`,
                ),
                predicate:
                  BroadcastServiceStatic.$properties.broadcastTimezone[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}CallSign`),
                predicate:
                  BroadcastServiceStatic.$properties.callSign["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class RadioBroadcastService extends BroadcastService {
  override readonly $type = "RadioBroadcastService";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof BroadcastService>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): RadioBroadcastService.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode(
          "http://schema.org/RadioBroadcastService",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RadioBroadcastService {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/RadioBroadcastService",
  );
  export type $Identifier = BroadcastServiceStatic.$Identifier;
  export const $Identifier = BroadcastServiceStatic.$Identifier;
  export type $Json = BroadcastServiceStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof BroadcastServiceStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      BroadcastServiceStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RadioBroadcastService> {
    return $propertiesFromJson(json).map(
      (properties) => new RadioBroadcastService(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [BroadcastServiceStatic.$jsonUiSchema({ scopePrefix })],
      label: "RadioBroadcastService",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return BroadcastServiceStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("RadioBroadcastService"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof BroadcastServiceStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = BroadcastServiceStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/RadioBroadcastService)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: RadioBroadcastService.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof RadioBroadcastService.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, RadioBroadcastService> {
    return RadioBroadcastService.$propertiesFromRdf(parameters).map(
      (properties) => new RadioBroadcastService(properties),
    );
  }

  export const $properties = { ...BroadcastServiceStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RadioBroadcastService.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RadioBroadcastService.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RadioBroadcastService.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("radioBroadcastService");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "radioBroadcastService");
    triples.push(
      ...BroadcastServiceStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("radioBroadcastService");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "radioBroadcastService");
    for (const pattern of BroadcastServiceStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ServiceStub extends IntangibleStub {
  override readonly $type:
    | "ServiceStub"
    | "BroadcastServiceStub"
    | "RadioBroadcastServiceStub" = "ServiceStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof IntangibleStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): ServiceStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Service"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ServiceStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Service",
  );
  export type $Identifier = IntangibleStubStatic.$Identifier;
  export const $Identifier = IntangibleStubStatic.$Identifier;
  export type $Json = IntangibleStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ServiceStub> {
    return (
      BroadcastServiceStubStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        ServiceStub
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new ServiceStub(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IntangibleStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "ServiceStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "ServiceStub",
          "BroadcastServiceStub",
          "RadioBroadcastServiceStub",
        ]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IntangibleStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Service)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ServiceStubStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ServiceStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ServiceStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      BroadcastServiceStubStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        ServiceStub
      >
    ).altLazy(() =>
      ServiceStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new ServiceStub(properties),
      ),
    );
  }

  export const $properties = { ...IntangibleStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ServiceStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ServiceStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ServiceStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("serviceStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "serviceStub");
    triples.push(
      ...IntangibleStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("serviceStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "serviceStub");
    for (const pattern of IntangibleStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class BroadcastServiceStub extends ServiceStub {
  override readonly $type:
    | "BroadcastServiceStub"
    | "RadioBroadcastServiceStub" = "BroadcastServiceStub";
  readonly broadcastTimezone: purify.Maybe<string>;
  readonly callSign: purify.Maybe<string>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly broadcastTimezone?: purify.Maybe<string> | string;
      readonly callSign?: purify.Maybe<string> | string;
    } & ConstructorParameters<typeof ServiceStub>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.broadcastTimezone)) {
      this.broadcastTimezone = parameters.broadcastTimezone;
    } else if (typeof parameters.broadcastTimezone === "string") {
      this.broadcastTimezone = purify.Maybe.of(parameters.broadcastTimezone);
    } else if (typeof parameters.broadcastTimezone === "undefined") {
      this.broadcastTimezone = purify.Maybe.empty();
    } else {
      this.broadcastTimezone = parameters.broadcastTimezone satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.callSign)) {
      this.callSign = parameters.callSign;
    } else if (typeof parameters.callSign === "string") {
      this.callSign = purify.Maybe.of(parameters.callSign);
    } else if (typeof parameters.callSign === "undefined") {
      this.callSign = purify.Maybe.empty();
    } else {
      this.callSign = parameters.callSign satisfies never;
    }
  }

  override get $identifier(): BroadcastServiceStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: BroadcastServiceStub): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.broadcastTimezone,
          other.broadcastTimezone,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "broadcastTimezone",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.callSign,
          other.callSign,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "callSign",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.broadcastTimezone.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.callSign.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    return _hasher;
  }

  override $toJson(): BroadcastServiceStubStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        broadcastTimezone: this.broadcastTimezone
          .map((_item) => _item)
          .extract(),
        callSign: this.callSign.map((_item) => _item).extract(),
      } satisfies BroadcastServiceStubStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/BroadcastService"),
      );
    }

    _resource.add(
      BroadcastServiceStatic.$properties.broadcastTimezone["identifier"],
      this.broadcastTimezone,
    );
    _resource.add(
      BroadcastServiceStatic.$properties.callSign["identifier"],
      this.callSign,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace BroadcastServiceStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/BroadcastService",
  );
  export type $Identifier = ServiceStubStatic.$Identifier;
  export const $Identifier = ServiceStubStatic.$Identifier;
  export type $Json = {
    readonly broadcastTimezone: string | undefined;
    readonly callSign: string | undefined;
  } & ServiceStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      broadcastTimezone: purify.Maybe<string>;
      callSign: purify.Maybe<string>;
    } & $UnwrapR<ReturnType<typeof ServiceStubStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ServiceStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const broadcastTimezone = purify.Maybe.fromNullable(
      _jsonObject["broadcastTimezone"],
    );
    const callSign = purify.Maybe.fromNullable(_jsonObject["callSign"]);
    return purify.Either.of({
      ...$super0,
      $identifier,
      broadcastTimezone,
      callSign,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BroadcastServiceStub> {
    return (
      RadioBroadcastServiceStub.$fromJson(json) as purify.Either<
        zod.ZodError,
        BroadcastServiceStub
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new BroadcastServiceStub(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ServiceStubStatic.$jsonUiSchema({ scopePrefix }),
        {
          scope: `${scopePrefix}/properties/broadcastTimezone`,
          type: "Control",
        },
        { scope: `${scopePrefix}/properties/callSign`, type: "Control" },
      ],
      label: "BroadcastServiceStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ServiceStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["BroadcastServiceStub", "RadioBroadcastServiceStub"]),
        broadcastTimezone: zod.string().optional(),
        callSign: zod.string().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      broadcastTimezone: purify.Maybe<string>;
      callSign: purify.Maybe<string>;
    } & $UnwrapR<ReturnType<typeof ServiceStubStatic.$propertiesFromRdf>>
  > {
    const $super0Either = ServiceStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/BroadcastService)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: BroadcastServiceStubStatic.$Identifier =
      _resource.identifier;
    const _broadcastTimezoneEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.broadcastTimezone["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_broadcastTimezoneEither.isLeft()) {
      return _broadcastTimezoneEither;
    }

    const broadcastTimezone = _broadcastTimezoneEither.unsafeCoerce();
    const _callSignEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.callSign["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_callSignEither.isLeft()) {
      return _callSignEither;
    }

    const callSign = _callSignEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      broadcastTimezone,
      callSign,
    });
  }

  export function $fromRdf(
    parameters: Parameters<
      typeof BroadcastServiceStubStatic.$propertiesFromRdf
    >[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, BroadcastServiceStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      RadioBroadcastServiceStub.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        BroadcastServiceStub
      >
    ).altLazy(() =>
      BroadcastServiceStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new BroadcastServiceStub(properties),
      ),
    );
  }

  export const $properties = {
    ...ServiceStubStatic.$properties,
    broadcastTimezone: {
      identifier: dataFactory.namedNode("http://schema.org/broadcastTimezone"),
    },
    callSign: {
      identifier: dataFactory.namedNode("http://schema.org/callSign"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BroadcastServiceStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BroadcastServiceStubStatic.$sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BroadcastServiceStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("broadcastServiceStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "broadcastServiceStub");
    triples.push(
      ...ServiceStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}BroadcastTimezone`),
      predicate:
        BroadcastServiceStatic.$properties.broadcastTimezone["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}CallSign`),
      predicate: BroadcastServiceStatic.$properties.callSign["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("broadcastServiceStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "broadcastServiceStub");
    for (const pattern of ServiceStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}BroadcastTimezone`,
                ),
                predicate:
                  BroadcastServiceStatic.$properties.broadcastTimezone[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}CallSign`),
                predicate:
                  BroadcastServiceStatic.$properties.callSign["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class RadioBroadcastServiceStub extends BroadcastServiceStub {
  override readonly $type = "RadioBroadcastServiceStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof BroadcastServiceStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): RadioBroadcastServiceStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode(
          "http://schema.org/RadioBroadcastService",
        ),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace RadioBroadcastServiceStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/RadioBroadcastService",
  );
  export type $Identifier = BroadcastServiceStubStatic.$Identifier;
  export const $Identifier = BroadcastServiceStubStatic.$Identifier;
  export type $Json = BroadcastServiceStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof BroadcastServiceStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      BroadcastServiceStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, RadioBroadcastServiceStub> {
    return $propertiesFromJson(json).map(
      (properties) => new RadioBroadcastServiceStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [BroadcastServiceStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "RadioBroadcastServiceStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return BroadcastServiceStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("RadioBroadcastServiceStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof BroadcastServiceStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = BroadcastServiceStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/RadioBroadcastService)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: RadioBroadcastServiceStub.$Identifier =
      _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<
      typeof RadioBroadcastServiceStub.$propertiesFromRdf
    >[0],
  ): purify.Either<
    rdfjsResource.Resource.ValueError,
    RadioBroadcastServiceStub
  > {
    return RadioBroadcastServiceStub.$propertiesFromRdf(parameters).map(
      (properties) => new RadioBroadcastServiceStub(properties),
    );
  }

  export const $properties = { ...BroadcastServiceStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        RadioBroadcastServiceStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        RadioBroadcastServiceStub.$sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      RadioBroadcastServiceStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("radioBroadcastServiceStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "radioBroadcastServiceStub");
    triples.push(
      ...BroadcastServiceStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("radioBroadcastServiceStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "radioBroadcastServiceStub");
    for (const pattern of BroadcastServiceStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class QuantitativeValue extends StructuredValue {
  override readonly $type = "QuantitativeValue";
  readonly unitText: purify.Maybe<string>;
  readonly value: purify.Maybe<number>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly unitText?: purify.Maybe<string> | string;
      readonly value?: number | purify.Maybe<number>;
    } & ConstructorParameters<typeof StructuredValue>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.unitText)) {
      this.unitText = parameters.unitText;
    } else if (typeof parameters.unitText === "string") {
      this.unitText = purify.Maybe.of(parameters.unitText);
    } else if (typeof parameters.unitText === "undefined") {
      this.unitText = purify.Maybe.empty();
    } else {
      this.unitText = parameters.unitText satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.value)) {
      this.value = parameters.value;
    } else if (typeof parameters.value === "number") {
      this.value = purify.Maybe.of(parameters.value);
    } else if (typeof parameters.value === "undefined") {
      this.value = purify.Maybe.empty();
    } else {
      this.value = parameters.value satisfies never;
    }
  }

  override get $identifier(): QuantitativeValue.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: QuantitativeValue): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.unitText,
          other.unitText,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "unitText",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.value,
          other.value,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "value",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.unitText.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.value.ifJust((_value0) => {
      _hasher.update(_value0.toString());
    });
    return _hasher;
  }

  override $toJson(): QuantitativeValue.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        unitText: this.unitText.map((_item) => _item).extract(),
        value: this.value.map((_item) => _item).extract(),
      } satisfies QuantitativeValue.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/QuantitativeValue"),
      );
    }

    _resource.add(
      QuantitativeValue.$properties.unitText["identifier"],
      this.unitText,
    );
    _resource.add(
      QuantitativeValue.$properties.value["identifier"],
      this.value,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace QuantitativeValue {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/QuantitativeValue",
  );
  export type $Identifier = StructuredValueStatic.$Identifier;
  export const $Identifier = StructuredValueStatic.$Identifier;
  export type $Json = {
    readonly unitText: string | undefined;
    readonly value: number | undefined;
  } & StructuredValueStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      unitText: purify.Maybe<string>;
      value: purify.Maybe<number>;
    } & $UnwrapR<ReturnType<typeof StructuredValueStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      StructuredValueStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const unitText = purify.Maybe.fromNullable(_jsonObject["unitText"]);
    const value = purify.Maybe.fromNullable(_jsonObject["value"]);
    return purify.Either.of({ ...$super0, $identifier, unitText, value });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, QuantitativeValue> {
    return $propertiesFromJson(json).map(
      (properties) => new QuantitativeValue(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        StructuredValueStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/unitText`, type: "Control" },
        { scope: `${scopePrefix}/properties/value`, type: "Control" },
      ],
      label: "QuantitativeValue",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return StructuredValueStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("QuantitativeValue"),
        unitText: zod.string().optional(),
        value: zod.number().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      unitText: purify.Maybe<string>;
      value: purify.Maybe<number>;
    } & $UnwrapR<ReturnType<typeof StructuredValueStatic.$propertiesFromRdf>>
  > {
    const $super0Either = StructuredValueStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/QuantitativeValue)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: QuantitativeValue.$Identifier = _resource.identifier;
    const _unitTextEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.unitText["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_unitTextEither.isLeft()) {
      return _unitTextEither;
    }

    const unitText = _unitTextEither.unsafeCoerce();
    const _valueEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<number>
    > = purify.Either.of(
      _resource
        .values($properties.value["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toNumber())
        .toMaybe(),
    );
    if (_valueEither.isLeft()) {
      return _valueEither;
    }

    const value = _valueEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, unitText, value });
  }

  export function $fromRdf(
    parameters: Parameters<typeof QuantitativeValue.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, QuantitativeValue> {
    return QuantitativeValue.$propertiesFromRdf(parameters).map(
      (properties) => new QuantitativeValue(properties),
    );
  }

  export const $properties = {
    ...StructuredValueStatic.$properties,
    unitText: {
      identifier: dataFactory.namedNode("http://schema.org/unitText"),
    },
    value: { identifier: dataFactory.namedNode("http://schema.org/value") },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        QuantitativeValue.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        QuantitativeValue.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      QuantitativeValue.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("quantitativeValue");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "quantitativeValue");
    triples.push(
      ...StructuredValueStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}UnitText`),
      predicate: QuantitativeValue.$properties.unitText["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Value`),
      predicate: QuantitativeValue.$properties.value["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("quantitativeValue");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "quantitativeValue");
    for (const pattern of StructuredValueStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}UnitText`),
                predicate: QuantitativeValue.$properties.unitText["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Value`),
                predicate: QuantitativeValue.$properties.value["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class StructuredValueStub extends IntangibleStub {
  override readonly $type:
    | "StructuredValueStub"
    | "MonetaryAmountStub"
    | "QuantitativeValueStub" = "StructuredValueStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof IntangibleStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): StructuredValueStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/StructuredValue"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace StructuredValueStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/StructuredValue",
  );
  export type $Identifier = IntangibleStubStatic.$Identifier;
  export const $Identifier = IntangibleStubStatic.$Identifier;
  export type $Json = IntangibleStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, StructuredValueStub> {
    return (
      MonetaryAmountStub.$fromJson(json) as purify.Either<
        zod.ZodError,
        StructuredValueStub
      >
    )
      .altLazy(
        () =>
          QuantitativeValueStub.$fromJson(json) as purify.Either<
            zod.ZodError,
            StructuredValueStub
          >,
      )
      .altLazy(() =>
        $propertiesFromJson(json).map(
          (properties) => new StructuredValueStub(properties),
        ),
      );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IntangibleStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "StructuredValueStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "StructuredValueStub",
          "MonetaryAmountStub",
          "QuantitativeValueStub",
        ]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IntangibleStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/StructuredValue)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: StructuredValueStubStatic.$Identifier =
      _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<
      typeof StructuredValueStubStatic.$propertiesFromRdf
    >[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, StructuredValueStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      MonetaryAmountStub.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        StructuredValueStub
      >
    )
      .altLazy(
        () =>
          QuantitativeValueStub.$fromRdf(otherParameters) as purify.Either<
            rdfjsResource.Resource.ValueError,
            StructuredValueStub
          >,
      )
      .altLazy(() =>
        StructuredValueStubStatic.$propertiesFromRdf(parameters).map(
          (properties) => new StructuredValueStub(properties),
        ),
      );
  }

  export const $properties = { ...IntangibleStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        StructuredValueStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        StructuredValueStubStatic.$sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      StructuredValueStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("structuredValueStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "structuredValueStub");
    triples.push(
      ...IntangibleStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("structuredValueStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "structuredValueStub");
    for (const pattern of IntangibleStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class QuantitativeValueStub extends StructuredValueStub {
  override readonly $type = "QuantitativeValueStub";
  readonly unitText: purify.Maybe<string>;
  readonly value: purify.Maybe<number>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly unitText?: purify.Maybe<string> | string;
      readonly value?: number | purify.Maybe<number>;
    } & ConstructorParameters<typeof StructuredValueStub>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.unitText)) {
      this.unitText = parameters.unitText;
    } else if (typeof parameters.unitText === "string") {
      this.unitText = purify.Maybe.of(parameters.unitText);
    } else if (typeof parameters.unitText === "undefined") {
      this.unitText = purify.Maybe.empty();
    } else {
      this.unitText = parameters.unitText satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.value)) {
      this.value = parameters.value;
    } else if (typeof parameters.value === "number") {
      this.value = purify.Maybe.of(parameters.value);
    } else if (typeof parameters.value === "undefined") {
      this.value = purify.Maybe.empty();
    } else {
      this.value = parameters.value satisfies never;
    }
  }

  override get $identifier(): QuantitativeValueStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: QuantitativeValueStub): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.unitText,
          other.unitText,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "unitText",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.value,
          other.value,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "value",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.unitText.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.value.ifJust((_value0) => {
      _hasher.update(_value0.toString());
    });
    return _hasher;
  }

  override $toJson(): QuantitativeValueStub.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        unitText: this.unitText.map((_item) => _item).extract(),
        value: this.value.map((_item) => _item).extract(),
      } satisfies QuantitativeValueStub.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/QuantitativeValue"),
      );
    }

    _resource.add(
      QuantitativeValue.$properties.unitText["identifier"],
      this.unitText,
    );
    _resource.add(
      QuantitativeValue.$properties.value["identifier"],
      this.value,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace QuantitativeValueStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/QuantitativeValue",
  );
  export type $Identifier = StructuredValueStubStatic.$Identifier;
  export const $Identifier = StructuredValueStubStatic.$Identifier;
  export type $Json = {
    readonly unitText: string | undefined;
    readonly value: number | undefined;
  } & StructuredValueStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      unitText: purify.Maybe<string>;
      value: purify.Maybe<number>;
    } & $UnwrapR<
      ReturnType<typeof StructuredValueStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      StructuredValueStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const unitText = purify.Maybe.fromNullable(_jsonObject["unitText"]);
    const value = purify.Maybe.fromNullable(_jsonObject["value"]);
    return purify.Either.of({ ...$super0, $identifier, unitText, value });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, QuantitativeValueStub> {
    return $propertiesFromJson(json).map(
      (properties) => new QuantitativeValueStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        StructuredValueStubStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/unitText`, type: "Control" },
        { scope: `${scopePrefix}/properties/value`, type: "Control" },
      ],
      label: "QuantitativeValueStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return StructuredValueStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("QuantitativeValueStub"),
        unitText: zod.string().optional(),
        value: zod.number().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      unitText: purify.Maybe<string>;
      value: purify.Maybe<number>;
    } & $UnwrapR<
      ReturnType<typeof StructuredValueStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = StructuredValueStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/QuantitativeValue)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: QuantitativeValueStub.$Identifier = _resource.identifier;
    const _unitTextEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.unitText["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_unitTextEither.isLeft()) {
      return _unitTextEither;
    }

    const unitText = _unitTextEither.unsafeCoerce();
    const _valueEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<number>
    > = purify.Either.of(
      _resource
        .values($properties.value["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toNumber())
        .toMaybe(),
    );
    if (_valueEither.isLeft()) {
      return _valueEither;
    }

    const value = _valueEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, unitText, value });
  }

  export function $fromRdf(
    parameters: Parameters<typeof QuantitativeValueStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, QuantitativeValueStub> {
    return QuantitativeValueStub.$propertiesFromRdf(parameters).map(
      (properties) => new QuantitativeValueStub(properties),
    );
  }

  export const $properties = {
    ...StructuredValueStubStatic.$properties,
    unitText: {
      identifier: dataFactory.namedNode("http://schema.org/unitText"),
    },
    value: { identifier: dataFactory.namedNode("http://schema.org/value") },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        QuantitativeValueStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        QuantitativeValueStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      QuantitativeValueStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("quantitativeValueStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "quantitativeValueStub");
    triples.push(
      ...StructuredValueStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}UnitText`),
      predicate: QuantitativeValue.$properties.unitText["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Value`),
      predicate: QuantitativeValue.$properties.value["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("quantitativeValueStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "quantitativeValueStub");
    for (const pattern of StructuredValueStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}UnitText`),
                predicate: QuantitativeValue.$properties.unitText["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Value`),
                predicate: QuantitativeValue.$properties.value["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Event extends Thing {
  override readonly $type: "Event" | "BroadcastEvent" | "PublicationEvent" =
    "Event";
  readonly about: readonly ThingStub[];
  readonly endDate: purify.Maybe<Date>;
  readonly location: purify.Maybe<PlaceStub>;
  readonly organizers: readonly AgentStub[];
  readonly performers: readonly AgentStub[];
  readonly startDate: purify.Maybe<Date>;
  subEvents: EventStub[];
  superEvent: purify.Maybe<EventStub>;
  worksPerformed: CreativeWorkStub[];

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly about?: readonly ThingStub[];
      readonly endDate?: Date | purify.Maybe<Date>;
      readonly location?: PlaceStub | purify.Maybe<PlaceStub>;
      readonly organizers?: readonly AgentStub[];
      readonly performers?: readonly AgentStub[];
      readonly startDate?: Date | purify.Maybe<Date>;
      readonly subEvents?: readonly EventStub[];
      readonly superEvent?: EventStub | purify.Maybe<EventStub>;
      readonly worksPerformed?: readonly CreativeWorkStub[];
    } & ConstructorParameters<typeof Thing>[0],
  ) {
    super(parameters);
    if (typeof parameters.about === "undefined") {
      this.about = [];
    } else if (typeof parameters.about === "object") {
      this.about = parameters.about;
    } else {
      this.about = parameters.about satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.endDate)) {
      this.endDate = parameters.endDate;
    } else if (
      typeof parameters.endDate === "object" &&
      parameters.endDate instanceof Date
    ) {
      this.endDate = purify.Maybe.of(parameters.endDate);
    } else if (typeof parameters.endDate === "undefined") {
      this.endDate = purify.Maybe.empty();
    } else {
      this.endDate = parameters.endDate satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.location)) {
      this.location = parameters.location;
    } else if (
      typeof parameters.location === "object" &&
      parameters.location instanceof PlaceStub
    ) {
      this.location = purify.Maybe.of(parameters.location);
    } else if (typeof parameters.location === "undefined") {
      this.location = purify.Maybe.empty();
    } else {
      this.location = parameters.location satisfies never;
    }

    if (typeof parameters.organizers === "undefined") {
      this.organizers = [];
    } else if (typeof parameters.organizers === "object") {
      this.organizers = parameters.organizers;
    } else {
      this.organizers = parameters.organizers satisfies never;
    }

    if (typeof parameters.performers === "undefined") {
      this.performers = [];
    } else if (typeof parameters.performers === "object") {
      this.performers = parameters.performers;
    } else {
      this.performers = parameters.performers satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.startDate)) {
      this.startDate = parameters.startDate;
    } else if (
      typeof parameters.startDate === "object" &&
      parameters.startDate instanceof Date
    ) {
      this.startDate = purify.Maybe.of(parameters.startDate);
    } else if (typeof parameters.startDate === "undefined") {
      this.startDate = purify.Maybe.empty();
    } else {
      this.startDate = parameters.startDate satisfies never;
    }

    if (typeof parameters.subEvents === "undefined") {
      this.subEvents = [];
    } else if (typeof parameters.subEvents === "object") {
      this.subEvents = parameters.subEvents.concat();
    } else {
      this.subEvents = parameters.subEvents satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.superEvent)) {
      this.superEvent = parameters.superEvent;
    } else if (
      typeof parameters.superEvent === "object" &&
      parameters.superEvent instanceof EventStub
    ) {
      this.superEvent = purify.Maybe.of(parameters.superEvent);
    } else if (typeof parameters.superEvent === "undefined") {
      this.superEvent = purify.Maybe.empty();
    } else {
      this.superEvent = parameters.superEvent satisfies never;
    }

    if (typeof parameters.worksPerformed === "undefined") {
      this.worksPerformed = [];
    } else if (typeof parameters.worksPerformed === "object") {
      this.worksPerformed = parameters.worksPerformed.concat();
    } else {
      this.worksPerformed = parameters.worksPerformed satisfies never;
    }
  }

  override get $identifier(): EventStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: Event): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.about,
          other.about,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "about",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.endDate,
          other.endDate,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "endDate",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.location,
          other.location,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "location",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, AgentStub.$equals))(
          this.organizers,
          other.organizers,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "organizers",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, AgentStub.$equals))(
          this.performers,
          other.performers,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "performers",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.startDate,
          other.startDate,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "startDate",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.subEvents,
          other.subEvents,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "subEvents",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.superEvent,
          other.superEvent,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "superEvent",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.worksPerformed,
          other.worksPerformed,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "worksPerformed",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.about) {
      _item0.$hash(_hasher);
    }

    this.endDate.ifJust((_value0) => {
      _hasher.update(_value0.toISOString());
    });
    this.location.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    for (const _item0 of this.organizers) {
      _item0.$hash(_hasher);
    }

    for (const _item0 of this.performers) {
      _item0.$hash(_hasher);
    }

    this.startDate.ifJust((_value0) => {
      _hasher.update(_value0.toISOString());
    });
    for (const _item0 of this.subEvents) {
      _item0.$hash(_hasher);
    }

    this.superEvent.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    for (const _item0 of this.worksPerformed) {
      _item0.$hash(_hasher);
    }

    return _hasher;
  }

  override $toJson(): EventStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        about: this.about.map((_item) => _item.$toJson()),
        endDate: this.endDate.map((_item) => _item.toISOString()).extract(),
        location: this.location.map((_item) => _item.$toJson()).extract(),
        organizers: this.organizers.map((_item) => _item.$toJson()),
        performers: this.performers.map((_item) => _item.$toJson()),
        startDate: this.startDate.map((_item) => _item.toISOString()).extract(),
        subEvents: this.subEvents.map((_item) => _item.$toJson()),
        superEvent: this.superEvent.map((_item) => _item.$toJson()).extract(),
        worksPerformed: this.worksPerformed.map((_item) => _item.$toJson()),
      } satisfies EventStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Event"),
      );
    }

    _resource.add(
      EventStatic.$properties.about["identifier"],
      this.about.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      EventStatic.$properties.endDate["identifier"],
      this.endDate.map((_value) =>
        rdfLiteral.toRdf(_value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.dateTime,
        }),
      ),
    );
    _resource.add(
      EventStatic.$properties.location["identifier"],
      this.location.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      EventStatic.$properties.organizers["identifier"],
      this.organizers.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      EventStatic.$properties.performers["identifier"],
      this.performers.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      EventStubStatic.$properties.startDate["identifier"],
      this.startDate.map((_value) =>
        rdfLiteral.toRdf(_value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.dateTime,
        }),
      ),
    );
    _resource.add(
      EventStatic.$properties.subEvents["identifier"],
      this.subEvents.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      EventStatic.$properties.superEvent["identifier"],
      this.superEvent.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      EventStatic.$properties.worksPerformed["identifier"],
      this.worksPerformed.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace EventStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Event",
  );
  export type $Identifier = ThingStatic.$Identifier;
  export const $Identifier = ThingStatic.$Identifier;
  export type $Json = {
    readonly about: readonly ThingStubStatic.$Json[];
    readonly endDate: string | undefined;
    readonly location: PlaceStub.$Json | undefined;
    readonly organizers: readonly (
      | OrganizationStubStatic.$Json
      | PersonStub.$Json
    )[];
    readonly performers: readonly (
      | OrganizationStubStatic.$Json
      | PersonStub.$Json
    )[];
    readonly startDate: string | undefined;
    readonly subEvents: readonly EventStubStatic.$Json[];
    readonly superEvent: EventStubStatic.$Json | undefined;
    readonly worksPerformed: readonly CreativeWorkStubStatic.$Json[];
  } & ThingStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      about: readonly ThingStub[];
      endDate: purify.Maybe<Date>;
      location: purify.Maybe<PlaceStub>;
      organizers: readonly AgentStub[];
      performers: readonly AgentStub[];
      startDate: purify.Maybe<Date>;
      subEvents: EventStub[];
      superEvent: purify.Maybe<EventStub>;
      worksPerformed: CreativeWorkStub[];
    } & $UnwrapR<ReturnType<typeof ThingStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const about = _jsonObject["about"].map((_item) =>
      ThingStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    const endDate = purify.Maybe.fromNullable(_jsonObject["endDate"]).map(
      (_item) => new Date(_item),
    );
    const location = purify.Maybe.fromNullable(_jsonObject["location"]).map(
      (_item) => PlaceStub.$fromJson(_item).unsafeCoerce(),
    );
    const organizers = _jsonObject["organizers"].map((_item) =>
      AgentStub.$fromJson(_item).unsafeCoerce(),
    );
    const performers = _jsonObject["performers"].map((_item) =>
      AgentStub.$fromJson(_item).unsafeCoerce(),
    );
    const startDate = purify.Maybe.fromNullable(_jsonObject["startDate"]).map(
      (_item) => new Date(_item),
    );
    const subEvents = _jsonObject["subEvents"].map((_item) =>
      EventStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    const superEvent = purify.Maybe.fromNullable(_jsonObject["superEvent"]).map(
      (_item) => EventStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    const worksPerformed = _jsonObject["worksPerformed"].map((_item) =>
      CreativeWorkStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({
      ...$super0,
      $identifier,
      about,
      endDate,
      location,
      organizers,
      performers,
      startDate,
      subEvents,
      superEvent,
      worksPerformed,
    });
  }

  export function $fromJson(json: unknown): purify.Either<zod.ZodError, Event> {
    return (
      PublicationEventStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        Event
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map((properties) => new Event(properties)),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ThingStatic.$jsonUiSchema({ scopePrefix }),
        ThingStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/about`,
        }),
        { scope: `${scopePrefix}/properties/endDate`, type: "Control" },
        PlaceStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/location`,
        }),
        { scope: `${scopePrefix}/properties/organizers`, type: "Control" },
        { scope: `${scopePrefix}/properties/performers`, type: "Control" },
        { scope: `${scopePrefix}/properties/startDate`, type: "Control" },
        EventStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/subEvents`,
        }),
        EventStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/superEvent`,
        }),
        CreativeWorkStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/worksPerformed`,
        }),
      ],
      label: "Event",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["Event", "BroadcastEvent", "PublicationEvent"]),
        about: ThingStubStatic.$jsonZodSchema()
          .array()
          .default(() => []),
        endDate: zod.string().datetime().optional(),
        location: PlaceStub.$jsonZodSchema().optional(),
        organizers: AgentStub.$jsonZodSchema()
          .array()
          .default(() => []),
        performers: AgentStub.$jsonZodSchema()
          .array()
          .default(() => []),
        startDate: zod.string().datetime().optional(),
        subEvents: EventStubStatic.$jsonZodSchema()
          .array()
          .default(() => []),
        superEvent: EventStubStatic.$jsonZodSchema().optional(),
        worksPerformed: CreativeWorkStubStatic.$jsonZodSchema()
          .array()
          .default(() => []),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      about: readonly ThingStub[];
      endDate: purify.Maybe<Date>;
      location: purify.Maybe<PlaceStub>;
      organizers: readonly AgentStub[];
      performers: readonly AgentStub[];
      startDate: purify.Maybe<Date>;
      subEvents: EventStub[];
      superEvent: purify.Maybe<EventStub>;
      worksPerformed: CreativeWorkStub[];
    } & $UnwrapR<ReturnType<typeof ThingStatic.$propertiesFromRdf>>
  > {
    const $super0Either = ThingStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Event)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: EventStatic.$Identifier = _resource.identifier;
    const _aboutEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly ThingStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.about["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              ThingStubStatic.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_aboutEither.isLeft()) {
      return _aboutEither;
    }

    const about = _aboutEither.unsafeCoerce();
    const _endDateEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<Date>
    > = purify.Either.of(
      _resource
        .values($properties.endDate["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toDate())
        .toMaybe(),
    );
    if (_endDateEither.isLeft()) {
      return _endDateEither;
    }

    const endDate = _endDateEither.unsafeCoerce();
    const _locationEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<PlaceStub>
    > = purify.Either.of(
      _resource
        .values($properties.location["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          PlaceStub.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_locationEither.isLeft()) {
      return _locationEither;
    }

    const location = _locationEither.unsafeCoerce();
    const _organizersEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly AgentStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.organizers["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              AgentStub.$fromRdf({
                ..._context,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_organizersEither.isLeft()) {
      return _organizersEither;
    }

    const organizers = _organizersEither.unsafeCoerce();
    const _performersEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly AgentStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.performers["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              AgentStub.$fromRdf({
                ..._context,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_performersEither.isLeft()) {
      return _performersEither;
    }

    const performers = _performersEither.unsafeCoerce();
    const _startDateEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<Date>
    > = purify.Either.of(
      _resource
        .values($properties.startDate["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toDate())
        .toMaybe(),
    );
    if (_startDateEither.isLeft()) {
      return _startDateEither;
    }

    const startDate = _startDateEither.unsafeCoerce();
    const _subEventsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      EventStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.subEvents["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              EventStubStatic.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_subEventsEither.isLeft()) {
      return _subEventsEither;
    }

    const subEvents = _subEventsEither.unsafeCoerce();
    const _superEventEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<EventStub>
    > = purify.Either.of(
      _resource
        .values($properties.superEvent["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          EventStubStatic.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_superEventEither.isLeft()) {
      return _superEventEither;
    }

    const superEvent = _superEventEither.unsafeCoerce();
    const _worksPerformedEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      CreativeWorkStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.worksPerformed["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              CreativeWorkStubStatic.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_worksPerformedEither.isLeft()) {
      return _worksPerformedEither;
    }

    const worksPerformed = _worksPerformedEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      about,
      endDate,
      location,
      organizers,
      performers,
      startDate,
      subEvents,
      superEvent,
      worksPerformed,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof EventStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Event> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      PublicationEventStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Event
      >
    ).altLazy(() =>
      EventStatic.$propertiesFromRdf(parameters).map(
        (properties) => new Event(properties),
      ),
    );
  }

  export const $properties = {
    ...ThingStatic.$properties,
    about: { identifier: dataFactory.namedNode("http://schema.org/about") },
    endDate: { identifier: dataFactory.namedNode("http://schema.org/endDate") },
    location: {
      identifier: dataFactory.namedNode("http://schema.org/location"),
    },
    organizers: {
      identifier: dataFactory.namedNode("http://schema.org/organizer"),
    },
    performers: {
      identifier: dataFactory.namedNode("http://schema.org/performer"),
    },
    startDate: {
      identifier: dataFactory.namedNode("http://schema.org/startDate"),
    },
    subEvents: {
      identifier: dataFactory.namedNode("http://schema.org/subEvent"),
    },
    superEvent: {
      identifier: dataFactory.namedNode("http://schema.org/superEvent"),
    },
    worksPerformed: {
      identifier: dataFactory.namedNode("http://schema.org/workPerformed"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        EventStatic.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        EventStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      EventStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("event");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "event");
    triples.push(
      ...ThingStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}About`),
      predicate: EventStatic.$properties.about["identifier"],
      subject,
    });
    triples.push(
      ...ThingStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}About`),
        variablePrefix: `${variablePrefix}About`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}EndDate`),
      predicate: EventStatic.$properties.endDate["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Location`),
      predicate: EventStatic.$properties.location["identifier"],
      subject,
    });
    triples.push(
      ...PlaceStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Location`),
        variablePrefix: `${variablePrefix}Location`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Organizers`),
      predicate: EventStatic.$properties.organizers["identifier"],
      subject,
    });
    triples.push(
      ...AgentStub.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(`${variablePrefix}Organizers`),
        variablePrefix: `${variablePrefix}Organizers`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Performers`),
      predicate: EventStatic.$properties.performers["identifier"],
      subject,
    });
    triples.push(
      ...AgentStub.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(`${variablePrefix}Performers`),
        variablePrefix: `${variablePrefix}Performers`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}StartDate`),
      predicate: EventStubStatic.$properties.startDate["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}SubEvents`),
      predicate: EventStatic.$properties.subEvents["identifier"],
      subject,
    });
    triples.push(
      ...EventStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}SubEvents`),
        variablePrefix: `${variablePrefix}SubEvents`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}SuperEvent`),
      predicate: EventStatic.$properties.superEvent["identifier"],
      subject,
    });
    triples.push(
      ...EventStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}SuperEvent`),
        variablePrefix: `${variablePrefix}SuperEvent`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}WorksPerformed`),
      predicate: EventStatic.$properties.worksPerformed["identifier"],
      subject,
    });
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}WorksPerformed`),
        variablePrefix: `${variablePrefix}WorksPerformed`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("event");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "event");
    for (const pattern of ThingStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}About`),
                predicate: EventStatic.$properties.about["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...ThingStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}About`),
            variablePrefix: `${variablePrefix}About`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}EndDate`),
                predicate: EventStatic.$properties.endDate["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Location`),
                predicate: EventStatic.$properties.location["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...PlaceStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}Location`),
            variablePrefix: `${variablePrefix}Location`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Organizers`),
                predicate: EventStatic.$properties.organizers["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...AgentStub.$sparqlWherePatterns({
            subject: dataFactory.variable!(`${variablePrefix}Organizers`),
            variablePrefix: `${variablePrefix}Organizers`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Performers`),
                predicate: EventStatic.$properties.performers["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...AgentStub.$sparqlWherePatterns({
            subject: dataFactory.variable!(`${variablePrefix}Performers`),
            variablePrefix: `${variablePrefix}Performers`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}StartDate`),
                predicate: EventStubStatic.$properties.startDate["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}SubEvents`),
                predicate: EventStatic.$properties.subEvents["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...EventStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}SubEvents`),
            variablePrefix: `${variablePrefix}SubEvents`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}SuperEvent`),
                predicate: EventStatic.$properties.superEvent["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...EventStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}SuperEvent`),
            variablePrefix: `${variablePrefix}SuperEvent`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}WorksPerformed`,
                ),
                predicate: EventStatic.$properties.worksPerformed["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...CreativeWorkStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}WorksPerformed`),
            variablePrefix: `${variablePrefix}WorksPerformed`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class PublicationEvent extends Event {
  override readonly $type: "PublicationEvent" | "BroadcastEvent" =
    "PublicationEvent";
  readonly publishedOn: purify.Maybe<BroadcastServiceStub>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly publishedOn?:
        | BroadcastServiceStub
        | purify.Maybe<BroadcastServiceStub>;
    } & ConstructorParameters<typeof Event>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.publishedOn)) {
      this.publishedOn = parameters.publishedOn;
    } else if (
      typeof parameters.publishedOn === "object" &&
      parameters.publishedOn instanceof BroadcastServiceStub
    ) {
      this.publishedOn = purify.Maybe.of(parameters.publishedOn);
    } else if (typeof parameters.publishedOn === "undefined") {
      this.publishedOn = purify.Maybe.empty();
    } else {
      this.publishedOn = parameters.publishedOn satisfies never;
    }
  }

  override get $identifier(): PublicationEventStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: PublicationEvent): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.publishedOn,
          other.publishedOn,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "publishedOn",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.publishedOn.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    return _hasher;
  }

  override $toJson(): PublicationEventStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        publishedOn: this.publishedOn.map((_item) => _item.$toJson()).extract(),
      } satisfies PublicationEventStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/PublicationEvent"),
      );
    }

    _resource.add(
      PublicationEventStatic.$properties.publishedOn["identifier"],
      this.publishedOn.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PublicationEventStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/PublicationEvent",
  );
  export type $Identifier = EventStatic.$Identifier;
  export const $Identifier = EventStatic.$Identifier;
  export type $Json = {
    readonly publishedOn: BroadcastServiceStubStatic.$Json | undefined;
  } & EventStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      publishedOn: purify.Maybe<BroadcastServiceStub>;
    } & $UnwrapR<ReturnType<typeof EventStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = EventStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const publishedOn = purify.Maybe.fromNullable(
      _jsonObject["publishedOn"],
    ).map((_item) =>
      BroadcastServiceStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ...$super0, $identifier, publishedOn });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PublicationEvent> {
    return (
      BroadcastEvent.$fromJson(json) as purify.Either<
        zod.ZodError,
        PublicationEvent
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new PublicationEvent(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        EventStatic.$jsonUiSchema({ scopePrefix }),
        BroadcastServiceStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/publishedOn`,
        }),
      ],
      label: "PublicationEvent",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return EventStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["PublicationEvent", "BroadcastEvent"]),
        publishedOn: BroadcastServiceStubStatic.$jsonZodSchema().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      publishedOn: purify.Maybe<BroadcastServiceStub>;
    } & $UnwrapR<ReturnType<typeof EventStatic.$propertiesFromRdf>>
  > {
    const $super0Either = EventStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/PublicationEvent)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: PublicationEventStatic.$Identifier =
      _resource.identifier;
    const _publishedOnEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<BroadcastServiceStub>
    > = purify.Either.of(
      _resource
        .values($properties.publishedOn["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          BroadcastServiceStubStatic.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_publishedOnEither.isLeft()) {
      return _publishedOnEither;
    }

    const publishedOn = _publishedOnEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, publishedOn });
  }

  export function $fromRdf(
    parameters: Parameters<typeof PublicationEventStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PublicationEvent> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      BroadcastEvent.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        PublicationEvent
      >
    ).altLazy(() =>
      PublicationEventStatic.$propertiesFromRdf(parameters).map(
        (properties) => new PublicationEvent(properties),
      ),
    );
  }

  export const $properties = {
    ...EventStatic.$properties,
    publishedOn: {
      identifier: dataFactory.namedNode("http://schema.org/publishedOn"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PublicationEventStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PublicationEventStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PublicationEventStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("publicationEvent");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "publicationEvent");
    triples.push(
      ...EventStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}PublishedOn`),
      predicate: PublicationEventStatic.$properties.publishedOn["identifier"],
      subject,
    });
    triples.push(
      ...BroadcastServiceStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}PublishedOn`),
        variablePrefix: `${variablePrefix}PublishedOn`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("publicationEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "publicationEvent");
    for (const pattern of EventStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}PublishedOn`),
                predicate:
                  PublicationEventStatic.$properties.publishedOn["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...BroadcastServiceStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}PublishedOn`),
            variablePrefix: `${variablePrefix}PublishedOn`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Place extends Thing {
  override readonly $type = "Place";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof Thing>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): Place.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Place"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace Place {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Place",
  );
  export type $Identifier = ThingStatic.$Identifier;
  export const $Identifier = ThingStatic.$Identifier;
  export type $Json = ThingStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(json: unknown): purify.Either<zod.ZodError, Place> {
    return $propertiesFromJson(json).map((properties) => new Place(properties));
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ThingStatic.$jsonUiSchema({ scopePrefix })],
      label: "Place",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStatic.$jsonZodSchema().merge(
      zod.object({ "@id": zod.string().min(1), $type: zod.literal("Place") }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ThingStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Place)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: Place.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof Place.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Place> {
    return Place.$propertiesFromRdf(parameters).map(
      (properties) => new Place(properties),
    );
  }

  export const $properties = { ...ThingStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Place.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Place.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Place.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("place");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "place");
    triples.push(
      ...ThingStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("place");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "place");
    for (const pattern of ThingStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class PlaceStub extends ThingStub {
  override readonly $type = "PlaceStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof ThingStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): PlaceStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Place"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PlaceStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Place",
  );
  export type $Identifier = ThingStubStatic.$Identifier;
  export const $Identifier = ThingStubStatic.$Identifier;
  export type $Json = ThingStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PlaceStub> {
    return $propertiesFromJson(json).map(
      (properties) => new PlaceStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ThingStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "PlaceStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("PlaceStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ThingStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Place)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: PlaceStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof PlaceStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PlaceStub> {
    return PlaceStub.$propertiesFromRdf(parameters).map(
      (properties) => new PlaceStub(properties),
    );
  }

  export const $properties = { ...ThingStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PlaceStub.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PlaceStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PlaceStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("placeStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "placeStub");
    triples.push(
      ...ThingStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("placeStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "placeStub");
    for (const pattern of ThingStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Person extends Thing {
  override readonly $type = "Person";
  readonly birthDate: purify.Maybe<Date>;
  readonly deathDate: purify.Maybe<Date>;
  readonly familyName: purify.Maybe<string>;
  readonly gender: purify.Maybe<
    rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal
  >;
  readonly givenName: purify.Maybe<string>;
  readonly hasOccupation: readonly (OccupationStub | RoleStub)[];
  readonly jobTitle: purify.Maybe<string>;
  memberOf: OrganizationStub[];
  performerIn: EventStub[];

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly birthDate?: Date | purify.Maybe<Date>;
      readonly deathDate?: Date | purify.Maybe<Date>;
      readonly familyName?: purify.Maybe<string> | string;
      readonly gender?:
        | (rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal)
        | Date
        | boolean
        | number
        | purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal>
        | string;
      readonly givenName?: purify.Maybe<string> | string;
      readonly hasOccupation?: readonly (OccupationStub | RoleStub)[];
      readonly jobTitle?: purify.Maybe<string> | string;
      readonly memberOf?: readonly OrganizationStub[];
      readonly performerIn?: readonly EventStub[];
    } & ConstructorParameters<typeof Thing>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.birthDate)) {
      this.birthDate = parameters.birthDate;
    } else if (
      typeof parameters.birthDate === "object" &&
      parameters.birthDate instanceof Date
    ) {
      this.birthDate = purify.Maybe.of(parameters.birthDate);
    } else if (typeof parameters.birthDate === "undefined") {
      this.birthDate = purify.Maybe.empty();
    } else {
      this.birthDate = parameters.birthDate satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.deathDate)) {
      this.deathDate = parameters.deathDate;
    } else if (
      typeof parameters.deathDate === "object" &&
      parameters.deathDate instanceof Date
    ) {
      this.deathDate = purify.Maybe.of(parameters.deathDate);
    } else if (typeof parameters.deathDate === "undefined") {
      this.deathDate = purify.Maybe.empty();
    } else {
      this.deathDate = parameters.deathDate satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.familyName)) {
      this.familyName = parameters.familyName;
    } else if (typeof parameters.familyName === "string") {
      this.familyName = purify.Maybe.of(parameters.familyName);
    } else if (typeof parameters.familyName === "undefined") {
      this.familyName = purify.Maybe.empty();
    } else {
      this.familyName = parameters.familyName satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.gender)) {
      this.gender = parameters.gender;
    } else if (typeof parameters.gender === "boolean") {
      this.gender = purify.Maybe.of(
        rdfLiteral.toRdf(parameters.gender, { dataFactory }),
      );
    } else if (
      typeof parameters.gender === "object" &&
      parameters.gender instanceof Date
    ) {
      this.gender = purify.Maybe.of(
        rdfLiteral.toRdf(parameters.gender, { dataFactory }),
      );
    } else if (typeof parameters.gender === "number") {
      this.gender = purify.Maybe.of(
        rdfLiteral.toRdf(parameters.gender, { dataFactory }),
      );
    } else if (typeof parameters.gender === "string") {
      this.gender = purify.Maybe.of(dataFactory.literal(parameters.gender));
    } else if (typeof parameters.gender === "object") {
      this.gender = purify.Maybe.of(parameters.gender);
    } else if (typeof parameters.gender === "undefined") {
      this.gender = purify.Maybe.empty();
    } else {
      this.gender = parameters.gender satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.givenName)) {
      this.givenName = parameters.givenName;
    } else if (typeof parameters.givenName === "string") {
      this.givenName = purify.Maybe.of(parameters.givenName);
    } else if (typeof parameters.givenName === "undefined") {
      this.givenName = purify.Maybe.empty();
    } else {
      this.givenName = parameters.givenName satisfies never;
    }

    if (typeof parameters.hasOccupation === "undefined") {
      this.hasOccupation = [];
    } else if (typeof parameters.hasOccupation === "object") {
      this.hasOccupation = parameters.hasOccupation;
    } else {
      this.hasOccupation = parameters.hasOccupation satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.jobTitle)) {
      this.jobTitle = parameters.jobTitle;
    } else if (typeof parameters.jobTitle === "string") {
      this.jobTitle = purify.Maybe.of(parameters.jobTitle);
    } else if (typeof parameters.jobTitle === "undefined") {
      this.jobTitle = purify.Maybe.empty();
    } else {
      this.jobTitle = parameters.jobTitle satisfies never;
    }

    if (typeof parameters.memberOf === "undefined") {
      this.memberOf = [];
    } else if (typeof parameters.memberOf === "object") {
      this.memberOf = parameters.memberOf.concat();
    } else {
      this.memberOf = parameters.memberOf satisfies never;
    }

    if (typeof parameters.performerIn === "undefined") {
      this.performerIn = [];
    } else if (typeof parameters.performerIn === "object") {
      this.performerIn = parameters.performerIn.concat();
    } else {
      this.performerIn = parameters.performerIn satisfies never;
    }
  }

  override get $identifier(): Person.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: Person): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.birthDate,
          other.birthDate,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "birthDate",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.deathDate,
          other.deathDate,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "deathDate",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.familyName,
          other.familyName,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "familyName",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.gender,
          other.gender,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "gender",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.givenName,
          other.givenName,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "givenName",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left: OccupationStub | RoleStub,
              right: OccupationStub | RoleStub,
            ) => {
              if (
                left.$type === "OccupationStub" &&
                right.$type === "OccupationStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (left.$type === "RoleStub" && right.$type === "RoleStub") {
                return ((left, right) => left.$equals(right))(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.hasOccupation, other.hasOccupation).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "hasOccupation",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.jobTitle,
          other.jobTitle,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "jobTitle",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.memberOf,
          other.memberOf,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "memberOf",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.performerIn,
          other.performerIn,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "performerIn",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.birthDate.ifJust((_value0) => {
      _hasher.update(_value0.toISOString());
    });
    this.deathDate.ifJust((_value0) => {
      _hasher.update(_value0.toISOString());
    });
    this.familyName.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.gender.ifJust((_value0) => {
      _hasher.update(_value0.termType);
      _hasher.update(_value0.value);
    });
    this.givenName.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    for (const _item0 of this.hasOccupation) {
      switch (_item0.$type) {
        case "OccupationStub": {
          _item0.$hash(_hasher);
          break;
        }
        case "RoleStub": {
          _item0.$hash(_hasher);
          break;
        }
        default:
          _item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    this.jobTitle.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    for (const _item0 of this.memberOf) {
      _item0.$hash(_hasher);
    }

    for (const _item0 of this.performerIn) {
      _item0.$hash(_hasher);
    }

    return _hasher;
  }

  override $toJson(): Person.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        birthDate: this.birthDate
          .map((_item) => _item.toISOString().replace(/T.*$/, ""))
          .extract(),
        deathDate: this.deathDate
          .map((_item) => _item.toISOString().replace(/T.*$/, ""))
          .extract(),
        familyName: this.familyName.map((_item) => _item).extract(),
        gender: this.gender
          .map((_item) =>
            _item.termType === "Literal"
              ? {
                  "@language":
                    _item.language.length > 0 ? _item.language : undefined,
                  "@type":
                    _item.datatype.value !==
                    "http://www.w3.org/2001/XMLSchema#string"
                      ? _item.datatype.value
                      : undefined,
                  "@value": _item.value,
                  termType: "Literal" as const,
                }
              : _item.termType === "NamedNode"
                ? { "@id": _item.value, termType: "NamedNode" as const }
                : { "@id": `_:${_item.value}`, termType: "BlankNode" as const },
          )
          .extract(),
        givenName: this.givenName.map((_item) => _item).extract(),
        hasOccupation: this.hasOccupation.map((_item) =>
          _item.$type === "RoleStub" ? _item.$toJson() : _item.$toJson(),
        ),
        jobTitle: this.jobTitle.map((_item) => _item).extract(),
        memberOf: this.memberOf.map((_item) => _item.$toJson()),
        performerIn: this.performerIn.map((_item) => _item.$toJson()),
      } satisfies Person.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Person"),
      );
    }

    _resource.add(
      Person.$properties.birthDate["identifier"],
      this.birthDate.map((_value) =>
        rdfLiteral.toRdf(_value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.date,
        }),
      ),
    );
    _resource.add(
      Person.$properties.deathDate["identifier"],
      this.deathDate.map((_value) =>
        rdfLiteral.toRdf(_value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.date,
        }),
      ),
    );
    _resource.add(Person.$properties.familyName["identifier"], this.familyName);
    _resource.add(Person.$properties.gender["identifier"], this.gender);
    _resource.add(Person.$properties.givenName["identifier"], this.givenName);
    _resource.add(
      Person.$properties.hasOccupation["identifier"],
      this.hasOccupation.map((_item) =>
        _item.$type === "RoleStub"
          ? _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
          : _item.$toRdf({
              mutateGraph: mutateGraph,
              resourceSet: resourceSet,
            }),
      ),
    );
    _resource.add(PersonStub.$properties.jobTitle["identifier"], this.jobTitle);
    _resource.add(
      Person.$properties.memberOf["identifier"],
      this.memberOf.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      Person.$properties.performerIn["identifier"],
      this.performerIn.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace Person {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Person",
  );
  export type $Identifier = ThingStatic.$Identifier;
  export const $Identifier = ThingStatic.$Identifier;
  export type $Json = {
    readonly birthDate: string | undefined;
    readonly deathDate: string | undefined;
    readonly familyName: string | undefined;
    readonly gender:
      | (
          | {
              readonly "@id": string;
              readonly termType: "BlankNode" | "NamedNode";
            }
          | {
              readonly "@language": string | undefined;
              readonly "@type": string | undefined;
              readonly "@value": string;
              readonly termType: "Literal";
            }
        )
      | undefined;
    readonly givenName: string | undefined;
    readonly hasOccupation: readonly (OccupationStub.$Json | RoleStub.$Json)[];
    readonly jobTitle: string | undefined;
    readonly memberOf: readonly OrganizationStubStatic.$Json[];
    readonly performerIn: readonly EventStubStatic.$Json[];
  } & ThingStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      birthDate: purify.Maybe<Date>;
      deathDate: purify.Maybe<Date>;
      familyName: purify.Maybe<string>;
      gender: purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal>;
      givenName: purify.Maybe<string>;
      hasOccupation: readonly (OccupationStub | RoleStub)[];
      jobTitle: purify.Maybe<string>;
      memberOf: OrganizationStub[];
      performerIn: EventStub[];
    } & $UnwrapR<ReturnType<typeof ThingStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const birthDate = purify.Maybe.fromNullable(_jsonObject["birthDate"]).map(
      (_item) => new Date(_item),
    );
    const deathDate = purify.Maybe.fromNullable(_jsonObject["deathDate"]).map(
      (_item) => new Date(_item),
    );
    const familyName = purify.Maybe.fromNullable(_jsonObject["familyName"]);
    const gender = purify.Maybe.fromNullable(_jsonObject["gender"]).map(
      (_item) =>
        _item.termType === "Literal"
          ? dataFactory.literal(
              _item["@value"],
              typeof _item["@language"] !== "undefined"
                ? _item["@language"]
                : typeof _item["@type"] !== "undefined"
                  ? dataFactory.namedNode(_item["@type"])
                  : undefined,
            )
          : _item.termType === "NamedNode"
            ? dataFactory.namedNode(_item["@id"])
            : dataFactory.blankNode(_item["@id"].substring(2)),
    );
    const givenName = purify.Maybe.fromNullable(_jsonObject["givenName"]);
    const hasOccupation = _jsonObject["hasOccupation"].map((_item) =>
      _item.$type === "RoleStub"
        ? RoleStub.$fromJson(_item).unsafeCoerce()
        : OccupationStub.$fromJson(_item).unsafeCoerce(),
    );
    const jobTitle = purify.Maybe.fromNullable(_jsonObject["jobTitle"]);
    const memberOf = _jsonObject["memberOf"].map((_item) =>
      OrganizationStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    const performerIn = _jsonObject["performerIn"].map((_item) =>
      EventStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({
      ...$super0,
      $identifier,
      birthDate,
      deathDate,
      familyName,
      gender,
      givenName,
      hasOccupation,
      jobTitle,
      memberOf,
      performerIn,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Person> {
    return $propertiesFromJson(json).map(
      (properties) => new Person(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ThingStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/birthDate`, type: "Control" },
        { scope: `${scopePrefix}/properties/deathDate`, type: "Control" },
        { scope: `${scopePrefix}/properties/familyName`, type: "Control" },
        { scope: `${scopePrefix}/properties/gender`, type: "Control" },
        { scope: `${scopePrefix}/properties/givenName`, type: "Control" },
        { scope: `${scopePrefix}/properties/hasOccupation`, type: "Control" },
        { scope: `${scopePrefix}/properties/jobTitle`, type: "Control" },
        OrganizationStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/memberOf`,
        }),
        EventStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/performerIn`,
        }),
      ],
      label: "Person",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("Person"),
        birthDate: zod.string().date().optional(),
        deathDate: zod.string().date().optional(),
        familyName: zod.string().optional(),
        gender: zod
          .discriminatedUnion("termType", [
            zod.object({
              "@id": zod.string().min(1),
              termType: zod.literal("BlankNode"),
            }),
            zod.object({
              "@id": zod.string().min(1),
              termType: zod.literal("NamedNode"),
            }),
            zod.object({
              "@language": zod.string().optional(),
              "@type": zod.string().optional(),
              "@value": zod.string(),
              termType: zod.literal("Literal"),
            }),
          ])
          .optional(),
        givenName: zod.string().optional(),
        hasOccupation: zod
          .discriminatedUnion("$type", [
            OccupationStub.$jsonZodSchema(),
            RoleStub.$jsonZodSchema(),
          ])
          .array()
          .default(() => []),
        jobTitle: zod.string().optional(),
        memberOf: OrganizationStubStatic.$jsonZodSchema()
          .array()
          .default(() => []),
        performerIn: EventStubStatic.$jsonZodSchema()
          .array()
          .default(() => []),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      birthDate: purify.Maybe<Date>;
      deathDate: purify.Maybe<Date>;
      familyName: purify.Maybe<string>;
      gender: purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal>;
      givenName: purify.Maybe<string>;
      hasOccupation: readonly (OccupationStub | RoleStub)[];
      jobTitle: purify.Maybe<string>;
      memberOf: OrganizationStub[];
      performerIn: EventStub[];
    } & $UnwrapR<ReturnType<typeof ThingStatic.$propertiesFromRdf>>
  > {
    const $super0Either = ThingStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Person)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: Person.$Identifier = _resource.identifier;
    const _birthDateEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<Date>
    > = purify.Either.of(
      _resource
        .values($properties.birthDate["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toDate())
        .toMaybe(),
    );
    if (_birthDateEither.isLeft()) {
      return _birthDateEither;
    }

    const birthDate = _birthDateEither.unsafeCoerce();
    const _deathDateEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<Date>
    > = purify.Either.of(
      _resource
        .values($properties.deathDate["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toDate())
        .toMaybe(),
    );
    if (_deathDateEither.isLeft()) {
      return _deathDateEither;
    }

    const deathDate = _deathDateEither.unsafeCoerce();
    const _familyNameEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.familyName["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_familyNameEither.isLeft()) {
      return _familyNameEither;
    }

    const familyName = _familyNameEither.unsafeCoerce();
    const _genderEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode | rdfjs.Literal>
    > = purify.Either.of(
      _resource
        .values($properties.gender["identifier"], { unique: true })
        .head()
        .chain((_value) => purify.Either.of(_value.toTerm()))
        .toMaybe(),
    );
    if (_genderEither.isLeft()) {
      return _genderEither;
    }

    const gender = _genderEither.unsafeCoerce();
    const _givenNameEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.givenName["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_givenNameEither.isLeft()) {
      return _givenNameEither;
    }

    const givenName = _givenNameEither.unsafeCoerce();
    const _hasOccupationEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly (OccupationStub | RoleStub)[]
    > = purify.Either.of([
      ..._resource
        .values($properties.hasOccupation["identifier"], { unique: true })
        .flatMap((_item) =>
          (
            _item
              .toValues()
              .head()
              .chain((value) => value.toResource())
              .chain((_resource) =>
                OccupationStub.$fromRdf({
                  ..._context,
                  languageIn: _languageIn,
                  resource: _resource,
                }),
              ) as purify.Either<
              rdfjsResource.Resource.ValueError,
              OccupationStub | RoleStub
            >
          )
            .altLazy(
              () =>
                _item
                  .toValues()
                  .head()
                  .chain((value) => value.toResource())
                  .chain((_resource) =>
                    RoleStub.$fromRdf({
                      ..._context,
                      languageIn: _languageIn,
                      resource: _resource,
                    }),
                  ) as purify.Either<
                  rdfjsResource.Resource.ValueError,
                  OccupationStub | RoleStub
                >,
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_hasOccupationEither.isLeft()) {
      return _hasOccupationEither;
    }

    const hasOccupation = _hasOccupationEither.unsafeCoerce();
    const _jobTitleEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.jobTitle["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_jobTitleEither.isLeft()) {
      return _jobTitleEither;
    }

    const jobTitle = _jobTitleEither.unsafeCoerce();
    const _memberOfEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      OrganizationStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.memberOf["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              OrganizationStubStatic.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_memberOfEither.isLeft()) {
      return _memberOfEither;
    }

    const memberOf = _memberOfEither.unsafeCoerce();
    const _performerInEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      EventStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.performerIn["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              EventStubStatic.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_performerInEither.isLeft()) {
      return _performerInEither;
    }

    const performerIn = _performerInEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      birthDate,
      deathDate,
      familyName,
      gender,
      givenName,
      hasOccupation,
      jobTitle,
      memberOf,
      performerIn,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof Person.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Person> {
    return Person.$propertiesFromRdf(parameters).map(
      (properties) => new Person(properties),
    );
  }

  export const $properties = {
    ...ThingStatic.$properties,
    birthDate: {
      identifier: dataFactory.namedNode("http://schema.org/birthDate"),
    },
    deathDate: {
      identifier: dataFactory.namedNode("http://schema.org/deathDate"),
    },
    familyName: {
      identifier: dataFactory.namedNode("http://schema.org/familyName"),
    },
    gender: { identifier: dataFactory.namedNode("http://schema.org/gender") },
    givenName: {
      identifier: dataFactory.namedNode("http://schema.org/givenName"),
    },
    hasOccupation: {
      identifier: dataFactory.namedNode("http://schema.org/hasOccupation"),
    },
    jobTitle: {
      identifier: dataFactory.namedNode("http://schema.org/jobTitle"),
    },
    memberOf: {
      identifier: dataFactory.namedNode("http://schema.org/memberOf"),
    },
    performerIn: {
      identifier: dataFactory.namedNode("http://schema.org/performerIn"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Person.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Person.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Person.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("person");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "person");
    triples.push(
      ...ThingStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}BirthDate`),
      predicate: Person.$properties.birthDate["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}DeathDate`),
      predicate: Person.$properties.deathDate["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}FamilyName`),
      predicate: Person.$properties.familyName["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Gender`),
      predicate: Person.$properties.gender["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}GivenName`),
      predicate: Person.$properties.givenName["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}HasOccupation`),
      predicate: Person.$properties.hasOccupation["identifier"],
      subject,
    });
    triples.push(
      ...OccupationStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}HasOccupation`),
        variablePrefix: `${variablePrefix}HasOccupation`,
      }),
    );
    triples.push(
      ...RoleStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}HasOccupation`),
        variablePrefix: `${variablePrefix}HasOccupation`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}JobTitle`),
      predicate: PersonStub.$properties.jobTitle["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}MemberOf`),
      predicate: Person.$properties.memberOf["identifier"],
      subject,
    });
    triples.push(
      ...OrganizationStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}MemberOf`),
        variablePrefix: `${variablePrefix}MemberOf`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}PerformerIn`),
      predicate: Person.$properties.performerIn["identifier"],
      subject,
    });
    triples.push(
      ...EventStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}PerformerIn`),
        variablePrefix: `${variablePrefix}PerformerIn`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("person");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "person");
    for (const pattern of ThingStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}BirthDate`),
                predicate: Person.$properties.birthDate["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}DeathDate`),
                predicate: Person.$properties.deathDate["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}FamilyName`),
                predicate: Person.$properties.familyName["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Gender`),
                predicate: Person.$properties.gender["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}GivenName`),
                predicate: Person.$properties.givenName["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}HasOccupation`),
                predicate: Person.$properties.hasOccupation["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          {
            patterns: [
              {
                patterns: [
                  ...OccupationStub.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(
                      `${variablePrefix}HasOccupation`,
                    ),
                    variablePrefix: `${variablePrefix}HasOccupation`,
                  }),
                ],
                type: "group",
              },
              {
                patterns: [
                  ...RoleStub.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(
                      `${variablePrefix}HasOccupation`,
                    ),
                    variablePrefix: `${variablePrefix}HasOccupation`,
                  }),
                ],
                type: "group",
              },
            ],
            type: "union",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}JobTitle`),
                predicate: PersonStub.$properties.jobTitle["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}MemberOf`),
                predicate: Person.$properties.memberOf["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...OrganizationStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}MemberOf`),
            variablePrefix: `${variablePrefix}MemberOf`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}PerformerIn`),
                predicate: Person.$properties.performerIn["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...EventStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}PerformerIn`),
            variablePrefix: `${variablePrefix}PerformerIn`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Organization extends Thing {
  override readonly $type: "Organization" | "MusicGroup" | "PerformingGroup" =
    "Organization";
  members: AgentStub[];
  parentOrganizations: OrganizationStub[];
  subOrganizations: OrganizationStub[];

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly members?: readonly AgentStub[];
      readonly parentOrganizations?: readonly OrganizationStub[];
      readonly subOrganizations?: readonly OrganizationStub[];
    } & ConstructorParameters<typeof Thing>[0],
  ) {
    super(parameters);
    if (typeof parameters.members === "undefined") {
      this.members = [];
    } else if (typeof parameters.members === "object") {
      this.members = parameters.members.concat();
    } else {
      this.members = parameters.members satisfies never;
    }

    if (typeof parameters.parentOrganizations === "undefined") {
      this.parentOrganizations = [];
    } else if (typeof parameters.parentOrganizations === "object") {
      this.parentOrganizations = parameters.parentOrganizations.concat();
    } else {
      this.parentOrganizations = parameters.parentOrganizations satisfies never;
    }

    if (typeof parameters.subOrganizations === "undefined") {
      this.subOrganizations = [];
    } else if (typeof parameters.subOrganizations === "object") {
      this.subOrganizations = parameters.subOrganizations.concat();
    } else {
      this.subOrganizations = parameters.subOrganizations satisfies never;
    }
  }

  override get $identifier(): OrganizationStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: Organization): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, AgentStub.$equals))(
          this.members,
          other.members,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "members",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.parentOrganizations,
          other.parentOrganizations,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "parentOrganizations",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.subOrganizations,
          other.subOrganizations,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "subOrganizations",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.members) {
      _item0.$hash(_hasher);
    }

    for (const _item0 of this.parentOrganizations) {
      _item0.$hash(_hasher);
    }

    for (const _item0 of this.subOrganizations) {
      _item0.$hash(_hasher);
    }

    return _hasher;
  }

  override $toJson(): OrganizationStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        members: this.members.map((_item) => _item.$toJson()),
        parentOrganizations: this.parentOrganizations.map((_item) =>
          _item.$toJson(),
        ),
        subOrganizations: this.subOrganizations.map((_item) => _item.$toJson()),
      } satisfies OrganizationStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Organization"),
      );
    }

    _resource.add(
      OrganizationStatic.$properties.members["identifier"],
      this.members.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      OrganizationStatic.$properties.parentOrganizations["identifier"],
      this.parentOrganizations.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      OrganizationStatic.$properties.subOrganizations["identifier"],
      this.subOrganizations.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace OrganizationStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Organization",
  );
  export type $Identifier = ThingStatic.$Identifier;
  export const $Identifier = ThingStatic.$Identifier;
  export type $Json = {
    readonly members: readonly (
      | OrganizationStubStatic.$Json
      | PersonStub.$Json
    )[];
    readonly parentOrganizations: readonly OrganizationStubStatic.$Json[];
    readonly subOrganizations: readonly OrganizationStubStatic.$Json[];
  } & ThingStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      members: AgentStub[];
      parentOrganizations: OrganizationStub[];
      subOrganizations: OrganizationStub[];
    } & $UnwrapR<ReturnType<typeof ThingStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const members = _jsonObject["members"].map((_item) =>
      AgentStub.$fromJson(_item).unsafeCoerce(),
    );
    const parentOrganizations = _jsonObject["parentOrganizations"].map(
      (_item) => OrganizationStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    const subOrganizations = _jsonObject["subOrganizations"].map((_item) =>
      OrganizationStubStatic.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({
      ...$super0,
      $identifier,
      members,
      parentOrganizations,
      subOrganizations,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Organization> {
    return (
      PerformingGroupStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        Organization
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new Organization(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ThingStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/members`, type: "Control" },
        OrganizationStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/parentOrganizations`,
        }),
        OrganizationStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/subOrganizations`,
        }),
      ],
      label: "Organization",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["Organization", "MusicGroup", "PerformingGroup"]),
        members: AgentStub.$jsonZodSchema()
          .array()
          .default(() => []),
        parentOrganizations: OrganizationStubStatic.$jsonZodSchema()
          .array()
          .default(() => []),
        subOrganizations: OrganizationStubStatic.$jsonZodSchema()
          .array()
          .default(() => []),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      members: AgentStub[];
      parentOrganizations: OrganizationStub[];
      subOrganizations: OrganizationStub[];
    } & $UnwrapR<ReturnType<typeof ThingStatic.$propertiesFromRdf>>
  > {
    const $super0Either = ThingStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Organization)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: OrganizationStatic.$Identifier = _resource.identifier;
    const _membersEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      AgentStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.members["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              AgentStub.$fromRdf({
                ..._context,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_membersEither.isLeft()) {
      return _membersEither;
    }

    const members = _membersEither.unsafeCoerce();
    const _parentOrganizationsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      OrganizationStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.parentOrganizations["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              OrganizationStubStatic.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_parentOrganizationsEither.isLeft()) {
      return _parentOrganizationsEither;
    }

    const parentOrganizations = _parentOrganizationsEither.unsafeCoerce();
    const _subOrganizationsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      OrganizationStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.subOrganizations["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              OrganizationStubStatic.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_subOrganizationsEither.isLeft()) {
      return _subOrganizationsEither;
    }

    const subOrganizations = _subOrganizationsEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      members,
      parentOrganizations,
      subOrganizations,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof OrganizationStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Organization> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      PerformingGroupStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        Organization
      >
    ).altLazy(() =>
      OrganizationStatic.$propertiesFromRdf(parameters).map(
        (properties) => new Organization(properties),
      ),
    );
  }

  export const $properties = {
    ...ThingStatic.$properties,
    members: { identifier: dataFactory.namedNode("http://schema.org/member") },
    parentOrganizations: {
      identifier: dataFactory.namedNode("http://schema.org/parentOrganization"),
    },
    subOrganizations: {
      identifier: dataFactory.namedNode("http://schema.org/subOrganization"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        OrganizationStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        OrganizationStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      OrganizationStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("organization");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "organization");
    triples.push(
      ...ThingStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Members`),
      predicate: OrganizationStatic.$properties.members["identifier"],
      subject,
    });
    triples.push(
      ...AgentStub.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(`${variablePrefix}Members`),
        variablePrefix: `${variablePrefix}Members`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ParentOrganizations`),
      predicate:
        OrganizationStatic.$properties.parentOrganizations["identifier"],
      subject,
    });
    triples.push(
      ...OrganizationStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ParentOrganizations`),
        variablePrefix: `${variablePrefix}ParentOrganizations`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}SubOrganizations`),
      predicate: OrganizationStatic.$properties.subOrganizations["identifier"],
      subject,
    });
    triples.push(
      ...OrganizationStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}SubOrganizations`),
        variablePrefix: `${variablePrefix}SubOrganizations`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("organization");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "organization");
    for (const pattern of ThingStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Members`),
                predicate: OrganizationStatic.$properties.members["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...AgentStub.$sparqlWherePatterns({
            subject: dataFactory.variable!(`${variablePrefix}Members`),
            variablePrefix: `${variablePrefix}Members`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ParentOrganizations`,
                ),
                predicate:
                  OrganizationStatic.$properties.parentOrganizations[
                    "identifier"
                  ],
                subject,
              },
            ],
            type: "bgp",
          },
          ...OrganizationStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(
              `${variablePrefix}ParentOrganizations`,
            ),
            variablePrefix: `${variablePrefix}ParentOrganizations`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}SubOrganizations`,
                ),
                predicate:
                  OrganizationStatic.$properties.subOrganizations["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...OrganizationStubStatic.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}SubOrganizations`),
            variablePrefix: `${variablePrefix}SubOrganizations`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class PerformingGroup extends Organization {
  override readonly $type: "PerformingGroup" | "MusicGroup" = "PerformingGroup";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof Organization>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): PerformingGroupStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/PerformingGroup"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PerformingGroupStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/PerformingGroup",
  );
  export type $Identifier = OrganizationStatic.$Identifier;
  export const $Identifier = OrganizationStatic.$Identifier;
  export type $Json = OrganizationStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof OrganizationStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = OrganizationStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PerformingGroup> {
    return (
      MusicGroup.$fromJson(json) as purify.Either<zod.ZodError, PerformingGroup>
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new PerformingGroup(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [OrganizationStatic.$jsonUiSchema({ scopePrefix })],
      label: "PerformingGroup",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return OrganizationStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["PerformingGroup", "MusicGroup"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof OrganizationStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = OrganizationStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/PerformingGroup)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: PerformingGroupStatic.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof PerformingGroupStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PerformingGroup> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      MusicGroup.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        PerformingGroup
      >
    ).altLazy(() =>
      PerformingGroupStatic.$propertiesFromRdf(parameters).map(
        (properties) => new PerformingGroup(properties),
      ),
    );
  }

  export const $properties = { ...OrganizationStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PerformingGroupStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PerformingGroupStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PerformingGroupStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("performingGroup");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "performingGroup");
    triples.push(
      ...OrganizationStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("performingGroup");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "performingGroup");
    for (const pattern of OrganizationStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Order extends Intangible {
  override readonly $type = "Order";
  readonly partOfInvoice: purify.Maybe<InvoiceStub>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly partOfInvoice?: InvoiceStub | purify.Maybe<InvoiceStub>;
    } & ConstructorParameters<typeof Intangible>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.partOfInvoice)) {
      this.partOfInvoice = parameters.partOfInvoice;
    } else if (
      typeof parameters.partOfInvoice === "object" &&
      parameters.partOfInvoice instanceof InvoiceStub
    ) {
      this.partOfInvoice = purify.Maybe.of(parameters.partOfInvoice);
    } else if (typeof parameters.partOfInvoice === "undefined") {
      this.partOfInvoice = purify.Maybe.empty();
    } else {
      this.partOfInvoice = parameters.partOfInvoice satisfies never;
    }
  }

  override get $identifier(): Order.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: Order): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.partOfInvoice,
          other.partOfInvoice,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "partOfInvoice",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.partOfInvoice.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    return _hasher;
  }

  override $toJson(): Order.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        partOfInvoice: this.partOfInvoice
          .map((_item) => _item.$toJson())
          .extract(),
      } satisfies Order.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Order"),
      );
    }

    _resource.add(
      Order.$properties.partOfInvoice["identifier"],
      this.partOfInvoice.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace Order {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Order",
  );
  export type $Identifier = IntangibleStatic.$Identifier;
  export const $Identifier = IntangibleStatic.$Identifier;
  export type $Json = {
    readonly partOfInvoice: InvoiceStub.$Json | undefined;
  } & IntangibleStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      partOfInvoice: purify.Maybe<InvoiceStub>;
    } & $UnwrapR<ReturnType<typeof IntangibleStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const partOfInvoice = purify.Maybe.fromNullable(
      _jsonObject["partOfInvoice"],
    ).map((_item) => InvoiceStub.$fromJson(_item).unsafeCoerce());
    return purify.Either.of({ ...$super0, $identifier, partOfInvoice });
  }

  export function $fromJson(json: unknown): purify.Either<zod.ZodError, Order> {
    return $propertiesFromJson(json).map((properties) => new Order(properties));
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        IntangibleStatic.$jsonUiSchema({ scopePrefix }),
        InvoiceStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/partOfInvoice`,
        }),
      ],
      label: "Order",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("Order"),
        partOfInvoice: InvoiceStub.$jsonZodSchema().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      partOfInvoice: purify.Maybe<InvoiceStub>;
    } & $UnwrapR<ReturnType<typeof IntangibleStatic.$propertiesFromRdf>>
  > {
    const $super0Either = IntangibleStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Order)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: Order.$Identifier = _resource.identifier;
    const _partOfInvoiceEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<InvoiceStub>
    > = purify.Either.of(
      _resource
        .values($properties.partOfInvoice["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          InvoiceStub.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_partOfInvoiceEither.isLeft()) {
      return _partOfInvoiceEither;
    }

    const partOfInvoice = _partOfInvoiceEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, partOfInvoice });
  }

  export function $fromRdf(
    parameters: Parameters<typeof Order.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Order> {
    return Order.$propertiesFromRdf(parameters).map(
      (properties) => new Order(properties),
    );
  }

  export const $properties = {
    ...IntangibleStatic.$properties,
    partOfInvoice: {
      identifier: dataFactory.namedNode("http://schema.org/partOfInvoice"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Order.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Order.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Order.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("order");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "order");
    triples.push(
      ...IntangibleStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}PartOfInvoice`),
      predicate: Order.$properties.partOfInvoice["identifier"],
      subject,
    });
    triples.push(
      ...InvoiceStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}PartOfInvoice`),
        variablePrefix: `${variablePrefix}PartOfInvoice`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("order");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "order");
    for (const pattern of IntangibleStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}PartOfInvoice`),
                predicate: Order.$properties.partOfInvoice["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...InvoiceStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}PartOfInvoice`),
            variablePrefix: `${variablePrefix}PartOfInvoice`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class OrderStub extends IntangibleStub {
  override readonly $type = "OrderStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof IntangibleStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): OrderStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Order"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace OrderStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Order",
  );
  export type $Identifier = IntangibleStubStatic.$Identifier;
  export const $Identifier = IntangibleStubStatic.$Identifier;
  export type $Json = IntangibleStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, OrderStub> {
    return $propertiesFromJson(json).map(
      (properties) => new OrderStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IntangibleStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "OrderStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("OrderStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IntangibleStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Order)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: OrderStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof OrderStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, OrderStub> {
    return OrderStub.$propertiesFromRdf(parameters).map(
      (properties) => new OrderStub(properties),
    );
  }

  export const $properties = { ...IntangibleStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        OrderStub.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        OrderStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      OrderStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("orderStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "orderStub");
    triples.push(
      ...IntangibleStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("orderStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "orderStub");
    for (const pattern of IntangibleStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class OccupationStub extends IntangibleStub {
  override readonly $type = "OccupationStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof IntangibleStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): OccupationStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Occupation"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace OccupationStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Occupation",
  );
  export type $Identifier = IntangibleStubStatic.$Identifier;
  export const $Identifier = IntangibleStubStatic.$Identifier;
  export type $Json = IntangibleStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, OccupationStub> {
    return $propertiesFromJson(json).map(
      (properties) => new OccupationStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IntangibleStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "OccupationStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("OccupationStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IntangibleStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Occupation)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: OccupationStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof OccupationStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, OccupationStub> {
    return OccupationStub.$propertiesFromRdf(parameters).map(
      (properties) => new OccupationStub(properties),
    );
  }

  export const $properties = { ...IntangibleStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        OccupationStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        OccupationStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      OccupationStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("occupationStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "occupationStub");
    triples.push(
      ...IntangibleStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("occupationStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "occupationStub");
    for (const pattern of IntangibleStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MusicRecording extends CreativeWork {
  override readonly $type = "MusicRecording";
  readonly byArtists: readonly (
    | MusicGroupStub
    | PersonStub
    | MusicArtistRoleStub
  )[];
  readonly duration: purify.Maybe<string | QuantitativeValueStub>;
  readonly inAlbum: purify.Maybe<MusicAlbumStub>;
  readonly inPlaylists: readonly MusicPlaylistStub[];
  readonly recordingOf: purify.Maybe<MusicCompositionStub>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly byArtists?: readonly (
        | MusicGroupStub
        | PersonStub
        | MusicArtistRoleStub
      )[];
      readonly duration?:
        | QuantitativeValueStub
        | purify.Maybe<string | QuantitativeValueStub>
        | string;
      readonly inAlbum?: MusicAlbumStub | purify.Maybe<MusicAlbumStub>;
      readonly inPlaylists?: readonly MusicPlaylistStub[];
      readonly recordingOf?:
        | MusicCompositionStub
        | purify.Maybe<MusicCompositionStub>;
    } & ConstructorParameters<typeof CreativeWork>[0],
  ) {
    super(parameters);
    if (typeof parameters.byArtists === "undefined") {
      this.byArtists = [];
    } else if (typeof parameters.byArtists === "object") {
      this.byArtists = parameters.byArtists;
    } else {
      this.byArtists = parameters.byArtists satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.duration)) {
      this.duration = parameters.duration;
    } else if (typeof parameters.duration === "string") {
      this.duration = purify.Maybe.of(parameters.duration);
    } else if (typeof parameters.duration === "object") {
      this.duration = purify.Maybe.of(parameters.duration);
    } else if (typeof parameters.duration === "undefined") {
      this.duration = purify.Maybe.empty();
    } else {
      this.duration = parameters.duration satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.inAlbum)) {
      this.inAlbum = parameters.inAlbum;
    } else if (
      typeof parameters.inAlbum === "object" &&
      parameters.inAlbum instanceof MusicAlbumStub
    ) {
      this.inAlbum = purify.Maybe.of(parameters.inAlbum);
    } else if (typeof parameters.inAlbum === "undefined") {
      this.inAlbum = purify.Maybe.empty();
    } else {
      this.inAlbum = parameters.inAlbum satisfies never;
    }

    if (typeof parameters.inPlaylists === "undefined") {
      this.inPlaylists = [];
    } else if (typeof parameters.inPlaylists === "object") {
      this.inPlaylists = parameters.inPlaylists;
    } else {
      this.inPlaylists = parameters.inPlaylists satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.recordingOf)) {
      this.recordingOf = parameters.recordingOf;
    } else if (
      typeof parameters.recordingOf === "object" &&
      parameters.recordingOf instanceof MusicCompositionStub
    ) {
      this.recordingOf = purify.Maybe.of(parameters.recordingOf);
    } else if (typeof parameters.recordingOf === "undefined") {
      this.recordingOf = purify.Maybe.empty();
    } else {
      this.recordingOf = parameters.recordingOf satisfies never;
    }
  }

  override get $identifier(): MusicRecording.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: MusicRecording): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) =>
          $arrayEquals(
            left,
            right,
            (
              left: MusicGroupStub | PersonStub | MusicArtistRoleStub,
              right: MusicGroupStub | PersonStub | MusicArtistRoleStub,
            ) => {
              if (
                left.$type === "MusicGroupStub" &&
                right.$type === "MusicGroupStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (left.$type === "PersonStub" && right.$type === "PersonStub") {
                return ((left, right) => left.$equals(right))(left, right);
              }
              if (
                left.$type === "MusicArtistRoleStub" &&
                right.$type === "MusicArtistRoleStub"
              ) {
                return ((left, right) => left.$equals(right))(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.byArtists, other.byArtists).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "byArtists",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (
              left: string | QuantitativeValueStub,
              right: string | QuantitativeValueStub,
            ) => {
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }
              if (typeof left === "object" && typeof right === "object") {
                return ((left, right) => left.$equals(right))(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.duration, other.duration).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "duration",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.inAlbum,
          other.inAlbum,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inAlbum",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.inPlaylists,
          other.inPlaylists,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "inPlaylists",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.recordingOf,
          other.recordingOf,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "recordingOf",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.byArtists) {
      switch (_item0.$type) {
        case "MusicGroupStub": {
          _item0.$hash(_hasher);
          break;
        }
        case "PersonStub": {
          _item0.$hash(_hasher);
          break;
        }
        case "MusicArtistRoleStub": {
          _item0.$hash(_hasher);
          break;
        }
        default:
          _item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    this.duration.ifJust((_value0) => {
      switch (typeof _value0) {
        case "string": {
          _hasher.update(_value0);
          break;
        }
        case "object": {
          _value0.$hash(_hasher);
          break;
        }
        default:
          _value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    this.inAlbum.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    for (const _item0 of this.inPlaylists) {
      _item0.$hash(_hasher);
    }

    this.recordingOf.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    return _hasher;
  }

  override $toJson(): MusicRecording.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        byArtists: this.byArtists.map((_item) =>
          _item.$type === "MusicArtistRoleStub"
            ? _item.$toJson()
            : _item.$type === "PersonStub"
              ? _item.$toJson()
              : _item.$toJson(),
        ),
        duration: this.duration
          .map((_item) => (typeof _item === "object" ? _item.$toJson() : _item))
          .extract(),
        inAlbum: this.inAlbum.map((_item) => _item.$toJson()).extract(),
        inPlaylists: this.inPlaylists.map((_item) => _item.$toJson()),
        recordingOf: this.recordingOf.map((_item) => _item.$toJson()).extract(),
      } satisfies MusicRecording.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MusicRecording"),
      );
    }

    _resource.add(
      MusicRecording.$properties.byArtists["identifier"],
      this.byArtists.map((_item) =>
        _item.$type === "MusicArtistRoleStub"
          ? _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
          : _item.$type === "PersonStub"
            ? _item.$toRdf({
                mutateGraph: mutateGraph,
                resourceSet: resourceSet,
              })
            : _item.$toRdf({
                mutateGraph: mutateGraph,
                resourceSet: resourceSet,
              }),
      ),
    );
    _resource.add(
      MusicRecording.$properties.duration["identifier"],
      this.duration.map((_value) =>
        typeof _value === "object"
          ? _value.$toRdf({
              mutateGraph: mutateGraph,
              resourceSet: resourceSet,
            })
          : _value,
      ),
    );
    _resource.add(
      MusicRecording.$properties.inAlbum["identifier"],
      this.inAlbum.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      MusicRecording.$properties.inPlaylists["identifier"],
      this.inPlaylists.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      MusicRecording.$properties.recordingOf["identifier"],
      this.recordingOf.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MusicRecording {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MusicRecording",
  );
  export type $Identifier = CreativeWorkStatic.$Identifier;
  export const $Identifier = CreativeWorkStatic.$Identifier;
  export type $Json = {
    readonly byArtists: readonly (
      | MusicGroupStub.$Json
      | PersonStub.$Json
      | MusicArtistRoleStub.$Json
    )[];
    readonly duration: (string | QuantitativeValueStub.$Json) | undefined;
    readonly inAlbum: MusicAlbumStub.$Json | undefined;
    readonly inPlaylists: readonly MusicPlaylistStub.$Json[];
    readonly recordingOf: MusicCompositionStub.$Json | undefined;
  } & CreativeWorkStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      byArtists: readonly (MusicGroupStub | PersonStub | MusicArtistRoleStub)[];
      duration: purify.Maybe<string | QuantitativeValueStub>;
      inAlbum: purify.Maybe<MusicAlbumStub>;
      inPlaylists: readonly MusicPlaylistStub[];
      recordingOf: purify.Maybe<MusicCompositionStub>;
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = CreativeWorkStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const byArtists = _jsonObject["byArtists"].map((_item) =>
      _item.$type === "MusicArtistRoleStub"
        ? MusicArtistRoleStub.$fromJson(_item).unsafeCoerce()
        : _item.$type === "PersonStub"
          ? PersonStub.$fromJson(_item).unsafeCoerce()
          : MusicGroupStub.$fromJson(_item).unsafeCoerce(),
    );
    const duration = purify.Maybe.fromNullable(_jsonObject["duration"]).map(
      (_item) =>
        typeof _item === "object"
          ? QuantitativeValueStub.$fromJson(_item).unsafeCoerce()
          : _item,
    );
    const inAlbum = purify.Maybe.fromNullable(_jsonObject["inAlbum"]).map(
      (_item) => MusicAlbumStub.$fromJson(_item).unsafeCoerce(),
    );
    const inPlaylists = _jsonObject["inPlaylists"].map((_item) =>
      MusicPlaylistStub.$fromJson(_item).unsafeCoerce(),
    );
    const recordingOf = purify.Maybe.fromNullable(
      _jsonObject["recordingOf"],
    ).map((_item) => MusicCompositionStub.$fromJson(_item).unsafeCoerce());
    return purify.Either.of({
      ...$super0,
      $identifier,
      byArtists,
      duration,
      inAlbum,
      inPlaylists,
      recordingOf,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicRecording> {
    return $propertiesFromJson(json).map(
      (properties) => new MusicRecording(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        CreativeWorkStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/byArtists`, type: "Control" },
        { scope: `${scopePrefix}/properties/duration`, type: "Control" },
        MusicAlbumStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/inAlbum`,
        }),
        MusicPlaylistStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/inPlaylists`,
        }),
        MusicCompositionStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/recordingOf`,
        }),
      ],
      label: "MusicRecording",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MusicRecording"),
        byArtists: zod
          .discriminatedUnion("$type", [
            MusicGroupStub.$jsonZodSchema(),
            PersonStub.$jsonZodSchema(),
            MusicArtistRoleStub.$jsonZodSchema(),
          ])
          .array()
          .default(() => []),
        duration: zod
          .union([zod.string(), QuantitativeValueStub.$jsonZodSchema()])
          .optional(),
        inAlbum: MusicAlbumStub.$jsonZodSchema().optional(),
        inPlaylists: MusicPlaylistStub.$jsonZodSchema()
          .array()
          .default(() => []),
        recordingOf: MusicCompositionStub.$jsonZodSchema().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      byArtists: readonly (MusicGroupStub | PersonStub | MusicArtistRoleStub)[];
      duration: purify.Maybe<string | QuantitativeValueStub>;
      inAlbum: purify.Maybe<MusicAlbumStub>;
      inPlaylists: readonly MusicPlaylistStub[];
      recordingOf: purify.Maybe<MusicCompositionStub>;
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromRdf>>
  > {
    const $super0Either = CreativeWorkStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MusicRecording)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MusicRecording.$Identifier = _resource.identifier;
    const _byArtistsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly (MusicGroupStub | PersonStub | MusicArtistRoleStub)[]
    > = purify.Either.of([
      ..._resource
        .values($properties.byArtists["identifier"], { unique: true })
        .flatMap((_item) =>
          (
            _item
              .toValues()
              .head()
              .chain((value) => value.toResource())
              .chain((_resource) =>
                MusicGroupStub.$fromRdf({
                  ..._context,
                  languageIn: _languageIn,
                  resource: _resource,
                }),
              ) as purify.Either<
              rdfjsResource.Resource.ValueError,
              MusicGroupStub | PersonStub | MusicArtistRoleStub
            >
          )
            .altLazy(
              () =>
                _item
                  .toValues()
                  .head()
                  .chain((value) => value.toResource())
                  .chain((_resource) =>
                    PersonStub.$fromRdf({
                      ..._context,
                      languageIn: _languageIn,
                      resource: _resource,
                    }),
                  ) as purify.Either<
                  rdfjsResource.Resource.ValueError,
                  MusicGroupStub | PersonStub | MusicArtistRoleStub
                >,
            )
            .altLazy(
              () =>
                _item
                  .toValues()
                  .head()
                  .chain((value) => value.toResource())
                  .chain((_resource) =>
                    MusicArtistRoleStub.$fromRdf({
                      ..._context,
                      languageIn: _languageIn,
                      resource: _resource,
                    }),
                  ) as purify.Either<
                  rdfjsResource.Resource.ValueError,
                  MusicGroupStub | PersonStub | MusicArtistRoleStub
                >,
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_byArtistsEither.isLeft()) {
      return _byArtistsEither;
    }

    const byArtists = _byArtistsEither.unsafeCoerce();
    const _durationEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string | QuantitativeValueStub>
    > = purify.Either.of(
      (
        _resource
          .values($properties.duration["identifier"], { unique: true })
          .head()
          .chain((_value) => _value.toString()) as purify.Either<
          rdfjsResource.Resource.ValueError,
          string | QuantitativeValueStub
        >
      )
        .altLazy(
          () =>
            _resource
              .values($properties.duration["identifier"], { unique: true })
              .head()
              .chain((value) => value.toResource())
              .chain((_resource) =>
                QuantitativeValueStub.$fromRdf({
                  ..._context,
                  languageIn: _languageIn,
                  resource: _resource,
                }),
              ) as purify.Either<
              rdfjsResource.Resource.ValueError,
              string | QuantitativeValueStub
            >,
        )
        .toMaybe(),
    );
    if (_durationEither.isLeft()) {
      return _durationEither;
    }

    const duration = _durationEither.unsafeCoerce();
    const _inAlbumEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<MusicAlbumStub>
    > = purify.Either.of(
      _resource
        .values($properties.inAlbum["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          MusicAlbumStub.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_inAlbumEither.isLeft()) {
      return _inAlbumEither;
    }

    const inAlbum = _inAlbumEither.unsafeCoerce();
    const _inPlaylistsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly MusicPlaylistStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.inPlaylists["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              MusicPlaylistStub.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_inPlaylistsEither.isLeft()) {
      return _inPlaylistsEither;
    }

    const inPlaylists = _inPlaylistsEither.unsafeCoerce();
    const _recordingOfEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<MusicCompositionStub>
    > = purify.Either.of(
      _resource
        .values($properties.recordingOf["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          MusicCompositionStub.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_recordingOfEither.isLeft()) {
      return _recordingOfEither;
    }

    const recordingOf = _recordingOfEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      byArtists,
      duration,
      inAlbum,
      inPlaylists,
      recordingOf,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MusicRecording.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MusicRecording> {
    return MusicRecording.$propertiesFromRdf(parameters).map(
      (properties) => new MusicRecording(properties),
    );
  }

  export const $properties = {
    ...CreativeWorkStatic.$properties,
    byArtists: {
      identifier: dataFactory.namedNode("http://schema.org/byArtist"),
    },
    duration: {
      identifier: dataFactory.namedNode("http://schema.org/duration"),
    },
    inAlbum: { identifier: dataFactory.namedNode("http://schema.org/inAlbum") },
    inPlaylists: {
      identifier: dataFactory.namedNode("http://schema.org/inPlaylist"),
    },
    recordingOf: {
      identifier: dataFactory.namedNode("http://schema.org/recordingOf"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicRecording.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicRecording.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicRecording.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicRecording");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicRecording");
    triples.push(
      ...CreativeWorkStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ByArtists`),
      predicate: MusicRecording.$properties.byArtists["identifier"],
      subject,
    });
    triples.push(
      ...MusicGroupStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ByArtists`),
        variablePrefix: `${variablePrefix}ByArtists`,
      }),
    );
    triples.push(
      ...PersonStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ByArtists`),
        variablePrefix: `${variablePrefix}ByArtists`,
      }),
    );
    triples.push(
      ...MusicArtistRoleStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ByArtists`),
        variablePrefix: `${variablePrefix}ByArtists`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Duration`),
      predicate: MusicRecording.$properties.duration["identifier"],
      subject,
    });
    triples.push(
      ...QuantitativeValueStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Duration`),
        variablePrefix: `${variablePrefix}Duration`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}InAlbum`),
      predicate: MusicRecording.$properties.inAlbum["identifier"],
      subject,
    });
    triples.push(
      ...MusicAlbumStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}InAlbum`),
        variablePrefix: `${variablePrefix}InAlbum`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}InPlaylists`),
      predicate: MusicRecording.$properties.inPlaylists["identifier"],
      subject,
    });
    triples.push(
      ...MusicPlaylistStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}InPlaylists`),
        variablePrefix: `${variablePrefix}InPlaylists`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}RecordingOf`),
      predicate: MusicRecording.$properties.recordingOf["identifier"],
      subject,
    });
    triples.push(
      ...MusicCompositionStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}RecordingOf`),
        variablePrefix: `${variablePrefix}RecordingOf`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicRecording");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicRecording");
    for (const pattern of CreativeWorkStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}ByArtists`),
                predicate: MusicRecording.$properties.byArtists["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          {
            patterns: [
              {
                patterns: [
                  ...MusicGroupStub.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(
                      `${variablePrefix}ByArtists`,
                    ),
                    variablePrefix: `${variablePrefix}ByArtists`,
                  }),
                ],
                type: "group",
              },
              {
                patterns: [
                  ...PersonStub.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(
                      `${variablePrefix}ByArtists`,
                    ),
                    variablePrefix: `${variablePrefix}ByArtists`,
                  }),
                ],
                type: "group",
              },
              {
                patterns: [
                  ...MusicArtistRoleStub.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(
                      `${variablePrefix}ByArtists`,
                    ),
                    variablePrefix: `${variablePrefix}ByArtists`,
                  }),
                ],
                type: "group",
              },
            ],
            type: "union",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Duration`),
                predicate: MusicRecording.$properties.duration["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          {
            patterns: [
              { patterns: [], type: "group" },
              {
                patterns: [
                  ...QuantitativeValueStub.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(`${variablePrefix}Duration`),
                    variablePrefix: `${variablePrefix}Duration`,
                  }),
                ],
                type: "group",
              },
            ],
            type: "union",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}InAlbum`),
                predicate: MusicRecording.$properties.inAlbum["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...MusicAlbumStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}InAlbum`),
            variablePrefix: `${variablePrefix}InAlbum`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}InPlaylists`),
                predicate: MusicRecording.$properties.inPlaylists["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...MusicPlaylistStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}InPlaylists`),
            variablePrefix: `${variablePrefix}InPlaylists`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}RecordingOf`),
                predicate: MusicRecording.$properties.recordingOf["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...MusicCompositionStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}RecordingOf`),
            variablePrefix: `${variablePrefix}RecordingOf`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MusicRecordingStub extends CreativeWorkStub {
  override readonly $type = "MusicRecordingStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof CreativeWorkStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): MusicRecordingStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MusicRecording"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MusicRecordingStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MusicRecording",
  );
  export type $Identifier = CreativeWorkStubStatic.$Identifier;
  export const $Identifier = CreativeWorkStubStatic.$Identifier;
  export type $Json = CreativeWorkStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      CreativeWorkStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicRecordingStub> {
    return $propertiesFromJson(json).map(
      (properties) => new MusicRecordingStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [CreativeWorkStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "MusicRecordingStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MusicRecordingStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = CreativeWorkStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MusicRecording)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MusicRecordingStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MusicRecordingStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MusicRecordingStub> {
    return MusicRecordingStub.$propertiesFromRdf(parameters).map(
      (properties) => new MusicRecordingStub(properties),
    );
  }

  export const $properties = { ...CreativeWorkStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicRecordingStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicRecordingStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicRecordingStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicRecordingStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicRecordingStub");
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicRecordingStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicRecordingStub");
    for (const pattern of CreativeWorkStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MusicPlaylist extends CreativeWork {
  override readonly $type = "MusicPlaylist";
  tracks: (MusicRecordingStub | ItemListStub)[];

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly tracks?: readonly (MusicRecordingStub | ItemListStub)[];
    } & ConstructorParameters<typeof CreativeWork>[0],
  ) {
    super(parameters);
    if (typeof parameters.tracks === "undefined") {
      this.tracks = [];
    } else if (typeof parameters.tracks === "object") {
      this.tracks = parameters.tracks.concat();
    } else {
      this.tracks = parameters.tracks satisfies never;
    }
  }

  override get $identifier(): MusicPlaylist.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: MusicPlaylist): $EqualsResult {
    return super.$equals(other).chain(() =>
      ((left, right) =>
        $arrayEquals(
          left,
          right,
          (
            left: MusicRecordingStub | ItemListStub,
            right: MusicRecordingStub | ItemListStub,
          ) => {
            if (
              left.$type === "MusicRecordingStub" &&
              right.$type === "MusicRecordingStub"
            ) {
              return ((left, right) => left.$equals(right))(left, right);
            }
            if (
              left.$type === "ItemListStub" &&
              right.$type === "ItemListStub"
            ) {
              return ((left, right) => left.$equals(right))(left, right);
            }

            return purify.Left({
              left,
              right,
              propertyName: "type",
              propertyValuesUnequal: {
                left: typeof left,
                right: typeof right,
                type: "BooleanEquals" as const,
              },
              type: "Property" as const,
            });
          },
        ))(this.tracks, other.tracks).mapLeft((propertyValuesUnequal) => ({
        left: this,
        right: other,
        propertyName: "tracks",
        propertyValuesUnequal,
        type: "Property" as const,
      })),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.tracks) {
      switch (_item0.$type) {
        case "MusicRecordingStub": {
          _item0.$hash(_hasher);
          break;
        }
        case "ItemListStub": {
          _item0.$hash(_hasher);
          break;
        }
        default:
          _item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    return _hasher;
  }

  override $toJson(): MusicPlaylist.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        tracks: this.tracks.map((_item) =>
          _item.$type === "ItemListStub" ? _item.$toJson() : _item.$toJson(),
        ),
      } satisfies MusicPlaylist.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MusicPlaylist"),
      );
    }

    _resource.add(
      MusicPlaylist.$properties.tracks["identifier"],
      this.tracks.map((_item) =>
        _item.$type === "ItemListStub"
          ? _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
          : _item.$toRdf({
              mutateGraph: mutateGraph,
              resourceSet: resourceSet,
            }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MusicPlaylist {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MusicPlaylist",
  );
  export type $Identifier = CreativeWorkStatic.$Identifier;
  export const $Identifier = CreativeWorkStatic.$Identifier;
  export type $Json = {
    readonly tracks: readonly (MusicRecordingStub.$Json | ItemListStub.$Json)[];
  } & CreativeWorkStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      tracks: (MusicRecordingStub | ItemListStub)[];
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = CreativeWorkStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const tracks = _jsonObject["tracks"].map((_item) =>
      _item.$type === "ItemListStub"
        ? ItemListStub.$fromJson(_item).unsafeCoerce()
        : MusicRecordingStub.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ...$super0, $identifier, tracks });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicPlaylist> {
    return $propertiesFromJson(json).map(
      (properties) => new MusicPlaylist(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        CreativeWorkStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/tracks`, type: "Control" },
      ],
      label: "MusicPlaylist",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MusicPlaylist"),
        tracks: zod
          .discriminatedUnion("$type", [
            MusicRecordingStub.$jsonZodSchema(),
            ItemListStub.$jsonZodSchema(),
          ])
          .array()
          .default(() => []),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      tracks: (MusicRecordingStub | ItemListStub)[];
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromRdf>>
  > {
    const $super0Either = CreativeWorkStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MusicPlaylist)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MusicPlaylist.$Identifier = _resource.identifier;
    const _tracksEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      (MusicRecordingStub | ItemListStub)[]
    > = purify.Either.of([
      ..._resource
        .values($properties.tracks["identifier"], { unique: true })
        .flatMap((_item) =>
          (
            _item
              .toValues()
              .head()
              .chain((value) => value.toResource())
              .chain((_resource) =>
                MusicRecordingStub.$fromRdf({
                  ..._context,
                  languageIn: _languageIn,
                  resource: _resource,
                }),
              ) as purify.Either<
              rdfjsResource.Resource.ValueError,
              MusicRecordingStub | ItemListStub
            >
          )
            .altLazy(
              () =>
                _item
                  .toValues()
                  .head()
                  .chain((value) => value.toResource())
                  .chain((_resource) =>
                    ItemListStub.$fromRdf({
                      ..._context,
                      languageIn: _languageIn,
                      resource: _resource,
                    }),
                  ) as purify.Either<
                  rdfjsResource.Resource.ValueError,
                  MusicRecordingStub | ItemListStub
                >,
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_tracksEither.isLeft()) {
      return _tracksEither;
    }

    const tracks = _tracksEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, tracks });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MusicPlaylist.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MusicPlaylist> {
    return MusicPlaylist.$propertiesFromRdf(parameters).map(
      (properties) => new MusicPlaylist(properties),
    );
  }

  export const $properties = {
    ...CreativeWorkStatic.$properties,
    tracks: { identifier: dataFactory.namedNode("http://schema.org/track") },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicPlaylist.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicPlaylist.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicPlaylist.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicPlaylist");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicPlaylist");
    triples.push(
      ...CreativeWorkStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Tracks`),
      predicate: MusicPlaylist.$properties.tracks["identifier"],
      subject,
    });
    triples.push(
      ...MusicRecordingStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Tracks`),
        variablePrefix: `${variablePrefix}Tracks`,
      }),
    );
    triples.push(
      ...ItemListStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Tracks`),
        variablePrefix: `${variablePrefix}Tracks`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicPlaylist");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicPlaylist");
    for (const pattern of CreativeWorkStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Tracks`),
                predicate: MusicPlaylist.$properties.tracks["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          {
            patterns: [
              {
                patterns: [
                  ...MusicRecordingStub.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(`${variablePrefix}Tracks`),
                    variablePrefix: `${variablePrefix}Tracks`,
                  }),
                ],
                type: "group",
              },
              {
                patterns: [
                  ...ItemListStub.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(`${variablePrefix}Tracks`),
                    variablePrefix: `${variablePrefix}Tracks`,
                  }),
                ],
                type: "group",
              },
            ],
            type: "union",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MusicPlaylistStub extends CreativeWorkStub {
  override readonly $type = "MusicPlaylistStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof CreativeWorkStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): MusicPlaylistStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MusicPlaylist"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MusicPlaylistStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MusicPlaylist",
  );
  export type $Identifier = CreativeWorkStubStatic.$Identifier;
  export const $Identifier = CreativeWorkStubStatic.$Identifier;
  export type $Json = CreativeWorkStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      CreativeWorkStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicPlaylistStub> {
    return $propertiesFromJson(json).map(
      (properties) => new MusicPlaylistStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [CreativeWorkStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "MusicPlaylistStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MusicPlaylistStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = CreativeWorkStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MusicPlaylist)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MusicPlaylistStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MusicPlaylistStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MusicPlaylistStub> {
    return MusicPlaylistStub.$propertiesFromRdf(parameters).map(
      (properties) => new MusicPlaylistStub(properties),
    );
  }

  export const $properties = { ...CreativeWorkStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicPlaylistStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicPlaylistStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicPlaylistStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicPlaylistStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicPlaylistStub");
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicPlaylistStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicPlaylistStub");
    for (const pattern of CreativeWorkStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class OrganizationStub extends ThingStub {
  override readonly $type:
    | "OrganizationStub"
    | "MusicGroupStub"
    | "PerformingGroupStub" = "OrganizationStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof ThingStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): OrganizationStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Organization"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace OrganizationStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Organization",
  );
  export type $Identifier = ThingStubStatic.$Identifier;
  export const $Identifier = ThingStubStatic.$Identifier;
  export type $Json = ThingStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, OrganizationStub> {
    return (
      PerformingGroupStubStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        OrganizationStub
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new OrganizationStub(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [ThingStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "OrganizationStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "OrganizationStub",
          "MusicGroupStub",
          "PerformingGroupStub",
        ]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof ThingStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = ThingStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Organization)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: OrganizationStubStatic.$Identifier =
      _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof OrganizationStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, OrganizationStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      PerformingGroupStubStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        OrganizationStub
      >
    ).altLazy(() =>
      OrganizationStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new OrganizationStub(properties),
      ),
    );
  }

  export const $properties = { ...ThingStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        OrganizationStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        OrganizationStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      OrganizationStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("organizationStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "organizationStub");
    triples.push(
      ...ThingStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("organizationStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "organizationStub");
    for (const pattern of ThingStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class PerformingGroupStub extends OrganizationStub {
  override readonly $type: "PerformingGroupStub" | "MusicGroupStub" =
    "PerformingGroupStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof OrganizationStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): PerformingGroupStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/PerformingGroup"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PerformingGroupStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/PerformingGroup",
  );
  export type $Identifier = OrganizationStubStatic.$Identifier;
  export const $Identifier = OrganizationStubStatic.$Identifier;
  export type $Json = OrganizationStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof OrganizationStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      OrganizationStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PerformingGroupStub> {
    return (
      MusicGroupStub.$fromJson(json) as purify.Either<
        zod.ZodError,
        PerformingGroupStub
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new PerformingGroupStub(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [OrganizationStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "PerformingGroupStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return OrganizationStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["PerformingGroupStub", "MusicGroupStub"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof OrganizationStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = OrganizationStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/PerformingGroup)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: PerformingGroupStubStatic.$Identifier =
      _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<
      typeof PerformingGroupStubStatic.$propertiesFromRdf
    >[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PerformingGroupStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      MusicGroupStub.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        PerformingGroupStub
      >
    ).altLazy(() =>
      PerformingGroupStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new PerformingGroupStub(properties),
      ),
    );
  }

  export const $properties = { ...OrganizationStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PerformingGroupStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PerformingGroupStubStatic.$sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PerformingGroupStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("performingGroupStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "performingGroupStub");
    triples.push(
      ...OrganizationStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("performingGroupStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "performingGroupStub");
    for (const pattern of OrganizationStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MusicGroup extends PerformingGroup {
  override readonly $type = "MusicGroup";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof PerformingGroup>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): MusicGroup.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MusicGroup"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MusicGroup {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MusicGroup",
  );
  export type $Identifier = PerformingGroupStatic.$Identifier;
  export const $Identifier = PerformingGroupStatic.$Identifier;
  export type $Json = PerformingGroupStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof PerformingGroupStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      PerformingGroupStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicGroup> {
    return $propertiesFromJson(json).map(
      (properties) => new MusicGroup(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [PerformingGroupStatic.$jsonUiSchema({ scopePrefix })],
      label: "MusicGroup",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return PerformingGroupStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MusicGroup"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof PerformingGroupStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = PerformingGroupStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MusicGroup)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MusicGroup.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MusicGroup.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MusicGroup> {
    return MusicGroup.$propertiesFromRdf(parameters).map(
      (properties) => new MusicGroup(properties),
    );
  }

  export const $properties = { ...PerformingGroupStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicGroup.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicGroup.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicGroup.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("musicGroup");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicGroup");
    triples.push(
      ...PerformingGroupStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("musicGroup");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicGroup");
    for (const pattern of PerformingGroupStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MusicComposition extends CreativeWork {
  override readonly $type = "MusicComposition";
  readonly composers: readonly AgentStub[];
  recordedAs: MusicRecordingStub[];

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly composers?: readonly AgentStub[];
      readonly recordedAs?: readonly MusicRecordingStub[];
    } & ConstructorParameters<typeof CreativeWork>[0],
  ) {
    super(parameters);
    if (typeof parameters.composers === "undefined") {
      this.composers = [];
    } else if (typeof parameters.composers === "object") {
      this.composers = parameters.composers;
    } else {
      this.composers = parameters.composers satisfies never;
    }

    if (typeof parameters.recordedAs === "undefined") {
      this.recordedAs = [];
    } else if (typeof parameters.recordedAs === "object") {
      this.recordedAs = parameters.recordedAs.concat();
    } else {
      this.recordedAs = parameters.recordedAs satisfies never;
    }
  }

  override get $identifier(): MusicComposition.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: MusicComposition): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $arrayEquals(left, right, AgentStub.$equals))(
          this.composers,
          other.composers,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "composers",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.recordedAs,
          other.recordedAs,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "recordedAs",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.composers) {
      _item0.$hash(_hasher);
    }

    for (const _item0 of this.recordedAs) {
      _item0.$hash(_hasher);
    }

    return _hasher;
  }

  override $toJson(): MusicComposition.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        composers: this.composers.map((_item) => _item.$toJson()),
        recordedAs: this.recordedAs.map((_item) => _item.$toJson()),
      } satisfies MusicComposition.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MusicComposition"),
      );
    }

    _resource.add(
      MusicComposition.$properties.composers["identifier"],
      this.composers.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      MusicComposition.$properties.recordedAs["identifier"],
      this.recordedAs.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MusicComposition {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MusicComposition",
  );
  export type $Identifier = CreativeWorkStatic.$Identifier;
  export const $Identifier = CreativeWorkStatic.$Identifier;
  export type $Json = {
    readonly composers: readonly (
      | OrganizationStubStatic.$Json
      | PersonStub.$Json
    )[];
    readonly recordedAs: readonly MusicRecordingStub.$Json[];
  } & CreativeWorkStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      composers: readonly AgentStub[];
      recordedAs: MusicRecordingStub[];
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = CreativeWorkStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const composers = _jsonObject["composers"].map((_item) =>
      AgentStub.$fromJson(_item).unsafeCoerce(),
    );
    const recordedAs = _jsonObject["recordedAs"].map((_item) =>
      MusicRecordingStub.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ...$super0, $identifier, composers, recordedAs });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicComposition> {
    return $propertiesFromJson(json).map(
      (properties) => new MusicComposition(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        CreativeWorkStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/composers`, type: "Control" },
        MusicRecordingStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/recordedAs`,
        }),
      ],
      label: "MusicComposition",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MusicComposition"),
        composers: AgentStub.$jsonZodSchema()
          .array()
          .default(() => []),
        recordedAs: MusicRecordingStub.$jsonZodSchema()
          .array()
          .default(() => []),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      composers: readonly AgentStub[];
      recordedAs: MusicRecordingStub[];
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromRdf>>
  > {
    const $super0Either = CreativeWorkStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MusicComposition)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MusicComposition.$Identifier = _resource.identifier;
    const _composersEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly AgentStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.composers["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              AgentStub.$fromRdf({
                ..._context,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_composersEither.isLeft()) {
      return _composersEither;
    }

    const composers = _composersEither.unsafeCoerce();
    const _recordedAsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      MusicRecordingStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.recordedAs["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              MusicRecordingStub.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_recordedAsEither.isLeft()) {
      return _recordedAsEither;
    }

    const recordedAs = _recordedAsEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, composers, recordedAs });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MusicComposition.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MusicComposition> {
    return MusicComposition.$propertiesFromRdf(parameters).map(
      (properties) => new MusicComposition(properties),
    );
  }

  export const $properties = {
    ...CreativeWorkStatic.$properties,
    composers: {
      identifier: dataFactory.namedNode("http://schema.org/composer"),
    },
    recordedAs: {
      identifier: dataFactory.namedNode("http://schema.org/recordedAs"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicComposition.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicComposition.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicComposition.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicComposition");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicComposition");
    triples.push(
      ...CreativeWorkStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Composers`),
      predicate: MusicComposition.$properties.composers["identifier"],
      subject,
    });
    triples.push(
      ...AgentStub.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(`${variablePrefix}Composers`),
        variablePrefix: `${variablePrefix}Composers`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}RecordedAs`),
      predicate: MusicComposition.$properties.recordedAs["identifier"],
      subject,
    });
    triples.push(
      ...MusicRecordingStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}RecordedAs`),
        variablePrefix: `${variablePrefix}RecordedAs`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicComposition");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicComposition");
    for (const pattern of CreativeWorkStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Composers`),
                predicate: MusicComposition.$properties.composers["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...AgentStub.$sparqlWherePatterns({
            subject: dataFactory.variable!(`${variablePrefix}Composers`),
            variablePrefix: `${variablePrefix}Composers`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}RecordedAs`),
                predicate:
                  MusicComposition.$properties.recordedAs["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...MusicRecordingStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}RecordedAs`),
            variablePrefix: `${variablePrefix}RecordedAs`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MusicCompositionStub extends CreativeWorkStub {
  override readonly $type = "MusicCompositionStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof CreativeWorkStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): MusicCompositionStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MusicComposition"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MusicCompositionStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MusicComposition",
  );
  export type $Identifier = CreativeWorkStubStatic.$Identifier;
  export const $Identifier = CreativeWorkStubStatic.$Identifier;
  export type $Json = CreativeWorkStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      CreativeWorkStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicCompositionStub> {
    return $propertiesFromJson(json).map(
      (properties) => new MusicCompositionStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [CreativeWorkStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "MusicCompositionStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MusicCompositionStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = CreativeWorkStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MusicComposition)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MusicCompositionStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MusicCompositionStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MusicCompositionStub> {
    return MusicCompositionStub.$propertiesFromRdf(parameters).map(
      (properties) => new MusicCompositionStub(properties),
    );
  }

  export const $properties = { ...CreativeWorkStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicCompositionStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicCompositionStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicCompositionStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicCompositionStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "musicCompositionStub");
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicCompositionStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "musicCompositionStub");
    for (const pattern of CreativeWorkStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MusicGroupStub extends PerformingGroupStub {
  override readonly $type = "MusicGroupStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof PerformingGroupStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): MusicGroupStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MusicGroup"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MusicGroupStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MusicGroup",
  );
  export type $Identifier = PerformingGroupStubStatic.$Identifier;
  export const $Identifier = PerformingGroupStubStatic.$Identifier;
  export type $Json = PerformingGroupStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof PerformingGroupStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      PerformingGroupStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicGroupStub> {
    return $propertiesFromJson(json).map(
      (properties) => new MusicGroupStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [PerformingGroupStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "MusicGroupStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return PerformingGroupStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MusicGroupStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof PerformingGroupStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = PerformingGroupStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MusicGroup)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MusicGroupStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MusicGroupStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MusicGroupStub> {
    return MusicGroupStub.$propertiesFromRdf(parameters).map(
      (properties) => new MusicGroupStub(properties),
    );
  }

  export const $properties = { ...PerformingGroupStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicGroupStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicGroupStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicGroupStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicGroupStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicGroupStub");
    triples.push(
      ...PerformingGroupStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicGroupStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicGroupStub");
    for (const pattern of PerformingGroupStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MusicArtistRoleStub extends IntangibleStub {
  protected readonly _$identifierPrefix?: string;
  override readonly $type = "MusicArtistRoleStub";
  readonly byArtist: MusicArtistStub;
  readonly roleName: rdfjs.NamedNode<
    | "http://purl.org/sdapps/ontology#MusicConductorRoleName"
    | "http://purl.org/sdapps/ontology#MusicEnsembleRoleName"
    | "http://purl.org/sdapps/ontology#MusicSoloistRoleName"
  >;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly $identifierPrefix?: string;
      readonly byArtist: MusicArtistStub;
      readonly roleName:
        | "http://purl.org/sdapps/ontology#MusicConductorRoleName"
        | "http://purl.org/sdapps/ontology#MusicEnsembleRoleName"
        | "http://purl.org/sdapps/ontology#MusicSoloistRoleName"
        | rdfjs.NamedNode<
            | "http://purl.org/sdapps/ontology#MusicConductorRoleName"
            | "http://purl.org/sdapps/ontology#MusicEnsembleRoleName"
            | "http://purl.org/sdapps/ontology#MusicSoloistRoleName"
          >;
    } & ConstructorParameters<typeof IntangibleStub>[0],
  ) {
    super(parameters);
    this._$identifierPrefix = parameters.$identifierPrefix;
    this.byArtist = parameters.byArtist;
    if (typeof parameters.roleName === "object") {
      this.roleName = parameters.roleName;
    } else if (typeof parameters.roleName === "string") {
      this.roleName = dataFactory.namedNode(parameters.roleName);
    } else {
      this.roleName = parameters.roleName satisfies never;
    }
  }

  override get $identifier(): MusicArtistRoleStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.namedNode(
        `${this.$identifierPrefix}${this.$hashShaclProperties(sha256.create())}`,
      );
    }
    return this._$identifier;
  }

  protected get $identifierPrefix(): string {
    return typeof this._$identifierPrefix !== "undefined"
      ? this._$identifierPrefix
      : `urn:shaclmate:${this.$type}:`;
  }

  override $equals(other: MusicArtistRoleStub): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        MusicArtistStub.$equals(this.byArtist, other.byArtist).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "byArtist",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        $booleanEquals(this.roleName, other.roleName).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "roleName",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.byArtist.$hash(_hasher);
    _hasher.update(this.roleName.termType);
    _hasher.update(this.roleName.value);
    return _hasher;
  }

  override $toJson(): MusicArtistRoleStub.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        byArtist: this.byArtist.$toJson(),
        roleName: { "@id": this.roleName.value },
      } satisfies MusicArtistRoleStub.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Role"),
      );
    }

    _resource.add(
      MusicArtistRoleStub.$properties.byArtist["identifier"],
      this.byArtist.$toRdf({
        mutateGraph: mutateGraph,
        resourceSet: resourceSet,
      }),
    );
    _resource.add(
      MusicArtistRoleStub.$properties.roleName["identifier"],
      this.roleName,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MusicArtistRoleStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Role",
  );
  export type $Identifier = IntangibleStubStatic.$Identifier;
  export const $Identifier = IntangibleStubStatic.$Identifier;
  export type $Json = {
    readonly byArtist: MusicGroupStub.$Json | PersonStub.$Json;
    readonly roleName: {
      readonly "@id":
        | "http://purl.org/sdapps/ontology#MusicConductorRoleName"
        | "http://purl.org/sdapps/ontology#MusicEnsembleRoleName"
        | "http://purl.org/sdapps/ontology#MusicSoloistRoleName";
    };
  } & IntangibleStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      byArtist: MusicArtistStub;
      roleName: rdfjs.NamedNode<
        | "http://purl.org/sdapps/ontology#MusicConductorRoleName"
        | "http://purl.org/sdapps/ontology#MusicEnsembleRoleName"
        | "http://purl.org/sdapps/ontology#MusicSoloistRoleName"
      >;
    } & $UnwrapR<ReturnType<typeof IntangibleStubStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const byArtist = MusicArtistStub.$fromJson(
      _jsonObject["byArtist"],
    ).unsafeCoerce();
    const roleName = dataFactory.namedNode(_jsonObject["roleName"]["@id"]);
    return purify.Either.of({ ...$super0, $identifier, byArtist, roleName });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicArtistRoleStub> {
    return $propertiesFromJson(json).map(
      (properties) => new MusicArtistRoleStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        IntangibleStubStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/byArtist`, type: "Control" },
        { scope: `${scopePrefix}/properties/roleName`, type: "Control" },
      ],
      label: "MusicArtistRoleStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MusicArtistRoleStub"),
        byArtist: MusicArtistStub.$jsonZodSchema(),
        roleName: zod.object({
          "@id": zod.enum([
            "http://purl.org/sdapps/ontology#MusicConductorRoleName",
            "http://purl.org/sdapps/ontology#MusicEnsembleRoleName",
            "http://purl.org/sdapps/ontology#MusicSoloistRoleName",
          ]),
        }),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      byArtist: MusicArtistStub;
      roleName: rdfjs.NamedNode<
        | "http://purl.org/sdapps/ontology#MusicConductorRoleName"
        | "http://purl.org/sdapps/ontology#MusicEnsembleRoleName"
        | "http://purl.org/sdapps/ontology#MusicSoloistRoleName"
      >;
    } & $UnwrapR<ReturnType<typeof IntangibleStubStatic.$propertiesFromRdf>>
  > {
    const $super0Either = IntangibleStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Role)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MusicArtistRoleStub.$Identifier = _resource.identifier;
    const _byArtistEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      MusicArtistStub
    > = _resource
      .values($properties.byArtist["identifier"], { unique: true })
      .head()
      .chain((value) => value.toResource())
      .chain((_resource) =>
        MusicArtistStub.$fromRdf({
          ..._context,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_byArtistEither.isLeft()) {
      return _byArtistEither;
    }

    const byArtist = _byArtistEither.unsafeCoerce();
    const _roleNameEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      rdfjs.NamedNode<
        | "http://purl.org/sdapps/ontology#MusicConductorRoleName"
        | "http://purl.org/sdapps/ontology#MusicEnsembleRoleName"
        | "http://purl.org/sdapps/ontology#MusicSoloistRoleName"
      >
    > = _resource
      .values($properties.roleName["identifier"], { unique: true })
      .head()
      .chain((_value) =>
        _value.toIri().chain((iri) => {
          switch (iri.value) {
            case "http://purl.org/sdapps/ontology#MusicConductorRoleName":
              return purify.Either.of<
                rdfjsResource.Resource.ValueError,
                rdfjs.NamedNode<
                  | "http://purl.org/sdapps/ontology#MusicConductorRoleName"
                  | "http://purl.org/sdapps/ontology#MusicEnsembleRoleName"
                  | "http://purl.org/sdapps/ontology#MusicSoloistRoleName"
                >
              >(
                iri as rdfjs.NamedNode<"http://purl.org/sdapps/ontology#MusicConductorRoleName">,
              );
            case "http://purl.org/sdapps/ontology#MusicEnsembleRoleName":
              return purify.Either.of<
                rdfjsResource.Resource.ValueError,
                rdfjs.NamedNode<
                  | "http://purl.org/sdapps/ontology#MusicConductorRoleName"
                  | "http://purl.org/sdapps/ontology#MusicEnsembleRoleName"
                  | "http://purl.org/sdapps/ontology#MusicSoloistRoleName"
                >
              >(
                iri as rdfjs.NamedNode<"http://purl.org/sdapps/ontology#MusicEnsembleRoleName">,
              );
            case "http://purl.org/sdapps/ontology#MusicSoloistRoleName":
              return purify.Either.of<
                rdfjsResource.Resource.ValueError,
                rdfjs.NamedNode<
                  | "http://purl.org/sdapps/ontology#MusicConductorRoleName"
                  | "http://purl.org/sdapps/ontology#MusicEnsembleRoleName"
                  | "http://purl.org/sdapps/ontology#MusicSoloistRoleName"
                >
              >(
                iri as rdfjs.NamedNode<"http://purl.org/sdapps/ontology#MusicSoloistRoleName">,
              );
            default:
              return purify.Left(
                new rdfjsResource.Resource.MistypedValueError({
                  actualValue: iri,
                  expectedValueType:
                    'rdfjs.NamedNode<"http://purl.org/sdapps/ontology#MusicConductorRoleName" | "http://purl.org/sdapps/ontology#MusicEnsembleRoleName" | "http://purl.org/sdapps/ontology#MusicSoloistRoleName">',
                  focusResource: _resource,
                  predicate:
                    MusicArtistRoleStub.$properties.roleName["identifier"],
                }),
              );
          }
        }),
      );
    if (_roleNameEither.isLeft()) {
      return _roleNameEither;
    }

    const roleName = _roleNameEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, byArtist, roleName });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MusicArtistRoleStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MusicArtistRoleStub> {
    return MusicArtistRoleStub.$propertiesFromRdf(parameters).map(
      (properties) => new MusicArtistRoleStub(properties),
    );
  }

  export const $properties = {
    ...IntangibleStubStatic.$properties,
    byArtist: {
      identifier: dataFactory.namedNode("http://schema.org/byArtist"),
    },
    roleName: {
      identifier: dataFactory.namedNode("http://schema.org/roleName"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicArtistRoleStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicArtistRoleStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicArtistRoleStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicArtistRoleStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicArtistRoleStub");
    triples.push(
      ...IntangibleStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ByArtist`),
      predicate: MusicArtistRoleStub.$properties.byArtist["identifier"],
      subject,
    });
    triples.push(
      ...MusicArtistStub.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(`${variablePrefix}ByArtist`),
        variablePrefix: `${variablePrefix}ByArtist`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}RoleName`),
      predicate: MusicArtistRoleStub.$properties.roleName["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicArtistRoleStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicArtistRoleStub");
    for (const pattern of IntangibleStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}ByArtist`),
            predicate: MusicArtistRoleStub.$properties.byArtist["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...MusicArtistStub.$sparqlWherePatterns({
        subject: dataFactory.variable!(`${variablePrefix}ByArtist`),
        variablePrefix: `${variablePrefix}ByArtist`,
      }),
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}RoleName`),
            predicate: MusicArtistRoleStub.$properties.roleName["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MusicAlbum extends CreativeWork {
  override readonly $type = "MusicAlbum";
  readonly byArtists: readonly (
    | MusicGroupStub
    | PersonStub
    | MusicArtistRoleStub
  )[];

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly byArtists?: readonly (
        | MusicGroupStub
        | PersonStub
        | MusicArtistRoleStub
      )[];
    } & ConstructorParameters<typeof CreativeWork>[0],
  ) {
    super(parameters);
    if (typeof parameters.byArtists === "undefined") {
      this.byArtists = [];
    } else if (typeof parameters.byArtists === "object") {
      this.byArtists = parameters.byArtists;
    } else {
      this.byArtists = parameters.byArtists satisfies never;
    }
  }

  override get $identifier(): MusicAlbum.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: MusicAlbum): $EqualsResult {
    return super.$equals(other).chain(() =>
      ((left, right) =>
        $arrayEquals(
          left,
          right,
          (
            left: MusicGroupStub | PersonStub | MusicArtistRoleStub,
            right: MusicGroupStub | PersonStub | MusicArtistRoleStub,
          ) => {
            if (
              left.$type === "MusicGroupStub" &&
              right.$type === "MusicGroupStub"
            ) {
              return ((left, right) => left.$equals(right))(left, right);
            }
            if (left.$type === "PersonStub" && right.$type === "PersonStub") {
              return ((left, right) => left.$equals(right))(left, right);
            }
            if (
              left.$type === "MusicArtistRoleStub" &&
              right.$type === "MusicArtistRoleStub"
            ) {
              return ((left, right) => left.$equals(right))(left, right);
            }

            return purify.Left({
              left,
              right,
              propertyName: "type",
              propertyValuesUnequal: {
                left: typeof left,
                right: typeof right,
                type: "BooleanEquals" as const,
              },
              type: "Property" as const,
            });
          },
        ))(this.byArtists, other.byArtists).mapLeft(
        (propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "byArtists",
          propertyValuesUnequal,
          type: "Property" as const,
        }),
      ),
    );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.byArtists) {
      switch (_item0.$type) {
        case "MusicGroupStub": {
          _item0.$hash(_hasher);
          break;
        }
        case "PersonStub": {
          _item0.$hash(_hasher);
          break;
        }
        case "MusicArtistRoleStub": {
          _item0.$hash(_hasher);
          break;
        }
        default:
          _item0 satisfies never;
          throw new Error("unrecognized type");
      }
    }

    return _hasher;
  }

  override $toJson(): MusicAlbum.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        byArtists: this.byArtists.map((_item) =>
          _item.$type === "MusicArtistRoleStub"
            ? _item.$toJson()
            : _item.$type === "PersonStub"
              ? _item.$toJson()
              : _item.$toJson(),
        ),
      } satisfies MusicAlbum.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MusicAlbum"),
      );
    }

    _resource.add(
      MusicAlbum.$properties.byArtists["identifier"],
      this.byArtists.map((_item) =>
        _item.$type === "MusicArtistRoleStub"
          ? _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet })
          : _item.$type === "PersonStub"
            ? _item.$toRdf({
                mutateGraph: mutateGraph,
                resourceSet: resourceSet,
              })
            : _item.$toRdf({
                mutateGraph: mutateGraph,
                resourceSet: resourceSet,
              }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MusicAlbum {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MusicAlbum",
  );
  export type $Identifier = CreativeWorkStatic.$Identifier;
  export const $Identifier = CreativeWorkStatic.$Identifier;
  export type $Json = {
    readonly byArtists: readonly (
      | MusicGroupStub.$Json
      | PersonStub.$Json
      | MusicArtistRoleStub.$Json
    )[];
  } & CreativeWorkStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      byArtists: readonly (MusicGroupStub | PersonStub | MusicArtistRoleStub)[];
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = CreativeWorkStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const byArtists = _jsonObject["byArtists"].map((_item) =>
      _item.$type === "MusicArtistRoleStub"
        ? MusicArtistRoleStub.$fromJson(_item).unsafeCoerce()
        : _item.$type === "PersonStub"
          ? PersonStub.$fromJson(_item).unsafeCoerce()
          : MusicGroupStub.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ...$super0, $identifier, byArtists });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicAlbum> {
    return $propertiesFromJson(json).map(
      (properties) => new MusicAlbum(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        CreativeWorkStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/byArtists`, type: "Control" },
      ],
      label: "MusicAlbum",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MusicAlbum"),
        byArtists: zod
          .discriminatedUnion("$type", [
            MusicGroupStub.$jsonZodSchema(),
            PersonStub.$jsonZodSchema(),
            MusicArtistRoleStub.$jsonZodSchema(),
          ])
          .array()
          .default(() => []),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      byArtists: readonly (MusicGroupStub | PersonStub | MusicArtistRoleStub)[];
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromRdf>>
  > {
    const $super0Either = CreativeWorkStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MusicAlbum)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MusicAlbum.$Identifier = _resource.identifier;
    const _byArtistsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly (MusicGroupStub | PersonStub | MusicArtistRoleStub)[]
    > = purify.Either.of([
      ..._resource
        .values($properties.byArtists["identifier"], { unique: true })
        .flatMap((_item) =>
          (
            _item
              .toValues()
              .head()
              .chain((value) => value.toResource())
              .chain((_resource) =>
                MusicGroupStub.$fromRdf({
                  ..._context,
                  languageIn: _languageIn,
                  resource: _resource,
                }),
              ) as purify.Either<
              rdfjsResource.Resource.ValueError,
              MusicGroupStub | PersonStub | MusicArtistRoleStub
            >
          )
            .altLazy(
              () =>
                _item
                  .toValues()
                  .head()
                  .chain((value) => value.toResource())
                  .chain((_resource) =>
                    PersonStub.$fromRdf({
                      ..._context,
                      languageIn: _languageIn,
                      resource: _resource,
                    }),
                  ) as purify.Either<
                  rdfjsResource.Resource.ValueError,
                  MusicGroupStub | PersonStub | MusicArtistRoleStub
                >,
            )
            .altLazy(
              () =>
                _item
                  .toValues()
                  .head()
                  .chain((value) => value.toResource())
                  .chain((_resource) =>
                    MusicArtistRoleStub.$fromRdf({
                      ..._context,
                      languageIn: _languageIn,
                      resource: _resource,
                    }),
                  ) as purify.Either<
                  rdfjsResource.Resource.ValueError,
                  MusicGroupStub | PersonStub | MusicArtistRoleStub
                >,
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_byArtistsEither.isLeft()) {
      return _byArtistsEither;
    }

    const byArtists = _byArtistsEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, byArtists });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MusicAlbum.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MusicAlbum> {
    return MusicAlbum.$propertiesFromRdf(parameters).map(
      (properties) => new MusicAlbum(properties),
    );
  }

  export const $properties = {
    ...CreativeWorkStatic.$properties,
    byArtists: {
      identifier: dataFactory.namedNode("http://schema.org/byArtist"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicAlbum.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicAlbum.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicAlbum.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("musicAlbum");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicAlbum");
    triples.push(
      ...CreativeWorkStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ByArtists`),
      predicate: MusicAlbum.$properties.byArtists["identifier"],
      subject,
    });
    triples.push(
      ...MusicGroupStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ByArtists`),
        variablePrefix: `${variablePrefix}ByArtists`,
      }),
    );
    triples.push(
      ...PersonStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ByArtists`),
        variablePrefix: `${variablePrefix}ByArtists`,
      }),
    );
    triples.push(
      ...MusicArtistRoleStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ByArtists`),
        variablePrefix: `${variablePrefix}ByArtists`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("musicAlbum");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicAlbum");
    for (const pattern of CreativeWorkStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}ByArtists`),
                predicate: MusicAlbum.$properties.byArtists["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          {
            patterns: [
              {
                patterns: [
                  ...MusicGroupStub.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(
                      `${variablePrefix}ByArtists`,
                    ),
                    variablePrefix: `${variablePrefix}ByArtists`,
                  }),
                ],
                type: "group",
              },
              {
                patterns: [
                  ...PersonStub.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(
                      `${variablePrefix}ByArtists`,
                    ),
                    variablePrefix: `${variablePrefix}ByArtists`,
                  }),
                ],
                type: "group",
              },
              {
                patterns: [
                  ...MusicArtistRoleStub.$sparqlWherePatterns({
                    ignoreRdfType: true,
                    subject: dataFactory.variable!(
                      `${variablePrefix}ByArtists`,
                    ),
                    variablePrefix: `${variablePrefix}ByArtists`,
                  }),
                ],
                type: "group",
              },
            ],
            type: "union",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MusicAlbumStub extends CreativeWorkStub {
  override readonly $type = "MusicAlbumStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof CreativeWorkStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): MusicAlbumStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MusicAlbum"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MusicAlbumStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MusicAlbum",
  );
  export type $Identifier = CreativeWorkStubStatic.$Identifier;
  export const $Identifier = CreativeWorkStubStatic.$Identifier;
  export type $Json = CreativeWorkStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      CreativeWorkStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicAlbumStub> {
    return $propertiesFromJson(json).map(
      (properties) => new MusicAlbumStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [CreativeWorkStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "MusicAlbumStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MusicAlbumStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = CreativeWorkStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MusicAlbum)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MusicAlbumStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MusicAlbumStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MusicAlbumStub> {
    return MusicAlbumStub.$propertiesFromRdf(parameters).map(
      (properties) => new MusicAlbumStub(properties),
    );
  }

  export const $properties = { ...CreativeWorkStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicAlbumStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicAlbumStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicAlbumStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicAlbumStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicAlbumStub");
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("musicAlbumStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "musicAlbumStub");
    for (const pattern of CreativeWorkStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MonetaryAmount extends StructuredValue {
  override readonly $type = "MonetaryAmount";
  readonly currency: purify.Maybe<string>;
  readonly value: purify.Maybe<number>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly currency?: purify.Maybe<string> | string;
      readonly value?: number | purify.Maybe<number>;
    } & ConstructorParameters<typeof StructuredValue>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.currency)) {
      this.currency = parameters.currency;
    } else if (typeof parameters.currency === "string") {
      this.currency = purify.Maybe.of(parameters.currency);
    } else if (typeof parameters.currency === "undefined") {
      this.currency = purify.Maybe.empty();
    } else {
      this.currency = parameters.currency satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.value)) {
      this.value = parameters.value;
    } else if (typeof parameters.value === "number") {
      this.value = purify.Maybe.of(parameters.value);
    } else if (typeof parameters.value === "undefined") {
      this.value = purify.Maybe.empty();
    } else {
      this.value = parameters.value satisfies never;
    }
  }

  override get $identifier(): MonetaryAmount.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: MonetaryAmount): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.currency,
          other.currency,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "currency",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.value,
          other.value,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "value",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.currency.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.value.ifJust((_value0) => {
      _hasher.update(_value0.toString());
    });
    return _hasher;
  }

  override $toJson(): MonetaryAmount.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        currency: this.currency.map((_item) => _item).extract(),
        value: this.value.map((_item) => _item).extract(),
      } satisfies MonetaryAmount.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MonetaryAmount"),
      );
    }

    _resource.add(
      MonetaryAmount.$properties.currency["identifier"],
      this.currency,
    );
    _resource.add(MonetaryAmount.$properties.value["identifier"], this.value);
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MonetaryAmount {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MonetaryAmount",
  );
  export type $Identifier = StructuredValueStatic.$Identifier;
  export const $Identifier = StructuredValueStatic.$Identifier;
  export type $Json = {
    readonly currency: string | undefined;
    readonly value: number | undefined;
  } & StructuredValueStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      currency: purify.Maybe<string>;
      value: purify.Maybe<number>;
    } & $UnwrapR<ReturnType<typeof StructuredValueStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      StructuredValueStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const currency = purify.Maybe.fromNullable(_jsonObject["currency"]);
    const value = purify.Maybe.fromNullable(_jsonObject["value"]);
    return purify.Either.of({ ...$super0, $identifier, currency, value });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MonetaryAmount> {
    return $propertiesFromJson(json).map(
      (properties) => new MonetaryAmount(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        StructuredValueStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/currency`, type: "Control" },
        { scope: `${scopePrefix}/properties/value`, type: "Control" },
      ],
      label: "MonetaryAmount",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return StructuredValueStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MonetaryAmount"),
        currency: zod.string().optional(),
        value: zod.number().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      currency: purify.Maybe<string>;
      value: purify.Maybe<number>;
    } & $UnwrapR<ReturnType<typeof StructuredValueStatic.$propertiesFromRdf>>
  > {
    const $super0Either = StructuredValueStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MonetaryAmount)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MonetaryAmount.$Identifier = _resource.identifier;
    const _currencyEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.currency["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_currencyEither.isLeft()) {
      return _currencyEither;
    }

    const currency = _currencyEither.unsafeCoerce();
    const _valueEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<number>
    > = purify.Either.of(
      _resource
        .values($properties.value["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toNumber())
        .toMaybe(),
    );
    if (_valueEither.isLeft()) {
      return _valueEither;
    }

    const value = _valueEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, currency, value });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MonetaryAmount.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MonetaryAmount> {
    return MonetaryAmount.$propertiesFromRdf(parameters).map(
      (properties) => new MonetaryAmount(properties),
    );
  }

  export const $properties = {
    ...StructuredValueStatic.$properties,
    currency: {
      identifier: dataFactory.namedNode("http://schema.org/currency"),
    },
    value: { identifier: dataFactory.namedNode("http://schema.org/value") },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MonetaryAmount.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MonetaryAmount.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MonetaryAmount.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("monetaryAmount");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "monetaryAmount");
    triples.push(
      ...StructuredValueStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Currency`),
      predicate: MonetaryAmount.$properties.currency["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Value`),
      predicate: MonetaryAmount.$properties.value["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("monetaryAmount");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "monetaryAmount");
    for (const pattern of StructuredValueStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Currency`),
                predicate: MonetaryAmount.$properties.currency["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Value`),
                predicate: MonetaryAmount.$properties.value["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MonetaryAmountStub extends StructuredValueStub {
  override readonly $type = "MonetaryAmountStub";
  readonly currency: purify.Maybe<string>;
  readonly value: purify.Maybe<number>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly currency?: purify.Maybe<string> | string;
      readonly value?: number | purify.Maybe<number>;
    } & ConstructorParameters<typeof StructuredValueStub>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.currency)) {
      this.currency = parameters.currency;
    } else if (typeof parameters.currency === "string") {
      this.currency = purify.Maybe.of(parameters.currency);
    } else if (typeof parameters.currency === "undefined") {
      this.currency = purify.Maybe.empty();
    } else {
      this.currency = parameters.currency satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.value)) {
      this.value = parameters.value;
    } else if (typeof parameters.value === "number") {
      this.value = purify.Maybe.of(parameters.value);
    } else if (typeof parameters.value === "undefined") {
      this.value = purify.Maybe.empty();
    } else {
      this.value = parameters.value satisfies never;
    }
  }

  override get $identifier(): MonetaryAmountStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: MonetaryAmountStub): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.currency,
          other.currency,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "currency",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.value,
          other.value,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "value",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.currency.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.value.ifJust((_value0) => {
      _hasher.update(_value0.toString());
    });
    return _hasher;
  }

  override $toJson(): MonetaryAmountStub.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        currency: this.currency.map((_item) => _item).extract(),
        value: this.value.map((_item) => _item).extract(),
      } satisfies MonetaryAmountStub.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/MonetaryAmount"),
      );
    }

    _resource.add(
      MonetaryAmount.$properties.currency["identifier"],
      this.currency,
    );
    _resource.add(MonetaryAmount.$properties.value["identifier"], this.value);
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MonetaryAmountStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/MonetaryAmount",
  );
  export type $Identifier = StructuredValueStubStatic.$Identifier;
  export const $Identifier = StructuredValueStubStatic.$Identifier;
  export type $Json = {
    readonly currency: string | undefined;
    readonly value: number | undefined;
  } & StructuredValueStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      currency: purify.Maybe<string>;
      value: purify.Maybe<number>;
    } & $UnwrapR<
      ReturnType<typeof StructuredValueStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      StructuredValueStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const currency = purify.Maybe.fromNullable(_jsonObject["currency"]);
    const value = purify.Maybe.fromNullable(_jsonObject["value"]);
    return purify.Either.of({ ...$super0, $identifier, currency, value });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MonetaryAmountStub> {
    return $propertiesFromJson(json).map(
      (properties) => new MonetaryAmountStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        StructuredValueStubStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/currency`, type: "Control" },
        { scope: `${scopePrefix}/properties/value`, type: "Control" },
      ],
      label: "MonetaryAmountStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return StructuredValueStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MonetaryAmountStub"),
        currency: zod.string().optional(),
        value: zod.number().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      currency: purify.Maybe<string>;
      value: purify.Maybe<number>;
    } & $UnwrapR<
      ReturnType<typeof StructuredValueStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = StructuredValueStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/MonetaryAmount)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MonetaryAmountStub.$Identifier = _resource.identifier;
    const _currencyEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.currency["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_currencyEither.isLeft()) {
      return _currencyEither;
    }

    const currency = _currencyEither.unsafeCoerce();
    const _valueEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<number>
    > = purify.Either.of(
      _resource
        .values($properties.value["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toNumber())
        .toMaybe(),
    );
    if (_valueEither.isLeft()) {
      return _valueEither;
    }

    const value = _valueEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, currency, value });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MonetaryAmountStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MonetaryAmountStub> {
    return MonetaryAmountStub.$propertiesFromRdf(parameters).map(
      (properties) => new MonetaryAmountStub(properties),
    );
  }

  export const $properties = {
    ...StructuredValueStubStatic.$properties,
    currency: {
      identifier: dataFactory.namedNode("http://schema.org/currency"),
    },
    value: { identifier: dataFactory.namedNode("http://schema.org/value") },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MonetaryAmountStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MonetaryAmountStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MonetaryAmountStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("monetaryAmountStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "monetaryAmountStub");
    triples.push(
      ...StructuredValueStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Currency`),
      predicate: MonetaryAmount.$properties.currency["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Value`),
      predicate: MonetaryAmount.$properties.value["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("monetaryAmountStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "monetaryAmountStub");
    for (const pattern of StructuredValueStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Currency`),
                predicate: MonetaryAmount.$properties.currency["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Value`),
                predicate: MonetaryAmount.$properties.value["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Message extends CreativeWork {
  override readonly $type = "Message";
  readonly sender: purify.Maybe<AgentStub>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly sender?: AgentStub | purify.Maybe<AgentStub>;
    } & ConstructorParameters<typeof CreativeWork>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.sender)) {
      this.sender = parameters.sender;
    } else if (typeof parameters.sender === "object") {
      this.sender = purify.Maybe.of(parameters.sender);
    } else if (typeof parameters.sender === "undefined") {
      this.sender = purify.Maybe.empty();
    } else {
      this.sender = parameters.sender satisfies never;
    }
  }

  override get $identifier(): Message.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: Message): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, AgentStub.$equals))(
          this.sender,
          other.sender,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "sender",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.sender.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    return _hasher;
  }

  override $toJson(): Message.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        sender: this.sender.map((_item) => _item.$toJson()).extract(),
      } satisfies Message.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Message"),
      );
    }

    _resource.add(
      Message.$properties.sender["identifier"],
      this.sender.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace Message {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Message",
  );
  export type $Identifier = CreativeWorkStatic.$Identifier;
  export const $Identifier = CreativeWorkStatic.$Identifier;
  export type $Json = {
    readonly sender:
      | (OrganizationStubStatic.$Json | PersonStub.$Json)
      | undefined;
  } & CreativeWorkStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      sender: purify.Maybe<AgentStub>;
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = CreativeWorkStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const sender = purify.Maybe.fromNullable(_jsonObject["sender"]).map(
      (_item) => AgentStub.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ...$super0, $identifier, sender });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Message> {
    return $propertiesFromJson(json).map(
      (properties) => new Message(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        CreativeWorkStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/sender`, type: "Control" },
      ],
      label: "Message",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("Message"),
        sender: AgentStub.$jsonZodSchema().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      sender: purify.Maybe<AgentStub>;
    } & $UnwrapR<ReturnType<typeof CreativeWorkStatic.$propertiesFromRdf>>
  > {
    const $super0Either = CreativeWorkStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Message)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: Message.$Identifier = _resource.identifier;
    const _senderEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<AgentStub>
    > = purify.Either.of(
      _resource
        .values($properties.sender["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          AgentStub.$fromRdf({
            ..._context,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_senderEither.isLeft()) {
      return _senderEither;
    }

    const sender = _senderEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, sender });
  }

  export function $fromRdf(
    parameters: Parameters<typeof Message.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Message> {
    return Message.$propertiesFromRdf(parameters).map(
      (properties) => new Message(properties),
    );
  }

  export const $properties = {
    ...CreativeWorkStatic.$properties,
    sender: { identifier: dataFactory.namedNode("http://schema.org/sender") },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Message.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Message.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Message.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("message");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "message");
    triples.push(
      ...CreativeWorkStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Sender`),
      predicate: Message.$properties.sender["identifier"],
      subject,
    });
    triples.push(
      ...AgentStub.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(`${variablePrefix}Sender`),
        variablePrefix: `${variablePrefix}Sender`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("message");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "message");
    for (const pattern of CreativeWorkStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Sender`),
                predicate: Message.$properties.sender["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...AgentStub.$sparqlWherePatterns({
            subject: dataFactory.variable!(`${variablePrefix}Sender`),
            variablePrefix: `${variablePrefix}Sender`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class MessageStub extends CreativeWorkStub {
  override readonly $type = "MessageStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof CreativeWorkStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): MessageStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Message"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace MessageStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Message",
  );
  export type $Identifier = CreativeWorkStubStatic.$Identifier;
  export const $Identifier = CreativeWorkStubStatic.$Identifier;
  export type $Json = CreativeWorkStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      CreativeWorkStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MessageStub> {
    return $propertiesFromJson(json).map(
      (properties) => new MessageStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [CreativeWorkStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "MessageStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return CreativeWorkStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("MessageStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof CreativeWorkStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = CreativeWorkStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Message)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: MessageStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof MessageStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, MessageStub> {
    return MessageStub.$propertiesFromRdf(parameters).map(
      (properties) => new MessageStub(properties),
    );
  }

  export const $properties = { ...CreativeWorkStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MessageStub.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MessageStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MessageStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("messageStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "messageStub");
    triples.push(
      ...CreativeWorkStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("messageStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "messageStub");
    for (const pattern of CreativeWorkStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ListItem extends Intangible {
  override readonly $type = "ListItem";
  readonly item: ThingStub;
  readonly position: purify.Maybe<number | string>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly item: ThingStub;
      readonly position?: number | purify.Maybe<number | string> | string;
    } & ConstructorParameters<typeof Intangible>[0],
  ) {
    super(parameters);
    this.item = parameters.item;
    if (purify.Maybe.isMaybe(parameters.position)) {
      this.position = parameters.position;
    } else if (typeof parameters.position === "number") {
      this.position = purify.Maybe.of(parameters.position);
    } else if (typeof parameters.position === "string") {
      this.position = purify.Maybe.of(parameters.position);
    } else if (typeof parameters.position === "undefined") {
      this.position = purify.Maybe.empty();
    } else {
      this.position = parameters.position satisfies never;
    }
  }

  override get $identifier(): ListItem.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: ListItem): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => left.$equals(right))(this.item, other.item).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "item",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (left: number | string, right: number | string) => {
              if (typeof left === "number" && typeof right === "number") {
                return $strictEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.position, other.position).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "position",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.item.$hash(_hasher);
    this.position.ifJust((_value0) => {
      switch (typeof _value0) {
        case "number": {
          _hasher.update(_value0.toString());
          break;
        }
        case "string": {
          _hasher.update(_value0);
          break;
        }
        default:
          _value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    return _hasher;
  }

  override $toJson(): ListItem.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        item: this.item.$toJson(),
        position: this.position
          .map((_item) => (typeof _item === "string" ? _item : _item))
          .extract(),
      } satisfies ListItem.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/ListItem"),
      );
    }

    _resource.add(
      ListItem.$properties.item["identifier"],
      this.item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    _resource.add(
      ListItem.$properties.position["identifier"],
      this.position.map((_value) =>
        typeof _value === "string" ? _value : _value,
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ListItem {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/ListItem",
  );
  export type $Identifier = IntangibleStatic.$Identifier;
  export const $Identifier = IntangibleStatic.$Identifier;
  export type $Json = {
    readonly item: ThingStubStatic.$Json;
    readonly position: (number | string) | undefined;
  } & IntangibleStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      item: ThingStub;
      position: purify.Maybe<number | string>;
    } & $UnwrapR<ReturnType<typeof IntangibleStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const item = ThingStubStatic.$fromJson(_jsonObject["item"]).unsafeCoerce();
    const position = purify.Maybe.fromNullable(_jsonObject["position"]).map(
      (_item) => (typeof _item === "string" ? _item : _item),
    );
    return purify.Either.of({ ...$super0, $identifier, item, position });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ListItem> {
    return $propertiesFromJson(json).map(
      (properties) => new ListItem(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        IntangibleStatic.$jsonUiSchema({ scopePrefix }),
        ThingStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/item`,
        }),
        { scope: `${scopePrefix}/properties/position`, type: "Control" },
      ],
      label: "ListItem",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ListItem"),
        item: ThingStubStatic.$jsonZodSchema(),
        position: zod.union([zod.number(), zod.string()]).optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      item: ThingStub;
      position: purify.Maybe<number | string>;
    } & $UnwrapR<ReturnType<typeof IntangibleStatic.$propertiesFromRdf>>
  > {
    const $super0Either = IntangibleStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/ListItem)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ListItem.$Identifier = _resource.identifier;
    const _itemEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      ThingStub
    > = _resource
      .values($properties.item["identifier"], { unique: true })
      .head()
      .chain((value) => value.toResource())
      .chain((_resource) =>
        ThingStubStatic.$fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_itemEither.isLeft()) {
      return _itemEither;
    }

    const item = _itemEither.unsafeCoerce();
    const _positionEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<number | string>
    > = purify.Either.of(
      (
        _resource
          .values($properties.position["identifier"], { unique: true })
          .head()
          .chain((_value) => _value.toNumber()) as purify.Either<
          rdfjsResource.Resource.ValueError,
          number | string
        >
      )
        .altLazy(
          () =>
            _resource
              .values($properties.position["identifier"], { unique: true })
              .head()
              .chain((_value) => _value.toString()) as purify.Either<
              rdfjsResource.Resource.ValueError,
              number | string
            >,
        )
        .toMaybe(),
    );
    if (_positionEither.isLeft()) {
      return _positionEither;
    }

    const position = _positionEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, item, position });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ListItem.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ListItem> {
    return ListItem.$propertiesFromRdf(parameters).map(
      (properties) => new ListItem(properties),
    );
  }

  export const $properties = {
    ...IntangibleStatic.$properties,
    item: { identifier: dataFactory.namedNode("http://schema.org/item") },
    position: {
      identifier: dataFactory.namedNode("http://schema.org/position"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ListItem.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ListItem.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ListItem.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("listItem");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "listItem");
    triples.push(
      ...IntangibleStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Item`),
      predicate: ListItem.$properties.item["identifier"],
      subject,
    });
    triples.push(
      ...ThingStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Item`),
        variablePrefix: `${variablePrefix}Item`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Position`),
      predicate: ListItem.$properties.position["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("listItem");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "listItem");
    for (const pattern of IntangibleStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Item`),
            predicate: ListItem.$properties.item["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...ThingStubStatic.$sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Item`),
        variablePrefix: `${variablePrefix}Item`,
      }),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Position`),
                predicate: ListItem.$properties.position["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          { patterns: [{ patterns: [], type: "group" }], type: "union" },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ListItemStub extends IntangibleStub {
  override readonly $type = "ListItemStub";
  readonly item: ThingStub;
  readonly position: purify.Maybe<number | string>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly item: ThingStub;
      readonly position?: number | purify.Maybe<number | string> | string;
    } & ConstructorParameters<typeof IntangibleStub>[0],
  ) {
    super(parameters);
    this.item = parameters.item;
    if (purify.Maybe.isMaybe(parameters.position)) {
      this.position = parameters.position;
    } else if (typeof parameters.position === "number") {
      this.position = purify.Maybe.of(parameters.position);
    } else if (typeof parameters.position === "string") {
      this.position = purify.Maybe.of(parameters.position);
    } else if (typeof parameters.position === "undefined") {
      this.position = purify.Maybe.empty();
    } else {
      this.position = parameters.position satisfies never;
    }
  }

  override get $identifier(): ListItemStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: ListItemStub): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => left.$equals(right))(this.item, other.item).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "item",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(
            left,
            right,
            (left: number | string, right: number | string) => {
              if (typeof left === "number" && typeof right === "number") {
                return $strictEquals(left, right);
              }
              if (typeof left === "string" && typeof right === "string") {
                return $strictEquals(left, right);
              }

              return purify.Left({
                left,
                right,
                propertyName: "type",
                propertyValuesUnequal: {
                  left: typeof left,
                  right: typeof right,
                  type: "BooleanEquals" as const,
                },
                type: "Property" as const,
              });
            },
          ))(this.position, other.position).mapLeft(
          (propertyValuesUnequal) => ({
            left: this,
            right: other,
            propertyName: "position",
            propertyValuesUnequal,
            type: "Property" as const,
          }),
        ),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.item.$hash(_hasher);
    this.position.ifJust((_value0) => {
      switch (typeof _value0) {
        case "number": {
          _hasher.update(_value0.toString());
          break;
        }
        case "string": {
          _hasher.update(_value0);
          break;
        }
        default:
          _value0 satisfies never;
          throw new Error("unrecognized type");
      }
    });
    return _hasher;
  }

  override $toJson(): ListItemStub.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        item: this.item.$toJson(),
        position: this.position
          .map((_item) => (typeof _item === "string" ? _item : _item))
          .extract(),
      } satisfies ListItemStub.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/ListItem"),
      );
    }

    _resource.add(
      ListItem.$properties.item["identifier"],
      this.item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
    );
    _resource.add(
      ListItem.$properties.position["identifier"],
      this.position.map((_value) =>
        typeof _value === "string" ? _value : _value,
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ListItemStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/ListItem",
  );
  export type $Identifier = IntangibleStubStatic.$Identifier;
  export const $Identifier = IntangibleStubStatic.$Identifier;
  export type $Json = {
    readonly item: ThingStubStatic.$Json;
    readonly position: (number | string) | undefined;
  } & IntangibleStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      item: ThingStub;
      position: purify.Maybe<number | string>;
    } & $UnwrapR<ReturnType<typeof IntangibleStubStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const item = ThingStubStatic.$fromJson(_jsonObject["item"]).unsafeCoerce();
    const position = purify.Maybe.fromNullable(_jsonObject["position"]).map(
      (_item) => (typeof _item === "string" ? _item : _item),
    );
    return purify.Either.of({ ...$super0, $identifier, item, position });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ListItemStub> {
    return $propertiesFromJson(json).map(
      (properties) => new ListItemStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        IntangibleStubStatic.$jsonUiSchema({ scopePrefix }),
        ThingStubStatic.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/item`,
        }),
        { scope: `${scopePrefix}/properties/position`, type: "Control" },
      ],
      label: "ListItemStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ListItemStub"),
        item: ThingStubStatic.$jsonZodSchema(),
        position: zod.union([zod.number(), zod.string()]).optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      item: ThingStub;
      position: purify.Maybe<number | string>;
    } & $UnwrapR<ReturnType<typeof IntangibleStubStatic.$propertiesFromRdf>>
  > {
    const $super0Either = IntangibleStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/ListItem)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ListItemStub.$Identifier = _resource.identifier;
    const _itemEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      ThingStub
    > = _resource
      .values($properties.item["identifier"], { unique: true })
      .head()
      .chain((value) => value.toResource())
      .chain((_resource) =>
        ThingStubStatic.$fromRdf({
          ..._context,
          ignoreRdfType: true,
          languageIn: _languageIn,
          resource: _resource,
        }),
      );
    if (_itemEither.isLeft()) {
      return _itemEither;
    }

    const item = _itemEither.unsafeCoerce();
    const _positionEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<number | string>
    > = purify.Either.of(
      (
        _resource
          .values($properties.position["identifier"], { unique: true })
          .head()
          .chain((_value) => _value.toNumber()) as purify.Either<
          rdfjsResource.Resource.ValueError,
          number | string
        >
      )
        .altLazy(
          () =>
            _resource
              .values($properties.position["identifier"], { unique: true })
              .head()
              .chain((_value) => _value.toString()) as purify.Either<
              rdfjsResource.Resource.ValueError,
              number | string
            >,
        )
        .toMaybe(),
    );
    if (_positionEither.isLeft()) {
      return _positionEither;
    }

    const position = _positionEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, item, position });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ListItemStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ListItemStub> {
    return ListItemStub.$propertiesFromRdf(parameters).map(
      (properties) => new ListItemStub(properties),
    );
  }

  export const $properties = {
    ...IntangibleStubStatic.$properties,
    item: { identifier: dataFactory.namedNode("http://schema.org/item") },
    position: {
      identifier: dataFactory.namedNode("http://schema.org/position"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ListItemStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ListItemStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ListItemStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("listItemStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "listItemStub");
    triples.push(
      ...IntangibleStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Item`),
      predicate: ListItem.$properties.item["identifier"],
      subject,
    });
    triples.push(
      ...ThingStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Item`),
        variablePrefix: `${variablePrefix}Item`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Position`),
      predicate: ListItem.$properties.position["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("listItemStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "listItemStub");
    for (const pattern of IntangibleStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        triples: [
          {
            object: dataFactory.variable!(`${variablePrefix}Item`),
            predicate: ListItem.$properties.item["identifier"],
            subject,
          },
        ],
        type: "bgp",
      },
      ...ThingStubStatic.$sparqlWherePatterns({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}Item`),
        variablePrefix: `${variablePrefix}Item`,
      }),
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Position`),
                predicate: ListItem.$properties.position["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          { patterns: [{ patterns: [], type: "group" }], type: "union" },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ItemList extends Intangible {
  override readonly $type = "ItemList";
  itemListElements: ListItemStub[];

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly itemListElements?: readonly ListItemStub[];
    } & ConstructorParameters<typeof Intangible>[0],
  ) {
    super(parameters);
    if (typeof parameters.itemListElements === "undefined") {
      this.itemListElements = [];
    } else if (typeof parameters.itemListElements === "object") {
      this.itemListElements = parameters.itemListElements.concat();
    } else {
      this.itemListElements = parameters.itemListElements satisfies never;
    }
  }

  override get $identifier(): ItemList.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: ItemList): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.itemListElements,
          other.itemListElements,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "itemListElements",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.itemListElements) {
      _item0.$hash(_hasher);
    }

    return _hasher;
  }

  override $toJson(): ItemList.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        itemListElements: this.itemListElements.map((_item) => _item.$toJson()),
      } satisfies ItemList.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/ItemList"),
      );
    }

    _resource.add(
      ItemListStub.$properties.itemListElements["identifier"],
      this.itemListElements.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ItemList {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/ItemList",
  );
  export type $Identifier = IntangibleStatic.$Identifier;
  export const $Identifier = IntangibleStatic.$Identifier;
  export type $Json = {
    readonly itemListElements: readonly ListItemStub.$Json[];
  } & IntangibleStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      itemListElements: ListItemStub[];
    } & $UnwrapR<ReturnType<typeof IntangibleStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const itemListElements = _jsonObject["itemListElements"].map((_item) =>
      ListItemStub.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ...$super0, $identifier, itemListElements });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ItemList> {
    return $propertiesFromJson(json).map(
      (properties) => new ItemList(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        IntangibleStatic.$jsonUiSchema({ scopePrefix }),
        ListItemStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/itemListElements`,
        }),
      ],
      label: "ItemList",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ItemList"),
        itemListElements: ListItemStub.$jsonZodSchema()
          .array()
          .default(() => []),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      itemListElements: ListItemStub[];
    } & $UnwrapR<ReturnType<typeof IntangibleStatic.$propertiesFromRdf>>
  > {
    const $super0Either = IntangibleStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/ItemList)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ItemList.$Identifier = _resource.identifier;
    const _itemListElementsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      ListItemStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.itemListElements["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              ListItemStub.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_itemListElementsEither.isLeft()) {
      return _itemListElementsEither;
    }

    const itemListElements = _itemListElementsEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, itemListElements });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ItemList.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ItemList> {
    return ItemList.$propertiesFromRdf(parameters).map(
      (properties) => new ItemList(properties),
    );
  }

  export const $properties = {
    ...IntangibleStatic.$properties,
    itemListElements: {
      identifier: dataFactory.namedNode("http://schema.org/itemListElement"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ItemList.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ItemList.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ItemList.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("itemList");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "itemList");
    triples.push(
      ...IntangibleStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ItemListElements`),
      predicate: ItemListStub.$properties.itemListElements["identifier"],
      subject,
    });
    triples.push(
      ...ListItemStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ItemListElements`),
        variablePrefix: `${variablePrefix}ItemListElements`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("itemList");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "itemList");
    for (const pattern of IntangibleStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ItemListElements`,
                ),
                predicate:
                  ItemListStub.$properties.itemListElements["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...ListItemStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}ItemListElements`),
            variablePrefix: `${variablePrefix}ItemListElements`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ItemListStub extends IntangibleStub {
  override readonly $type = "ItemListStub";
  itemListElements: ListItemStub[];

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly itemListElements?: readonly ListItemStub[];
    } & ConstructorParameters<typeof IntangibleStub>[0],
  ) {
    super(parameters);
    if (typeof parameters.itemListElements === "undefined") {
      this.itemListElements = [];
    } else if (typeof parameters.itemListElements === "object") {
      this.itemListElements = parameters.itemListElements.concat();
    } else {
      this.itemListElements = parameters.itemListElements satisfies never;
    }
  }

  override get $identifier(): ItemListStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: ItemListStub): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.itemListElements,
          other.itemListElements,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "itemListElements",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    for (const _item0 of this.itemListElements) {
      _item0.$hash(_hasher);
    }

    return _hasher;
  }

  override $toJson(): ItemListStub.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        itemListElements: this.itemListElements.map((_item) => _item.$toJson()),
      } satisfies ItemListStub.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/ItemList"),
      );
    }

    _resource.add(
      ItemListStub.$properties.itemListElements["identifier"],
      this.itemListElements.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ItemListStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/ItemList",
  );
  export type $Identifier = IntangibleStubStatic.$Identifier;
  export const $Identifier = IntangibleStubStatic.$Identifier;
  export type $Json = {
    readonly itemListElements: readonly ListItemStub.$Json[];
  } & IntangibleStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      itemListElements: ListItemStub[];
    } & $UnwrapR<ReturnType<typeof IntangibleStubStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const itemListElements = _jsonObject["itemListElements"].map((_item) =>
      ListItemStub.$fromJson(_item).unsafeCoerce(),
    );
    return purify.Either.of({ ...$super0, $identifier, itemListElements });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ItemListStub> {
    return $propertiesFromJson(json).map(
      (properties) => new ItemListStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        IntangibleStubStatic.$jsonUiSchema({ scopePrefix }),
        ListItemStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/itemListElements`,
        }),
      ],
      label: "ItemListStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ItemListStub"),
        itemListElements: ListItemStub.$jsonZodSchema()
          .array()
          .default(() => []),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      itemListElements: ListItemStub[];
    } & $UnwrapR<ReturnType<typeof IntangibleStubStatic.$propertiesFromRdf>>
  > {
    const $super0Either = IntangibleStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/ItemList)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ItemListStub.$Identifier = _resource.identifier;
    const _itemListElementsEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      ListItemStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.itemListElements["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              ListItemStub.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_itemListElementsEither.isLeft()) {
      return _itemListElementsEither;
    }

    const itemListElements = _itemListElementsEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, itemListElements });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ItemListStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ItemListStub> {
    return ItemListStub.$propertiesFromRdf(parameters).map(
      (properties) => new ItemListStub(properties),
    );
  }

  export const $properties = {
    ...IntangibleStubStatic.$properties,
    itemListElements: {
      identifier: dataFactory.namedNode("http://schema.org/itemListElement"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ItemListStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ItemListStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ItemListStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("itemListStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "itemListStub");
    triples.push(
      ...IntangibleStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ItemListElements`),
      predicate: ItemListStub.$properties.itemListElements["identifier"],
      subject,
    });
    triples.push(
      ...ListItemStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ItemListElements`),
        variablePrefix: `${variablePrefix}ItemListElements`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("itemListStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "itemListStub");
    for (const pattern of IntangibleStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ItemListElements`,
                ),
                predicate:
                  ItemListStub.$properties.itemListElements["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...ListItemStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}ItemListElements`),
            variablePrefix: `${variablePrefix}ItemListElements`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class Invoice extends Intangible {
  override readonly $type = "Invoice";
  readonly category: purify.Maybe<string>;
  readonly provider: purify.Maybe<AgentStub>;
  readonly referencesOrders: readonly OrderStub[];
  readonly totalPaymentDue: purify.Maybe<MonetaryAmountStub>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly category?: purify.Maybe<string> | string;
      readonly provider?: AgentStub | purify.Maybe<AgentStub>;
      readonly referencesOrders?: readonly OrderStub[];
      readonly totalPaymentDue?:
        | MonetaryAmountStub
        | purify.Maybe<MonetaryAmountStub>;
    } & ConstructorParameters<typeof Intangible>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.category)) {
      this.category = parameters.category;
    } else if (typeof parameters.category === "string") {
      this.category = purify.Maybe.of(parameters.category);
    } else if (typeof parameters.category === "undefined") {
      this.category = purify.Maybe.empty();
    } else {
      this.category = parameters.category satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.provider)) {
      this.provider = parameters.provider;
    } else if (typeof parameters.provider === "object") {
      this.provider = purify.Maybe.of(parameters.provider);
    } else if (typeof parameters.provider === "undefined") {
      this.provider = purify.Maybe.empty();
    } else {
      this.provider = parameters.provider satisfies never;
    }

    if (typeof parameters.referencesOrders === "undefined") {
      this.referencesOrders = [];
    } else if (typeof parameters.referencesOrders === "object") {
      this.referencesOrders = parameters.referencesOrders;
    } else {
      this.referencesOrders = parameters.referencesOrders satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.totalPaymentDue)) {
      this.totalPaymentDue = parameters.totalPaymentDue;
    } else if (
      typeof parameters.totalPaymentDue === "object" &&
      parameters.totalPaymentDue instanceof MonetaryAmountStub
    ) {
      this.totalPaymentDue = purify.Maybe.of(parameters.totalPaymentDue);
    } else if (typeof parameters.totalPaymentDue === "undefined") {
      this.totalPaymentDue = purify.Maybe.empty();
    } else {
      this.totalPaymentDue = parameters.totalPaymentDue satisfies never;
    }
  }

  override get $identifier(): Invoice.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: Invoice): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.category,
          other.category,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "category",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, AgentStub.$equals))(
          this.provider,
          other.provider,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "provider",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $arrayEquals(left, right, (left, right) => left.$equals(right)))(
          this.referencesOrders,
          other.referencesOrders,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "referencesOrders",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) =>
          $maybeEquals(left, right, (left, right) => left.$equals(right)))(
          this.totalPaymentDue,
          other.totalPaymentDue,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "totalPaymentDue",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.category.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    this.provider.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    for (const _item0 of this.referencesOrders) {
      _item0.$hash(_hasher);
    }

    this.totalPaymentDue.ifJust((_value0) => {
      _value0.$hash(_hasher);
    });
    return _hasher;
  }

  override $toJson(): Invoice.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        category: this.category.map((_item) => _item).extract(),
        provider: this.provider.map((_item) => _item.$toJson()).extract(),
        referencesOrders: this.referencesOrders.map((_item) => _item.$toJson()),
        totalPaymentDue: this.totalPaymentDue
          .map((_item) => _item.$toJson())
          .extract(),
      } satisfies Invoice.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Invoice"),
      );
    }

    _resource.add(Invoice.$properties.category["identifier"], this.category);
    _resource.add(
      Invoice.$properties.provider["identifier"],
      this.provider.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      Invoice.$properties.referencesOrders["identifier"],
      this.referencesOrders.map((_item) =>
        _item.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    _resource.add(
      Invoice.$properties.totalPaymentDue["identifier"],
      this.totalPaymentDue.map((_value) =>
        _value.$toRdf({ mutateGraph: mutateGraph, resourceSet: resourceSet }),
      ),
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace Invoice {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Invoice",
  );
  export type $Identifier = IntangibleStatic.$Identifier;
  export const $Identifier = IntangibleStatic.$Identifier;
  export type $Json = {
    readonly category: string | undefined;
    readonly provider:
      | (OrganizationStubStatic.$Json | PersonStub.$Json)
      | undefined;
    readonly referencesOrders: readonly OrderStub.$Json[];
    readonly totalPaymentDue: MonetaryAmountStub.$Json | undefined;
  } & IntangibleStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      category: purify.Maybe<string>;
      provider: purify.Maybe<AgentStub>;
      referencesOrders: readonly OrderStub[];
      totalPaymentDue: purify.Maybe<MonetaryAmountStub>;
    } & $UnwrapR<ReturnType<typeof IntangibleStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const category = purify.Maybe.fromNullable(_jsonObject["category"]);
    const provider = purify.Maybe.fromNullable(_jsonObject["provider"]).map(
      (_item) => AgentStub.$fromJson(_item).unsafeCoerce(),
    );
    const referencesOrders = _jsonObject["referencesOrders"].map((_item) =>
      OrderStub.$fromJson(_item).unsafeCoerce(),
    );
    const totalPaymentDue = purify.Maybe.fromNullable(
      _jsonObject["totalPaymentDue"],
    ).map((_item) => MonetaryAmountStub.$fromJson(_item).unsafeCoerce());
    return purify.Either.of({
      ...$super0,
      $identifier,
      category,
      provider,
      referencesOrders,
      totalPaymentDue,
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, Invoice> {
    return $propertiesFromJson(json).map(
      (properties) => new Invoice(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        IntangibleStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/category`, type: "Control" },
        { scope: `${scopePrefix}/properties/provider`, type: "Control" },
        OrderStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/referencesOrders`,
        }),
        MonetaryAmountStub.$jsonUiSchema({
          scopePrefix: `${scopePrefix}/properties/totalPaymentDue`,
        }),
      ],
      label: "Invoice",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("Invoice"),
        category: zod.string().optional(),
        provider: AgentStub.$jsonZodSchema().optional(),
        referencesOrders: OrderStub.$jsonZodSchema()
          .array()
          .default(() => []),
        totalPaymentDue: MonetaryAmountStub.$jsonZodSchema().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      category: purify.Maybe<string>;
      provider: purify.Maybe<AgentStub>;
      referencesOrders: readonly OrderStub[];
      totalPaymentDue: purify.Maybe<MonetaryAmountStub>;
    } & $UnwrapR<ReturnType<typeof IntangibleStatic.$propertiesFromRdf>>
  > {
    const $super0Either = IntangibleStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Invoice)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: Invoice.$Identifier = _resource.identifier;
    const _categoryEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.category["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_categoryEither.isLeft()) {
      return _categoryEither;
    }

    const category = _categoryEither.unsafeCoerce();
    const _providerEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<AgentStub>
    > = purify.Either.of(
      _resource
        .values($properties.provider["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          AgentStub.$fromRdf({
            ..._context,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_providerEither.isLeft()) {
      return _providerEither;
    }

    const provider = _providerEither.unsafeCoerce();
    const _referencesOrdersEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      readonly OrderStub[]
    > = purify.Either.of([
      ..._resource
        .values($properties.referencesOrders["identifier"], { unique: true })
        .flatMap((_item) =>
          _item
            .toValues()
            .head()
            .chain((value) => value.toResource())
            .chain((_resource) =>
              OrderStub.$fromRdf({
                ..._context,
                ignoreRdfType: true,
                languageIn: _languageIn,
                resource: _resource,
              }),
            )
            .toMaybe()
            .toList(),
        ),
    ]);
    if (_referencesOrdersEither.isLeft()) {
      return _referencesOrdersEither;
    }

    const referencesOrders = _referencesOrdersEither.unsafeCoerce();
    const _totalPaymentDueEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<MonetaryAmountStub>
    > = purify.Either.of(
      _resource
        .values($properties.totalPaymentDue["identifier"], { unique: true })
        .head()
        .chain((value) => value.toResource())
        .chain((_resource) =>
          MonetaryAmountStub.$fromRdf({
            ..._context,
            ignoreRdfType: true,
            languageIn: _languageIn,
            resource: _resource,
          }),
        )
        .toMaybe(),
    );
    if (_totalPaymentDueEither.isLeft()) {
      return _totalPaymentDueEither;
    }

    const totalPaymentDue = _totalPaymentDueEither.unsafeCoerce();
    return purify.Either.of({
      ...$super0,
      $identifier,
      category,
      provider,
      referencesOrders,
      totalPaymentDue,
    });
  }

  export function $fromRdf(
    parameters: Parameters<typeof Invoice.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, Invoice> {
    return Invoice.$propertiesFromRdf(parameters).map(
      (properties) => new Invoice(properties),
    );
  }

  export const $properties = {
    ...IntangibleStatic.$properties,
    category: {
      identifier: dataFactory.namedNode("http://schema.org/category"),
    },
    provider: {
      identifier: dataFactory.namedNode("http://schema.org/provider"),
    },
    referencesOrders: {
      identifier: dataFactory.namedNode("http://schema.org/referencesOrder"),
    },
    totalPaymentDue: {
      identifier: dataFactory.namedNode("http://schema.org/totalPaymentDue"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        Invoice.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        Invoice.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      Invoice.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("invoice");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "invoice");
    triples.push(
      ...IntangibleStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Category`),
      predicate: Invoice.$properties.category["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}Provider`),
      predicate: Invoice.$properties.provider["identifier"],
      subject,
    });
    triples.push(
      ...AgentStub.$sparqlConstructTemplateTriples({
        subject: dataFactory.variable!(`${variablePrefix}Provider`),
        variablePrefix: `${variablePrefix}Provider`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}ReferencesOrders`),
      predicate: Invoice.$properties.referencesOrders["identifier"],
      subject,
    });
    triples.push(
      ...OrderStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}ReferencesOrders`),
        variablePrefix: `${variablePrefix}ReferencesOrders`,
      }),
    );
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}TotalPaymentDue`),
      predicate: Invoice.$properties.totalPaymentDue["identifier"],
      subject,
    });
    triples.push(
      ...MonetaryAmountStub.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject: dataFactory.variable!(`${variablePrefix}TotalPaymentDue`),
        variablePrefix: `${variablePrefix}TotalPaymentDue`,
      }),
    );
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("invoice");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "invoice");
    for (const pattern of IntangibleStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Category`),
                predicate: Invoice.$properties.category["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}Provider`),
                predicate: Invoice.$properties.provider["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...AgentStub.$sparqlWherePatterns({
            subject: dataFactory.variable!(`${variablePrefix}Provider`),
            variablePrefix: `${variablePrefix}Provider`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}ReferencesOrders`,
                ),
                predicate: Invoice.$properties.referencesOrders["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...OrderStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}ReferencesOrders`),
            variablePrefix: `${variablePrefix}ReferencesOrders`,
          }),
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(
                  `${variablePrefix}TotalPaymentDue`,
                ),
                predicate: Invoice.$properties.totalPaymentDue["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
          ...MonetaryAmountStub.$sparqlWherePatterns({
            ignoreRdfType: true,
            subject: dataFactory.variable!(`${variablePrefix}TotalPaymentDue`),
            variablePrefix: `${variablePrefix}TotalPaymentDue`,
          }),
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class InvoiceStub extends IntangibleStub {
  override readonly $type = "InvoiceStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof IntangibleStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): InvoiceStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Invoice"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace InvoiceStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Invoice",
  );
  export type $Identifier = IntangibleStubStatic.$Identifier;
  export const $Identifier = IntangibleStubStatic.$Identifier;
  export type $Json = IntangibleStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = IntangibleStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, InvoiceStub> {
    return $propertiesFromJson(json).map(
      (properties) => new InvoiceStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [IntangibleStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "InvoiceStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return IntangibleStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("InvoiceStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof IntangibleStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = IntangibleStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Invoice)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: InvoiceStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof InvoiceStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, InvoiceStub> {
    return InvoiceStub.$propertiesFromRdf(parameters).map(
      (properties) => new InvoiceStub(properties),
    );
  }

  export const $properties = { ...IntangibleStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        InvoiceStub.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        InvoiceStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      InvoiceStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("invoiceStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "invoiceStub");
    triples.push(
      ...IntangibleStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("invoiceStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "invoiceStub");
    for (const pattern of IntangibleStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ImageObject extends MediaObject {
  override readonly $type = "ImageObject";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof MediaObject>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): ImageObject.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/ImageObject"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ImageObject {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/ImageObject",
  );
  export type $Identifier = MediaObjectStatic.$Identifier;
  export const $Identifier = MediaObjectStatic.$Identifier;
  export type $Json = MediaObjectStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof MediaObjectStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = MediaObjectStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ImageObject> {
    return $propertiesFromJson(json).map(
      (properties) => new ImageObject(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [MediaObjectStatic.$jsonUiSchema({ scopePrefix })],
      label: "ImageObject",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return MediaObjectStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ImageObject"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof MediaObjectStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = MediaObjectStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/ImageObject)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ImageObject.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ImageObject.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ImageObject> {
    return ImageObject.$propertiesFromRdf(parameters).map(
      (properties) => new ImageObject(properties),
    );
  }

  export const $properties = { ...MediaObjectStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ImageObject.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ImageObject.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ImageObject.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("imageObject");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "imageObject");
    triples.push(
      ...MediaObjectStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("imageObject");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "imageObject");
    for (const pattern of MediaObjectStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class ImageObjectStub extends MediaObjectStub {
  override readonly $type = "ImageObjectStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof MediaObjectStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): ImageObjectStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/ImageObject"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace ImageObjectStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/ImageObject",
  );
  export type $Identifier = MediaObjectStubStatic.$Identifier;
  export const $Identifier = MediaObjectStubStatic.$Identifier;
  export type $Json = MediaObjectStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof MediaObjectStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      MediaObjectStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, ImageObjectStub> {
    return $propertiesFromJson(json).map(
      (properties) => new ImageObjectStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [MediaObjectStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "ImageObjectStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return MediaObjectStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("ImageObjectStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof MediaObjectStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = MediaObjectStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/ImageObject)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: ImageObjectStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof ImageObjectStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, ImageObjectStub> {
    return ImageObjectStub.$propertiesFromRdf(parameters).map(
      (properties) => new ImageObjectStub(properties),
    );
  }

  export const $properties = { ...MediaObjectStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        ImageObjectStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        ImageObjectStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      ImageObjectStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("imageObjectStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "imageObjectStub");
    triples.push(
      ...MediaObjectStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("imageObjectStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "imageObjectStub");
    for (const pattern of MediaObjectStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class EventStub extends ThingStub {
  override readonly $type:
    | "EventStub"
    | "BroadcastEventStub"
    | "PublicationEventStub" = "EventStub";
  readonly startDate: purify.Maybe<Date>;
  superEvent: purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly startDate?: Date | purify.Maybe<Date>;
      readonly superEvent?:
        | (rdfjs.BlankNode | rdfjs.NamedNode)
        | purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode>
        | string;
    } & ConstructorParameters<typeof ThingStub>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.startDate)) {
      this.startDate = parameters.startDate;
    } else if (
      typeof parameters.startDate === "object" &&
      parameters.startDate instanceof Date
    ) {
      this.startDate = purify.Maybe.of(parameters.startDate);
    } else if (typeof parameters.startDate === "undefined") {
      this.startDate = purify.Maybe.empty();
    } else {
      this.startDate = parameters.startDate satisfies never;
    }

    if (purify.Maybe.isMaybe(parameters.superEvent)) {
      this.superEvent = parameters.superEvent;
    } else if (typeof parameters.superEvent === "object") {
      this.superEvent = purify.Maybe.of(parameters.superEvent);
    } else if (typeof parameters.superEvent === "string") {
      this.superEvent = purify.Maybe.of(
        dataFactory.namedNode(parameters.superEvent),
      );
    } else if (typeof parameters.superEvent === "undefined") {
      this.superEvent = purify.Maybe.empty();
    } else {
      this.superEvent = parameters.superEvent satisfies never;
    }
  }

  override get $identifier(): EventStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: EventStub): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $dateEquals))(
          this.startDate,
          other.startDate,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "startDate",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      )
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $booleanEquals))(
          this.superEvent,
          other.superEvent,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "superEvent",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.startDate.ifJust((_value0) => {
      _hasher.update(_value0.toISOString());
    });
    this.superEvent.ifJust((_value0) => {
      _hasher.update(_value0.termType);
      _hasher.update(_value0.value);
    });
    return _hasher;
  }

  override $toJson(): EventStubStatic.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        startDate: this.startDate.map((_item) => _item.toISOString()).extract(),
        superEvent: this.superEvent
          .map((_item) =>
            _item.termType === "BlankNode"
              ? { "@id": `_:${_item.value}` }
              : { "@id": _item.value },
          )
          .extract(),
      } satisfies EventStubStatic.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Event"),
      );
    }

    _resource.add(
      EventStubStatic.$properties.startDate["identifier"],
      this.startDate.map((_value) =>
        rdfLiteral.toRdf(_value, {
          dataFactory,
          datatype: $RdfVocabularies.xsd.dateTime,
        }),
      ),
    );
    _resource.add(
      EventStubStatic.$properties.superEvent["identifier"],
      this.superEvent,
    );
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace EventStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Event",
  );
  export type $Identifier = ThingStubStatic.$Identifier;
  export const $Identifier = ThingStubStatic.$Identifier;
  export type $Json = {
    readonly startDate: string | undefined;
    readonly superEvent: { readonly "@id": string } | undefined;
  } & ThingStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      startDate: purify.Maybe<Date>;
      superEvent: purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode>;
    } & $UnwrapR<ReturnType<typeof ThingStubStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const startDate = purify.Maybe.fromNullable(_jsonObject["startDate"]).map(
      (_item) => new Date(_item),
    );
    const superEvent = purify.Maybe.fromNullable(_jsonObject["superEvent"]).map(
      (_item) =>
        _item["@id"].startsWith("_:")
          ? dataFactory.blankNode(_item["@id"].substring(2))
          : dataFactory.namedNode(_item["@id"]),
    );
    return purify.Either.of({ ...$super0, $identifier, startDate, superEvent });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, EventStub> {
    return (
      PublicationEventStubStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        EventStub
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map((properties) => new EventStub(properties)),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ThingStubStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/startDate`, type: "Control" },
        { scope: `${scopePrefix}/properties/superEvent`, type: "Control" },
      ],
      label: "EventStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum([
          "EventStub",
          "BroadcastEventStub",
          "PublicationEventStub",
        ]),
        startDate: zod.string().datetime().optional(),
        superEvent: zod.object({ "@id": zod.string().min(1) }).optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      startDate: purify.Maybe<Date>;
      superEvent: purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode>;
    } & $UnwrapR<ReturnType<typeof ThingStubStatic.$propertiesFromRdf>>
  > {
    const $super0Either = ThingStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Event)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: EventStubStatic.$Identifier = _resource.identifier;
    const _startDateEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<Date>
    > = purify.Either.of(
      _resource
        .values($properties.startDate["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toDate())
        .toMaybe(),
    );
    if (_startDateEither.isLeft()) {
      return _startDateEither;
    }

    const startDate = _startDateEither.unsafeCoerce();
    const _superEventEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<rdfjs.BlankNode | rdfjs.NamedNode>
    > = purify.Either.of(
      _resource
        .values($properties.superEvent["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toIdentifier())
        .toMaybe(),
    );
    if (_superEventEither.isLeft()) {
      return _superEventEither;
    }

    const superEvent = _superEventEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, startDate, superEvent });
  }

  export function $fromRdf(
    parameters: Parameters<typeof EventStubStatic.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, EventStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      PublicationEventStubStatic.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        EventStub
      >
    ).altLazy(() =>
      EventStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new EventStub(properties),
      ),
    );
  }

  export const $properties = {
    ...ThingStubStatic.$properties,
    startDate: {
      identifier: dataFactory.namedNode("http://schema.org/startDate"),
    },
    superEvent: {
      identifier: dataFactory.namedNode("http://schema.org/superEvent"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        EventStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        EventStubStatic.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      EventStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("eventStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "eventStub");
    triples.push(
      ...ThingStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}StartDate`),
      predicate: EventStubStatic.$properties.startDate["identifier"],
      subject,
    });
    triples.push({
      object: dataFactory.variable!(`${variablePrefix}SuperEvent`),
      predicate: EventStubStatic.$properties.superEvent["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("eventStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "eventStub");
    for (const pattern of ThingStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}StartDate`),
                predicate: EventStubStatic.$properties.startDate["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}SuperEvent`),
                predicate: EventStubStatic.$properties.superEvent["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class PublicationEventStub extends EventStub {
  override readonly $type: "PublicationEventStub" | "BroadcastEventStub" =
    "PublicationEventStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof EventStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): PublicationEventStubStatic.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/PublicationEvent"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PublicationEventStubStatic {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/PublicationEvent",
  );
  export type $Identifier = EventStubStatic.$Identifier;
  export const $Identifier = EventStubStatic.$Identifier;
  export type $Json = EventStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof EventStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = EventStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PublicationEventStub> {
    return (
      BroadcastEventStub.$fromJson(json) as purify.Either<
        zod.ZodError,
        PublicationEventStub
      >
    ).altLazy(() =>
      $propertiesFromJson(json).map(
        (properties) => new PublicationEventStub(properties),
      ),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [EventStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "PublicationEventStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return EventStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.enum(["PublicationEventStub", "BroadcastEventStub"]),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof EventStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = EventStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/PublicationEvent)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: PublicationEventStubStatic.$Identifier =
      _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<
      typeof PublicationEventStubStatic.$propertiesFromRdf
    >[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PublicationEventStub> {
    const { ignoreRdfType: _ignoreRdfType, ...otherParameters } = parameters;
    return (
      BroadcastEventStub.$fromRdf(otherParameters) as purify.Either<
        rdfjsResource.Resource.ValueError,
        PublicationEventStub
      >
    ).altLazy(() =>
      PublicationEventStubStatic.$propertiesFromRdf(parameters).map(
        (properties) => new PublicationEventStub(properties),
      ),
    );
  }

  export const $properties = { ...EventStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PublicationEventStubStatic.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PublicationEventStubStatic.$sparqlWherePatterns({
          ignoreRdfType,
          subject,
        }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PublicationEventStubStatic.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("publicationEventStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "publicationEventStub");
    triples.push(
      ...EventStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("publicationEventStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable"
        ? subject.value
        : "publicationEventStub");
    for (const pattern of EventStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class BroadcastEvent extends PublicationEvent {
  override readonly $type = "BroadcastEvent";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof PublicationEvent>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): BroadcastEvent.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/BroadcastEvent"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace BroadcastEvent {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/BroadcastEvent",
  );
  export type $Identifier = PublicationEventStatic.$Identifier;
  export const $Identifier = PublicationEventStatic.$Identifier;
  export type $Json = PublicationEventStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof PublicationEventStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      PublicationEventStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BroadcastEvent> {
    return $propertiesFromJson(json).map(
      (properties) => new BroadcastEvent(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [PublicationEventStatic.$jsonUiSchema({ scopePrefix })],
      label: "BroadcastEvent",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return PublicationEventStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("BroadcastEvent"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof PublicationEventStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = PublicationEventStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/BroadcastEvent)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: BroadcastEvent.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof BroadcastEvent.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, BroadcastEvent> {
    return BroadcastEvent.$propertiesFromRdf(parameters).map(
      (properties) => new BroadcastEvent(properties),
    );
  }

  export const $properties = { ...PublicationEventStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BroadcastEvent.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BroadcastEvent.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BroadcastEvent.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("broadcastEvent");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "broadcastEvent");
    triples.push(
      ...PublicationEventStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("broadcastEvent");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "broadcastEvent");
    for (const pattern of PublicationEventStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class BroadcastEventStub extends PublicationEventStub {
  override readonly $type = "BroadcastEventStub";

  // biome-ignore lint/complexity/noUselessConstructor: Always have a constructor
  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
    } & ConstructorParameters<typeof PublicationEventStub>[0],
  ) {
    super(parameters);
  }

  override get $identifier(): BroadcastEventStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/BroadcastEvent"),
      );
    }

    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace BroadcastEventStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/BroadcastEvent",
  );
  export type $Identifier = PublicationEventStubStatic.$Identifier;
  export const $Identifier = PublicationEventStubStatic.$Identifier;
  export type $Json = PublicationEventStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof PublicationEventStubStatic.$propertiesFromJson>
    >
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either =
      PublicationEventStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, BroadcastEventStub> {
    return $propertiesFromJson(json).map(
      (properties) => new BroadcastEventStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [PublicationEventStubStatic.$jsonUiSchema({ scopePrefix })],
      label: "BroadcastEventStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return PublicationEventStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("BroadcastEventStub"),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    { $identifier: rdfjs.BlankNode | rdfjs.NamedNode } & $UnwrapR<
      ReturnType<typeof PublicationEventStubStatic.$propertiesFromRdf>
    >
  > {
    const $super0Either = PublicationEventStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/BroadcastEvent)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: BroadcastEventStub.$Identifier = _resource.identifier;
    return purify.Either.of({ ...$super0, $identifier });
  }

  export function $fromRdf(
    parameters: Parameters<typeof BroadcastEventStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, BroadcastEventStub> {
    return BroadcastEventStub.$propertiesFromRdf(parameters).map(
      (properties) => new BroadcastEventStub(properties),
    );
  }

  export const $properties = { ...PublicationEventStubStatic.$properties };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        BroadcastEventStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        BroadcastEventStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      BroadcastEventStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject =
      parameters?.subject ?? dataFactory.variable!("broadcastEventStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "broadcastEventStub");
    triples.push(
      ...PublicationEventStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject =
      parameters?.subject ?? dataFactory.variable!("broadcastEventStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "broadcastEventStub");
    for (const pattern of PublicationEventStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export class PersonStub extends ThingStub {
  override readonly $type = "PersonStub";
  readonly jobTitle: purify.Maybe<string>;

  constructor(
    parameters: {
      readonly $identifier?: (rdfjs.BlankNode | rdfjs.NamedNode) | string;
      readonly jobTitle?: purify.Maybe<string> | string;
    } & ConstructorParameters<typeof ThingStub>[0],
  ) {
    super(parameters);
    if (purify.Maybe.isMaybe(parameters.jobTitle)) {
      this.jobTitle = parameters.jobTitle;
    } else if (typeof parameters.jobTitle === "string") {
      this.jobTitle = purify.Maybe.of(parameters.jobTitle);
    } else if (typeof parameters.jobTitle === "undefined") {
      this.jobTitle = purify.Maybe.empty();
    } else {
      this.jobTitle = parameters.jobTitle satisfies never;
    }
  }

  override get $identifier(): PersonStub.$Identifier {
    if (typeof this._$identifier === "undefined") {
      this._$identifier = dataFactory.blankNode();
    }
    return this._$identifier;
  }

  override $equals(other: PersonStub): $EqualsResult {
    return super
      .$equals(other)
      .chain(() =>
        ((left, right) => $maybeEquals(left, right, $strictEquals))(
          this.jobTitle,
          other.jobTitle,
        ).mapLeft((propertyValuesUnequal) => ({
          left: this,
          right: other,
          propertyName: "jobTitle",
          propertyValuesUnequal,
          type: "Property" as const,
        })),
      );
  }

  override $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    this.$hashShaclProperties(_hasher);
    return _hasher;
  }

  protected override $hashShaclProperties<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_hasher: HasherT): HasherT {
    super.$hashShaclProperties(_hasher);
    this.jobTitle.ifJust((_value0) => {
      _hasher.update(_value0);
    });
    return _hasher;
  }

  override $toJson(): PersonStub.$Json {
    return JSON.parse(
      JSON.stringify({
        ...super.$toJson(),
        jobTitle: this.jobTitle.map((_item) => _item).extract(),
      } satisfies PersonStub.$Json),
    );
  }

  override $toRdf({
    ignoreRdfType,
    mutateGraph,
    resourceSet,
  }: {
    ignoreRdfType?: boolean;
    mutateGraph?: rdfjsResource.MutableResource.MutateGraph;
    resourceSet: rdfjsResource.MutableResourceSet;
  }): rdfjsResource.MutableResource {
    const _resource = super.$toRdf({
      ignoreRdfType: true,
      mutateGraph,
      resourceSet,
    });
    if (!ignoreRdfType) {
      _resource.add(
        $RdfVocabularies.rdf.type,
        _resource.dataFactory.namedNode("http://schema.org/Person"),
      );
    }

    _resource.add(PersonStub.$properties.jobTitle["identifier"], this.jobTitle);
    return _resource;
  }

  override toString(): string {
    return JSON.stringify(this.$toJson());
  }
}

export namespace PersonStub {
  export const $fromRdfType: rdfjs.NamedNode<string> = dataFactory.namedNode(
    "http://schema.org/Person",
  );
  export type $Identifier = ThingStubStatic.$Identifier;
  export const $Identifier = ThingStubStatic.$Identifier;
  export type $Json = {
    readonly jobTitle: string | undefined;
  } & ThingStubStatic.$Json;

  export function $propertiesFromJson(
    _json: unknown,
  ): purify.Either<
    zod.ZodError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      jobTitle: purify.Maybe<string>;
    } & $UnwrapR<ReturnType<typeof ThingStubStatic.$propertiesFromJson>>
  > {
    const $jsonSafeParseResult = $jsonZodSchema().safeParse(_json);
    if (!$jsonSafeParseResult.success) {
      return purify.Left($jsonSafeParseResult.error);
    }

    const _jsonObject = $jsonSafeParseResult.data;
    const $super0Either = ThingStubStatic.$propertiesFromJson(_jsonObject);
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    const $identifier = _jsonObject["@id"].startsWith("_:")
      ? dataFactory.blankNode(_jsonObject["@id"].substring(2))
      : dataFactory.namedNode(_jsonObject["@id"]);
    const jobTitle = purify.Maybe.fromNullable(_jsonObject["jobTitle"]);
    return purify.Either.of({ ...$super0, $identifier, jobTitle });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, PersonStub> {
    return $propertiesFromJson(json).map(
      (properties) => new PersonStub(properties),
    );
  }

  export function $jsonSchema() {
    return zodToJsonSchema($jsonZodSchema());
  }

  export function $jsonUiSchema(parameters?: { scopePrefix?: string }) {
    const scopePrefix = parameters?.scopePrefix ?? "#";
    return {
      elements: [
        ThingStubStatic.$jsonUiSchema({ scopePrefix }),
        { scope: `${scopePrefix}/properties/jobTitle`, type: "Control" },
      ],
      label: "PersonStub",
      type: "Group",
    };
  }

  export function $jsonZodSchema() {
    return ThingStubStatic.$jsonZodSchema().merge(
      zod.object({
        "@id": zod.string().min(1),
        $type: zod.literal("PersonStub"),
        jobTitle: zod.string().optional(),
      }),
    );
  }

  export function $propertiesFromRdf({
    ignoreRdfType: _ignoreRdfType,
    languageIn: _languageIn,
    resource: _resource,
    // @ts-ignore
    ..._context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    languageIn?: readonly string[];
    resource: rdfjsResource.Resource;
  }): purify.Either<
    rdfjsResource.Resource.ValueError,
    {
      $identifier: rdfjs.BlankNode | rdfjs.NamedNode;
      jobTitle: purify.Maybe<string>;
    } & $UnwrapR<ReturnType<typeof ThingStubStatic.$propertiesFromRdf>>
  > {
    const $super0Either = ThingStubStatic.$propertiesFromRdf({
      ..._context,
      ignoreRdfType: true,
      languageIn: _languageIn,
      resource: _resource,
    });
    if ($super0Either.isLeft()) {
      return $super0Either;
    }

    const $super0 = $super0Either.unsafeCoerce();
    if (!_ignoreRdfType && !_resource.isInstanceOf($fromRdfType)) {
      return _resource
        .value($RdfVocabularies.rdf.type)
        .chain((actualRdfType) => actualRdfType.toIri())
        .chain((actualRdfType) =>
          purify.Left(
            new rdfjsResource.Resource.ValueError({
              focusResource: _resource,
              message: `${rdfjsResource.Resource.Identifier.toString(_resource.identifier)} has unexpected RDF type (actual: ${actualRdfType.value}, expected: http://schema.org/Person)`,
              predicate: $RdfVocabularies.rdf.type,
            }),
          ),
        );
    }

    const $identifier: PersonStub.$Identifier = _resource.identifier;
    const _jobTitleEither: purify.Either<
      rdfjsResource.Resource.ValueError,
      purify.Maybe<string>
    > = purify.Either.of(
      _resource
        .values($properties.jobTitle["identifier"], { unique: true })
        .head()
        .chain((_value) => _value.toString())
        .toMaybe(),
    );
    if (_jobTitleEither.isLeft()) {
      return _jobTitleEither;
    }

    const jobTitle = _jobTitleEither.unsafeCoerce();
    return purify.Either.of({ ...$super0, $identifier, jobTitle });
  }

  export function $fromRdf(
    parameters: Parameters<typeof PersonStub.$propertiesFromRdf>[0],
  ): purify.Either<rdfjsResource.Resource.ValueError, PersonStub> {
    return PersonStub.$propertiesFromRdf(parameters).map(
      (properties) => new PersonStub(properties),
    );
  }

  export const $properties = {
    ...ThingStubStatic.$properties,
    jobTitle: {
      identifier: dataFactory.namedNode("http://schema.org/jobTitle"),
    },
  };

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        PersonStub.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        PersonStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      PersonStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    const subject = parameters?.subject ?? dataFactory.variable!("personStub");
    const triples: sparqljs.Triple[] = [];
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "personStub");
    triples.push(
      ...ThingStubStatic.$sparqlConstructTemplateTriples({
        ignoreRdfType: true,
        subject,
        variablePrefix,
      }),
    );
    if (!parameters?.ignoreRdfType) {
      triples.push(
        {
          subject,
          predicate: $RdfVocabularies.rdf.type,
          object: dataFactory.variable!(`${variablePrefix}RdfType`),
        },
        {
          subject: dataFactory.variable!(`${variablePrefix}RdfType`),
          predicate: $RdfVocabularies.rdfs.subClassOf,
          object: dataFactory.variable!(`${variablePrefix}RdfClass`),
        },
      );
    }

    triples.push({
      object: dataFactory.variable!(`${variablePrefix}JobTitle`),
      predicate: PersonStub.$properties.jobTitle["identifier"],
      subject,
    });
    return triples;
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    const optionalPatterns: sparqljs.OptionalPattern[] = [];
    const requiredPatterns: sparqljs.Pattern[] = [];
    const subject = parameters?.subject ?? dataFactory.variable!("personStub");
    const variablePrefix =
      parameters?.variablePrefix ??
      (subject.termType === "Variable" ? subject.value : "personStub");
    for (const pattern of ThingStubStatic.$sparqlWherePatterns({
      ignoreRdfType: true,
      subject,
      variablePrefix,
    })) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    if (!parameters?.ignoreRdfType) {
      requiredPatterns.push(
        $sparqlInstancesOfPattern({ rdfType: $fromRdfType, subject }),
      );
      requiredPatterns.push({
        triples: [
          {
            subject,
            predicate: $RdfVocabularies.rdf.type,
            object: dataFactory.variable!(`${variablePrefix}RdfType`),
          },
        ],
        type: "bgp" as const,
      });
      optionalPatterns.push({
        patterns: [
          {
            triples: [
              {
                subject: dataFactory.variable!(`${variablePrefix}RdfType`),
                predicate: {
                  items: [$RdfVocabularies.rdfs.subClassOf],
                  pathType: "+" as const,
                  type: "path" as const,
                },
                object: dataFactory.variable!(`${variablePrefix}RdfClass`),
              },
            ],
            type: "bgp" as const,
          },
        ],
        type: "optional" as const,
      });
    }

    const propertyPatterns: readonly sparqljs.Pattern[] = [
      {
        patterns: [
          {
            triples: [
              {
                object: dataFactory.variable!(`${variablePrefix}JobTitle`),
                predicate: PersonStub.$properties.jobTitle["identifier"],
                subject,
              },
            ],
            type: "bgp",
          },
        ],
        type: "optional",
      },
    ];
    for (const pattern of propertyPatterns) {
      if (pattern.type === "optional") {
        optionalPatterns.push(pattern);
      } else {
        requiredPatterns.push(pattern);
      }
    }

    return requiredPatterns.concat(optionalPatterns);
  }
}
export type AgentStub = OrganizationStub | PersonStub;

export namespace AgentStub {
  export function $equals(left: AgentStub, right: AgentStub): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "OrganizationStub":
        case "MusicGroupStub":
        case "PerformingGroupStub":
          return left.$equals(right as unknown as OrganizationStub);
        case "PersonStub":
          return left.$equals(right as unknown as PersonStub);
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, AgentStub> {
    return (
      OrganizationStubStatic.$fromJson(json) as purify.Either<
        zod.ZodError,
        AgentStub
      >
    ).altLazy(
      () =>
        PersonStub.$fromJson(json) as purify.Either<zod.ZodError, AgentStub>,
    );
  }

  export function $fromRdf({
    ignoreRdfType,
    resource,
    ...context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource;
  }): purify.Either<rdfjsResource.Resource.ValueError, AgentStub> {
    return (
      OrganizationStubStatic.$fromRdf({
        ...context,
        resource,
      }) as purify.Either<rdfjsResource.Resource.ValueError, AgentStub>
    ).altLazy(
      () =>
        PersonStub.$fromRdf({ ...context, resource }) as purify.Either<
          rdfjsResource.Resource.ValueError,
          AgentStub
        >,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_agentStub: AgentStub, _hasher: HasherT): HasherT {
    switch (_agentStub.$type) {
      case "OrganizationStub":
      case "MusicGroupStub":
      case "PerformingGroupStub":
        return _agentStub.$hash(_hasher);
      case "PersonStub":
        return _agentStub.$hash(_hasher);
      default:
        _agentStub satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Json = OrganizationStubStatic.$Json | PersonStub.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      OrganizationStubStatic.$jsonZodSchema(),
      PersonStub.$jsonZodSchema(),
    ]);
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory: dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        AgentStub.$sparqlConstructTemplateTriples({ ignoreRdfType, subject }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        AgentStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      AgentStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...OrganizationStubStatic.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("agentStubOrganizationStub"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}OrganizationStub`
          : "agentStubOrganizationStub",
      }).concat(),
      ...PersonStub.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ?? dataFactory.variable!("agentStubPersonStub"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PersonStub`
          : "agentStubPersonStub",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: OrganizationStubStatic.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!("agentStubOrganizationStub"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}OrganizationStub`
                : "agentStubOrganizationStub",
            }).concat(),
            type: "group",
          },
          {
            patterns: PersonStub.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!("agentStubPersonStub"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PersonStub`
                : "agentStubPersonStub",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _agentStub: AgentStub,
  ): OrganizationStubStatic.$Json | PersonStub.$Json {
    switch (_agentStub.$type) {
      case "OrganizationStub":
      case "MusicGroupStub":
      case "PerformingGroupStub":
        return _agentStub.$toJson();
      case "PersonStub":
        return _agentStub.$toJson();
      default:
        _agentStub satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _agentStub: AgentStub,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_agentStub.$type) {
      case "OrganizationStub":
      case "MusicGroupStub":
      case "PerformingGroupStub":
        return _agentStub.$toRdf(_parameters);
      case "PersonStub":
        return _agentStub.$toRdf(_parameters);
      default:
        _agentStub satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
export type MusicArtistStub = MusicGroupStub | PersonStub;

export namespace MusicArtistStub {
  export function $equals(
    left: MusicArtistStub,
    right: MusicArtistStub,
  ): $EqualsResult {
    return $strictEquals(left.$type, right.$type).chain(() => {
      switch (left.$type) {
        case "MusicGroupStub":
          return left.$equals(right as unknown as MusicGroupStub);
        case "PersonStub":
          return left.$equals(right as unknown as PersonStub);
        default:
          left satisfies never;
          throw new Error("unrecognized type");
      }
    });
  }

  export function $fromJson(
    json: unknown,
  ): purify.Either<zod.ZodError, MusicArtistStub> {
    return (
      MusicGroupStub.$fromJson(json) as purify.Either<
        zod.ZodError,
        MusicArtistStub
      >
    ).altLazy(
      () =>
        PersonStub.$fromJson(json) as purify.Either<
          zod.ZodError,
          MusicArtistStub
        >,
    );
  }

  export function $fromRdf({
    ignoreRdfType,
    resource,
    ...context
  }: {
    [_index: string]: any;
    ignoreRdfType?: boolean;
    resource: rdfjsResource.Resource;
  }): purify.Either<rdfjsResource.Resource.ValueError, MusicArtistStub> {
    return (
      MusicGroupStub.$fromRdf({ ...context, resource }) as purify.Either<
        rdfjsResource.Resource.ValueError,
        MusicArtistStub
      >
    ).altLazy(
      () =>
        PersonStub.$fromRdf({ ...context, resource }) as purify.Either<
          rdfjsResource.Resource.ValueError,
          MusicArtistStub
        >,
    );
  }

  export function $hash<
    HasherT extends {
      update: (message: string | number[] | ArrayBuffer | Uint8Array) => void;
    },
  >(_musicArtistStub: MusicArtistStub, _hasher: HasherT): HasherT {
    switch (_musicArtistStub.$type) {
      case "MusicGroupStub":
        return _musicArtistStub.$hash(_hasher);
      case "PersonStub":
        return _musicArtistStub.$hash(_hasher);
      default:
        _musicArtistStub satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export type $Json = MusicGroupStub.$Json | PersonStub.$Json;

  export function $jsonZodSchema() {
    return zod.discriminatedUnion("$type", [
      MusicGroupStub.$jsonZodSchema(),
      PersonStub.$jsonZodSchema(),
    ]);
  }

  export type $Identifier = rdfjs.BlankNode | rdfjs.NamedNode;

  export namespace $Identifier {
    export function fromString(
      identifier: string,
    ): purify.Either<Error, rdfjsResource.Resource.Identifier> {
      return purify.Either.encase(() =>
        rdfjsResource.Resource.Identifier.fromString({
          dataFactory: dataFactory,
          identifier,
        }),
      );
    }

    export const // biome-ignore lint/suspicious/noShadowRestrictedNames:
      toString = rdfjsResource.Resource.Identifier.toString;
  }

  export function $sparqlConstructQuery(
    parameters?: {
      ignoreRdfType?: boolean;
      prefixes?: { [prefix: string]: string };
      subject?: sparqljs.Triple["subject"];
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type">,
  ): sparqljs.ConstructQuery {
    const { ignoreRdfType, subject, ...queryParameters } = parameters ?? {};

    return {
      ...queryParameters,
      prefixes: parameters?.prefixes ?? {},
      queryType: "CONSTRUCT",
      template: (queryParameters.template ?? []).concat(
        MusicArtistStub.$sparqlConstructTemplateTriples({
          ignoreRdfType,
          subject,
        }),
      ),
      type: "query",
      where: (queryParameters.where ?? []).concat(
        MusicArtistStub.$sparqlWherePatterns({ ignoreRdfType, subject }),
      ),
    };
  }

  export function $sparqlConstructQueryString(
    parameters?: {
      ignoreRdfType?: boolean;
      subject?: sparqljs.Triple["subject"];
      variablePrefix?: string;
    } & Omit<sparqljs.ConstructQuery, "prefixes" | "queryType" | "type"> &
      sparqljs.GeneratorOptions,
  ): string {
    return new sparqljs.Generator(parameters).stringify(
      MusicArtistStub.$sparqlConstructQuery(parameters),
    );
  }

  export function $sparqlConstructTemplateTriples(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Triple[] {
    return [
      ...MusicGroupStub.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("musicArtistStubMusicGroupStub"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}MusicGroupStub`
          : "musicArtistStubMusicGroupStub",
      }).concat(),
      ...PersonStub.$sparqlConstructTemplateTriples({
        subject:
          parameters?.subject ??
          dataFactory.variable!("musicArtistStubPersonStub"),
        variablePrefix: parameters?.variablePrefix
          ? `${parameters.variablePrefix}PersonStub`
          : "musicArtistStubPersonStub",
      }).concat(),
    ];
  }

  export function $sparqlWherePatterns(parameters?: {
    ignoreRdfType?: boolean;
    subject?: sparqljs.Triple["subject"];
    variablePrefix?: string;
  }): readonly sparqljs.Pattern[] {
    return [
      {
        patterns: [
          {
            patterns: MusicGroupStub.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!("musicArtistStubMusicGroupStub"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}MusicGroupStub`
                : "musicArtistStubMusicGroupStub",
            }).concat(),
            type: "group",
          },
          {
            patterns: PersonStub.$sparqlWherePatterns({
              subject:
                parameters?.subject ??
                dataFactory.variable!("musicArtistStubPersonStub"),
              variablePrefix: parameters?.variablePrefix
                ? `${parameters.variablePrefix}PersonStub`
                : "musicArtistStubPersonStub",
            }).concat(),
            type: "group",
          },
        ],
        type: "union",
      },
    ];
  }

  export function $toJson(
    _musicArtistStub: MusicArtistStub,
  ): MusicGroupStub.$Json | PersonStub.$Json {
    switch (_musicArtistStub.$type) {
      case "MusicGroupStub":
        return _musicArtistStub.$toJson();
      case "PersonStub":
        return _musicArtistStub.$toJson();
      default:
        _musicArtistStub satisfies never;
        throw new Error("unrecognized type");
    }
  }

  export function $toRdf(
    _musicArtistStub: MusicArtistStub,
    _parameters: {
      mutateGraph: rdfjsResource.MutableResource.MutateGraph;
      resourceSet: rdfjsResource.MutableResourceSet;
    },
  ): rdfjsResource.MutableResource {
    switch (_musicArtistStub.$type) {
      case "MusicGroupStub":
        return _musicArtistStub.$toRdf(_parameters);
      case "PersonStub":
        return _musicArtistStub.$toRdf(_parameters);
      default:
        _musicArtistStub satisfies never;
        throw new Error("unrecognized type");
    }
  }
}
export interface $ObjectSet {
  action(
    identifier: ActionStatic.$Identifier,
  ): Promise<purify.Either<Error, Action>>;
  actionIdentifiers(
    query?: $ObjectSet.Query<ActionStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ActionStatic.$Identifier[]>>;
  actions(
    query?: $ObjectSet.Query<ActionStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Action>[]>;
  actionsCount(
    query?: Pick<$ObjectSet.Query<ActionStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  actionStub(
    identifier: ActionStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ActionStub>>;
  actionStubIdentifiers(
    query?: $ObjectSet.Query<ActionStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ActionStubStatic.$Identifier[]>>;
  actionStubs(
    query?: $ObjectSet.Query<ActionStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ActionStub>[]>;
  actionStubsCount(
    query?: Pick<$ObjectSet.Query<ActionStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  article(
    identifier: ArticleStatic.$Identifier,
  ): Promise<purify.Either<Error, Article>>;
  articleIdentifiers(
    query?: $ObjectSet.Query<ArticleStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ArticleStatic.$Identifier[]>>;
  articles(
    query?: $ObjectSet.Query<ArticleStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Article>[]>;
  articlesCount(
    query?: Pick<$ObjectSet.Query<ArticleStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  articleStub(
    identifier: ArticleStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ArticleStub>>;
  articleStubIdentifiers(
    query?: $ObjectSet.Query<ArticleStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ArticleStubStatic.$Identifier[]>>;
  articleStubs(
    query?: $ObjectSet.Query<ArticleStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ArticleStub>[]>;
  articleStubsCount(
    query?: Pick<$ObjectSet.Query<ArticleStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  assessAction(
    identifier: AssessActionStatic.$Identifier,
  ): Promise<purify.Either<Error, AssessAction>>;
  assessActionIdentifiers(
    query?: $ObjectSet.Query<AssessActionStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly AssessActionStatic.$Identifier[]>>;
  assessActions(
    query?: $ObjectSet.Query<AssessActionStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, AssessAction>[]>;
  assessActionsCount(
    query?: Pick<$ObjectSet.Query<AssessActionStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  assessActionStub(
    identifier: AssessActionStubStatic.$Identifier,
  ): Promise<purify.Either<Error, AssessActionStub>>;
  assessActionStubIdentifiers(
    query?: $ObjectSet.Query<AssessActionStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly AssessActionStubStatic.$Identifier[]>
  >;
  assessActionStubs(
    query?: $ObjectSet.Query<AssessActionStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, AssessActionStub>[]>;
  assessActionStubsCount(
    query?: Pick<$ObjectSet.Query<AssessActionStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  broadcastEvent(
    identifier: BroadcastEvent.$Identifier,
  ): Promise<purify.Either<Error, BroadcastEvent>>;
  broadcastEventIdentifiers(
    query?: $ObjectSet.Query<BroadcastEvent.$Identifier>,
  ): Promise<purify.Either<Error, readonly BroadcastEvent.$Identifier[]>>;
  broadcastEvents(
    query?: $ObjectSet.Query<BroadcastEvent.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastEvent>[]>;
  broadcastEventsCount(
    query?: Pick<$ObjectSet.Query<BroadcastEvent.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  broadcastEventStub(
    identifier: BroadcastEventStub.$Identifier,
  ): Promise<purify.Either<Error, BroadcastEventStub>>;
  broadcastEventStubIdentifiers(
    query?: $ObjectSet.Query<BroadcastEventStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly BroadcastEventStub.$Identifier[]>>;
  broadcastEventStubs(
    query?: $ObjectSet.Query<BroadcastEventStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastEventStub>[]>;
  broadcastEventStubsCount(
    query?: Pick<$ObjectSet.Query<BroadcastEventStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  broadcastService(
    identifier: BroadcastServiceStatic.$Identifier,
  ): Promise<purify.Either<Error, BroadcastService>>;
  broadcastServiceIdentifiers(
    query?: $ObjectSet.Query<BroadcastServiceStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BroadcastServiceStatic.$Identifier[]>
  >;
  broadcastServices(
    query?: $ObjectSet.Query<BroadcastServiceStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastService>[]>;
  broadcastServicesCount(
    query?: Pick<$ObjectSet.Query<BroadcastServiceStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  broadcastServiceStub(
    identifier: BroadcastServiceStubStatic.$Identifier,
  ): Promise<purify.Either<Error, BroadcastServiceStub>>;
  broadcastServiceStubIdentifiers(
    query?: $ObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BroadcastServiceStubStatic.$Identifier[]>
  >;
  broadcastServiceStubs(
    query?: $ObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastServiceStub>[]>;
  broadcastServiceStubsCount(
    query?: Pick<
      $ObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  chooseAction(
    identifier: ChooseActionStatic.$Identifier,
  ): Promise<purify.Either<Error, ChooseAction>>;
  chooseActionIdentifiers(
    query?: $ObjectSet.Query<ChooseActionStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ChooseActionStatic.$Identifier[]>>;
  chooseActions(
    query?: $ObjectSet.Query<ChooseActionStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ChooseAction>[]>;
  chooseActionsCount(
    query?: Pick<$ObjectSet.Query<ChooseActionStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  chooseActionStub(
    identifier: ChooseActionStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ChooseActionStub>>;
  chooseActionStubIdentifiers(
    query?: $ObjectSet.Query<ChooseActionStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ChooseActionStubStatic.$Identifier[]>
  >;
  chooseActionStubs(
    query?: $ObjectSet.Query<ChooseActionStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ChooseActionStub>[]>;
  chooseActionStubsCount(
    query?: Pick<$ObjectSet.Query<ChooseActionStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  creativeWork(
    identifier: CreativeWorkStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWork>>;
  creativeWorkIdentifiers(
    query?: $ObjectSet.Query<CreativeWorkStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly CreativeWorkStatic.$Identifier[]>>;
  creativeWorks(
    query?: $ObjectSet.Query<CreativeWorkStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWork>[]>;
  creativeWorksCount(
    query?: Pick<$ObjectSet.Query<CreativeWorkStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  creativeWorkSeries(
    identifier: CreativeWorkSeriesStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWorkSeries>>;
  creativeWorkSeriesIdentifiers(
    query?: $ObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly CreativeWorkSeriesStatic.$Identifier[]>
  >;
  creativeWorkSeriess(
    query?: $ObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWorkSeries>[]>;
  creativeWorkSeriessCount(
    query?: Pick<
      $ObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  creativeWorkSeriesStub(
    identifier: CreativeWorkSeriesStubStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWorkSeriesStub>>;
  creativeWorkSeriesStubIdentifiers(
    query?: $ObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly CreativeWorkSeriesStubStatic.$Identifier[]>
  >;
  creativeWorkSeriesStubs(
    query?: $ObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWorkSeriesStub>[]>;
  creativeWorkSeriesStubsCount(
    query?: Pick<
      $ObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  creativeWorkStub(
    identifier: CreativeWorkStubStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWorkStub>>;
  creativeWorkStubIdentifiers(
    query?: $ObjectSet.Query<CreativeWorkStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly CreativeWorkStubStatic.$Identifier[]>
  >;
  creativeWorkStubs(
    query?: $ObjectSet.Query<CreativeWorkStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWorkStub>[]>;
  creativeWorkStubsCount(
    query?: Pick<$ObjectSet.Query<CreativeWorkStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  enumeration(
    identifier: EnumerationStatic.$Identifier,
  ): Promise<purify.Either<Error, Enumeration>>;
  enumerationIdentifiers(
    query?: $ObjectSet.Query<EnumerationStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EnumerationStatic.$Identifier[]>>;
  enumerations(
    query?: $ObjectSet.Query<EnumerationStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Enumeration>[]>;
  enumerationsCount(
    query?: Pick<$ObjectSet.Query<EnumerationStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  episode(
    identifier: EpisodeStatic.$Identifier,
  ): Promise<purify.Either<Error, Episode>>;
  episodeIdentifiers(
    query?: $ObjectSet.Query<EpisodeStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EpisodeStatic.$Identifier[]>>;
  episodes(
    query?: $ObjectSet.Query<EpisodeStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Episode>[]>;
  episodesCount(
    query?: Pick<$ObjectSet.Query<EpisodeStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  episodeStub(
    identifier: EpisodeStubStatic.$Identifier,
  ): Promise<purify.Either<Error, EpisodeStub>>;
  episodeStubIdentifiers(
    query?: $ObjectSet.Query<EpisodeStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EpisodeStubStatic.$Identifier[]>>;
  episodeStubs(
    query?: $ObjectSet.Query<EpisodeStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, EpisodeStub>[]>;
  episodeStubsCount(
    query?: Pick<$ObjectSet.Query<EpisodeStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  event(
    identifier: EventStatic.$Identifier,
  ): Promise<purify.Either<Error, Event>>;
  eventIdentifiers(
    query?: $ObjectSet.Query<EventStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EventStatic.$Identifier[]>>;
  events(
    query?: $ObjectSet.Query<EventStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Event>[]>;
  eventsCount(
    query?: Pick<$ObjectSet.Query<EventStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  eventStub(
    identifier: EventStubStatic.$Identifier,
  ): Promise<purify.Either<Error, EventStub>>;
  eventStubIdentifiers(
    query?: $ObjectSet.Query<EventStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EventStubStatic.$Identifier[]>>;
  eventStubs(
    query?: $ObjectSet.Query<EventStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, EventStub>[]>;
  eventStubsCount(
    query?: Pick<$ObjectSet.Query<EventStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  genderType(
    identifier: GenderType.$Identifier,
  ): Promise<purify.Either<Error, GenderType>>;
  genderTypeIdentifiers(
    query?: $ObjectSet.Query<GenderType.$Identifier>,
  ): Promise<purify.Either<Error, readonly GenderType.$Identifier[]>>;
  genderTypes(
    query?: $ObjectSet.Query<GenderType.$Identifier>,
  ): Promise<readonly purify.Either<Error, GenderType>[]>;
  genderTypesCount(
    query?: Pick<$ObjectSet.Query<GenderType.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  imageObject(
    identifier: ImageObject.$Identifier,
  ): Promise<purify.Either<Error, ImageObject>>;
  imageObjectIdentifiers(
    query?: $ObjectSet.Query<ImageObject.$Identifier>,
  ): Promise<purify.Either<Error, readonly ImageObject.$Identifier[]>>;
  imageObjects(
    query?: $ObjectSet.Query<ImageObject.$Identifier>,
  ): Promise<readonly purify.Either<Error, ImageObject>[]>;
  imageObjectsCount(
    query?: Pick<$ObjectSet.Query<ImageObject.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  imageObjectStub(
    identifier: ImageObjectStub.$Identifier,
  ): Promise<purify.Either<Error, ImageObjectStub>>;
  imageObjectStubIdentifiers(
    query?: $ObjectSet.Query<ImageObjectStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ImageObjectStub.$Identifier[]>>;
  imageObjectStubs(
    query?: $ObjectSet.Query<ImageObjectStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ImageObjectStub>[]>;
  imageObjectStubsCount(
    query?: Pick<$ObjectSet.Query<ImageObjectStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  intangible(
    identifier: IntangibleStatic.$Identifier,
  ): Promise<purify.Either<Error, Intangible>>;
  intangibleIdentifiers(
    query?: $ObjectSet.Query<IntangibleStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IntangibleStatic.$Identifier[]>>;
  intangibles(
    query?: $ObjectSet.Query<IntangibleStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Intangible>[]>;
  intangiblesCount(
    query?: Pick<$ObjectSet.Query<IntangibleStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  intangibleStub(
    identifier: IntangibleStubStatic.$Identifier,
  ): Promise<purify.Either<Error, IntangibleStub>>;
  intangibleStubIdentifiers(
    query?: $ObjectSet.Query<IntangibleStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IntangibleStubStatic.$Identifier[]>>;
  intangibleStubs(
    query?: $ObjectSet.Query<IntangibleStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, IntangibleStub>[]>;
  intangibleStubsCount(
    query?: Pick<$ObjectSet.Query<IntangibleStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  invoice(
    identifier: Invoice.$Identifier,
  ): Promise<purify.Either<Error, Invoice>>;
  invoiceIdentifiers(
    query?: $ObjectSet.Query<Invoice.$Identifier>,
  ): Promise<purify.Either<Error, readonly Invoice.$Identifier[]>>;
  invoices(
    query?: $ObjectSet.Query<Invoice.$Identifier>,
  ): Promise<readonly purify.Either<Error, Invoice>[]>;
  invoicesCount(
    query?: Pick<$ObjectSet.Query<Invoice.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  invoiceStub(
    identifier: InvoiceStub.$Identifier,
  ): Promise<purify.Either<Error, InvoiceStub>>;
  invoiceStubIdentifiers(
    query?: $ObjectSet.Query<InvoiceStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly InvoiceStub.$Identifier[]>>;
  invoiceStubs(
    query?: $ObjectSet.Query<InvoiceStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, InvoiceStub>[]>;
  invoiceStubsCount(
    query?: Pick<$ObjectSet.Query<InvoiceStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  itemList(
    identifier: ItemList.$Identifier,
  ): Promise<purify.Either<Error, ItemList>>;
  itemListIdentifiers(
    query?: $ObjectSet.Query<ItemList.$Identifier>,
  ): Promise<purify.Either<Error, readonly ItemList.$Identifier[]>>;
  itemLists(
    query?: $ObjectSet.Query<ItemList.$Identifier>,
  ): Promise<readonly purify.Either<Error, ItemList>[]>;
  itemListsCount(
    query?: Pick<$ObjectSet.Query<ItemList.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  itemListStub(
    identifier: ItemListStub.$Identifier,
  ): Promise<purify.Either<Error, ItemListStub>>;
  itemListStubIdentifiers(
    query?: $ObjectSet.Query<ItemListStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ItemListStub.$Identifier[]>>;
  itemListStubs(
    query?: $ObjectSet.Query<ItemListStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ItemListStub>[]>;
  itemListStubsCount(
    query?: Pick<$ObjectSet.Query<ItemListStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  listItem(
    identifier: ListItem.$Identifier,
  ): Promise<purify.Either<Error, ListItem>>;
  listItemIdentifiers(
    query?: $ObjectSet.Query<ListItem.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListItem.$Identifier[]>>;
  listItems(
    query?: $ObjectSet.Query<ListItem.$Identifier>,
  ): Promise<readonly purify.Either<Error, ListItem>[]>;
  listItemsCount(
    query?: Pick<$ObjectSet.Query<ListItem.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  listItemStub(
    identifier: ListItemStub.$Identifier,
  ): Promise<purify.Either<Error, ListItemStub>>;
  listItemStubIdentifiers(
    query?: $ObjectSet.Query<ListItemStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListItemStub.$Identifier[]>>;
  listItemStubs(
    query?: $ObjectSet.Query<ListItemStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ListItemStub>[]>;
  listItemStubsCount(
    query?: Pick<$ObjectSet.Query<ListItemStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  mediaObject(
    identifier: MediaObjectStatic.$Identifier,
  ): Promise<purify.Either<Error, MediaObject>>;
  mediaObjectIdentifiers(
    query?: $ObjectSet.Query<MediaObjectStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly MediaObjectStatic.$Identifier[]>>;
  mediaObjects(
    query?: $ObjectSet.Query<MediaObjectStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, MediaObject>[]>;
  mediaObjectsCount(
    query?: Pick<$ObjectSet.Query<MediaObjectStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  mediaObjectStub(
    identifier: MediaObjectStubStatic.$Identifier,
  ): Promise<purify.Either<Error, MediaObjectStub>>;
  mediaObjectStubIdentifiers(
    query?: $ObjectSet.Query<MediaObjectStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MediaObjectStubStatic.$Identifier[]>
  >;
  mediaObjectStubs(
    query?: $ObjectSet.Query<MediaObjectStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, MediaObjectStub>[]>;
  mediaObjectStubsCount(
    query?: Pick<$ObjectSet.Query<MediaObjectStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  message(
    identifier: Message.$Identifier,
  ): Promise<purify.Either<Error, Message>>;
  messageIdentifiers(
    query?: $ObjectSet.Query<Message.$Identifier>,
  ): Promise<purify.Either<Error, readonly Message.$Identifier[]>>;
  messages(
    query?: $ObjectSet.Query<Message.$Identifier>,
  ): Promise<readonly purify.Either<Error, Message>[]>;
  messagesCount(
    query?: Pick<$ObjectSet.Query<Message.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  messageStub(
    identifier: MessageStub.$Identifier,
  ): Promise<purify.Either<Error, MessageStub>>;
  messageStubIdentifiers(
    query?: $ObjectSet.Query<MessageStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MessageStub.$Identifier[]>>;
  messageStubs(
    query?: $ObjectSet.Query<MessageStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MessageStub>[]>;
  messageStubsCount(
    query?: Pick<$ObjectSet.Query<MessageStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  monetaryAmount(
    identifier: MonetaryAmount.$Identifier,
  ): Promise<purify.Either<Error, MonetaryAmount>>;
  monetaryAmountIdentifiers(
    query?: $ObjectSet.Query<MonetaryAmount.$Identifier>,
  ): Promise<purify.Either<Error, readonly MonetaryAmount.$Identifier[]>>;
  monetaryAmounts(
    query?: $ObjectSet.Query<MonetaryAmount.$Identifier>,
  ): Promise<readonly purify.Either<Error, MonetaryAmount>[]>;
  monetaryAmountsCount(
    query?: Pick<$ObjectSet.Query<MonetaryAmount.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  monetaryAmountStub(
    identifier: MonetaryAmountStub.$Identifier,
  ): Promise<purify.Either<Error, MonetaryAmountStub>>;
  monetaryAmountStubIdentifiers(
    query?: $ObjectSet.Query<MonetaryAmountStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MonetaryAmountStub.$Identifier[]>>;
  monetaryAmountStubs(
    query?: $ObjectSet.Query<MonetaryAmountStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MonetaryAmountStub>[]>;
  monetaryAmountStubsCount(
    query?: Pick<$ObjectSet.Query<MonetaryAmountStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicAlbum(
    identifier: MusicAlbum.$Identifier,
  ): Promise<purify.Either<Error, MusicAlbum>>;
  musicAlbumIdentifiers(
    query?: $ObjectSet.Query<MusicAlbum.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicAlbum.$Identifier[]>>;
  musicAlbums(
    query?: $ObjectSet.Query<MusicAlbum.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicAlbum>[]>;
  musicAlbumsCount(
    query?: Pick<$ObjectSet.Query<MusicAlbum.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicAlbumStub(
    identifier: MusicAlbumStub.$Identifier,
  ): Promise<purify.Either<Error, MusicAlbumStub>>;
  musicAlbumStubIdentifiers(
    query?: $ObjectSet.Query<MusicAlbumStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicAlbumStub.$Identifier[]>>;
  musicAlbumStubs(
    query?: $ObjectSet.Query<MusicAlbumStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicAlbumStub>[]>;
  musicAlbumStubsCount(
    query?: Pick<$ObjectSet.Query<MusicAlbumStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicArtistRoleStub(
    identifier: MusicArtistRoleStub.$Identifier,
  ): Promise<purify.Either<Error, MusicArtistRoleStub>>;
  musicArtistRoleStubIdentifiers(
    query?: $ObjectSet.Query<MusicArtistRoleStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicArtistRoleStub.$Identifier[]>>;
  musicArtistRoleStubs(
    query?: $ObjectSet.Query<MusicArtistRoleStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicArtistRoleStub>[]>;
  musicArtistRoleStubsCount(
    query?: Pick<$ObjectSet.Query<MusicArtistRoleStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicComposition(
    identifier: MusicComposition.$Identifier,
  ): Promise<purify.Either<Error, MusicComposition>>;
  musicCompositionIdentifiers(
    query?: $ObjectSet.Query<MusicComposition.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicComposition.$Identifier[]>>;
  musicCompositions(
    query?: $ObjectSet.Query<MusicComposition.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicComposition>[]>;
  musicCompositionsCount(
    query?: Pick<$ObjectSet.Query<MusicComposition.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicCompositionStub(
    identifier: MusicCompositionStub.$Identifier,
  ): Promise<purify.Either<Error, MusicCompositionStub>>;
  musicCompositionStubIdentifiers(
    query?: $ObjectSet.Query<MusicCompositionStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicCompositionStub.$Identifier[]>>;
  musicCompositionStubs(
    query?: $ObjectSet.Query<MusicCompositionStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicCompositionStub>[]>;
  musicCompositionStubsCount(
    query?: Pick<$ObjectSet.Query<MusicCompositionStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicGroup(
    identifier: MusicGroup.$Identifier,
  ): Promise<purify.Either<Error, MusicGroup>>;
  musicGroupIdentifiers(
    query?: $ObjectSet.Query<MusicGroup.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicGroup.$Identifier[]>>;
  musicGroups(
    query?: $ObjectSet.Query<MusicGroup.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicGroup>[]>;
  musicGroupsCount(
    query?: Pick<$ObjectSet.Query<MusicGroup.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicGroupStub(
    identifier: MusicGroupStub.$Identifier,
  ): Promise<purify.Either<Error, MusicGroupStub>>;
  musicGroupStubIdentifiers(
    query?: $ObjectSet.Query<MusicGroupStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicGroupStub.$Identifier[]>>;
  musicGroupStubs(
    query?: $ObjectSet.Query<MusicGroupStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicGroupStub>[]>;
  musicGroupStubsCount(
    query?: Pick<$ObjectSet.Query<MusicGroupStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicPlaylist(
    identifier: MusicPlaylist.$Identifier,
  ): Promise<purify.Either<Error, MusicPlaylist>>;
  musicPlaylistIdentifiers(
    query?: $ObjectSet.Query<MusicPlaylist.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicPlaylist.$Identifier[]>>;
  musicPlaylists(
    query?: $ObjectSet.Query<MusicPlaylist.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicPlaylist>[]>;
  musicPlaylistsCount(
    query?: Pick<$ObjectSet.Query<MusicPlaylist.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicPlaylistStub(
    identifier: MusicPlaylistStub.$Identifier,
  ): Promise<purify.Either<Error, MusicPlaylistStub>>;
  musicPlaylistStubIdentifiers(
    query?: $ObjectSet.Query<MusicPlaylistStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicPlaylistStub.$Identifier[]>>;
  musicPlaylistStubs(
    query?: $ObjectSet.Query<MusicPlaylistStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicPlaylistStub>[]>;
  musicPlaylistStubsCount(
    query?: Pick<$ObjectSet.Query<MusicPlaylistStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicRecording(
    identifier: MusicRecording.$Identifier,
  ): Promise<purify.Either<Error, MusicRecording>>;
  musicRecordingIdentifiers(
    query?: $ObjectSet.Query<MusicRecording.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicRecording.$Identifier[]>>;
  musicRecordings(
    query?: $ObjectSet.Query<MusicRecording.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicRecording>[]>;
  musicRecordingsCount(
    query?: Pick<$ObjectSet.Query<MusicRecording.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicRecordingStub(
    identifier: MusicRecordingStub.$Identifier,
  ): Promise<purify.Either<Error, MusicRecordingStub>>;
  musicRecordingStubIdentifiers(
    query?: $ObjectSet.Query<MusicRecordingStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicRecordingStub.$Identifier[]>>;
  musicRecordingStubs(
    query?: $ObjectSet.Query<MusicRecordingStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicRecordingStub>[]>;
  musicRecordingStubsCount(
    query?: Pick<$ObjectSet.Query<MusicRecordingStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  occupationStub(
    identifier: OccupationStub.$Identifier,
  ): Promise<purify.Either<Error, OccupationStub>>;
  occupationStubIdentifiers(
    query?: $ObjectSet.Query<OccupationStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly OccupationStub.$Identifier[]>>;
  occupationStubs(
    query?: $ObjectSet.Query<OccupationStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, OccupationStub>[]>;
  occupationStubsCount(
    query?: Pick<$ObjectSet.Query<OccupationStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  order(identifier: Order.$Identifier): Promise<purify.Either<Error, Order>>;
  orderIdentifiers(
    query?: $ObjectSet.Query<Order.$Identifier>,
  ): Promise<purify.Either<Error, readonly Order.$Identifier[]>>;
  orders(
    query?: $ObjectSet.Query<Order.$Identifier>,
  ): Promise<readonly purify.Either<Error, Order>[]>;
  ordersCount(
    query?: Pick<$ObjectSet.Query<Order.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  orderStub(
    identifier: OrderStub.$Identifier,
  ): Promise<purify.Either<Error, OrderStub>>;
  orderStubIdentifiers(
    query?: $ObjectSet.Query<OrderStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrderStub.$Identifier[]>>;
  orderStubs(
    query?: $ObjectSet.Query<OrderStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, OrderStub>[]>;
  orderStubsCount(
    query?: Pick<$ObjectSet.Query<OrderStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  organization(
    identifier: OrganizationStatic.$Identifier,
  ): Promise<purify.Either<Error, Organization>>;
  organizationIdentifiers(
    query?: $ObjectSet.Query<OrganizationStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrganizationStatic.$Identifier[]>>;
  organizations(
    query?: $ObjectSet.Query<OrganizationStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Organization>[]>;
  organizationsCount(
    query?: Pick<$ObjectSet.Query<OrganizationStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  organizationStub(
    identifier: OrganizationStubStatic.$Identifier,
  ): Promise<purify.Either<Error, OrganizationStub>>;
  organizationStubIdentifiers(
    query?: $ObjectSet.Query<OrganizationStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly OrganizationStubStatic.$Identifier[]>
  >;
  organizationStubs(
    query?: $ObjectSet.Query<OrganizationStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, OrganizationStub>[]>;
  organizationStubsCount(
    query?: Pick<$ObjectSet.Query<OrganizationStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  performingGroup(
    identifier: PerformingGroupStatic.$Identifier,
  ): Promise<purify.Either<Error, PerformingGroup>>;
  performingGroupIdentifiers(
    query?: $ObjectSet.Query<PerformingGroupStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PerformingGroupStatic.$Identifier[]>
  >;
  performingGroups(
    query?: $ObjectSet.Query<PerformingGroupStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PerformingGroup>[]>;
  performingGroupsCount(
    query?: Pick<$ObjectSet.Query<PerformingGroupStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  performingGroupStub(
    identifier: PerformingGroupStubStatic.$Identifier,
  ): Promise<purify.Either<Error, PerformingGroupStub>>;
  performingGroupStubIdentifiers(
    query?: $ObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PerformingGroupStubStatic.$Identifier[]>
  >;
  performingGroupStubs(
    query?: $ObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PerformingGroupStub>[]>;
  performingGroupStubsCount(
    query?: Pick<
      $ObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  person(identifier: Person.$Identifier): Promise<purify.Either<Error, Person>>;
  personIdentifiers(
    query?: $ObjectSet.Query<Person.$Identifier>,
  ): Promise<purify.Either<Error, readonly Person.$Identifier[]>>;
  people(
    query?: $ObjectSet.Query<Person.$Identifier>,
  ): Promise<readonly purify.Either<Error, Person>[]>;
  peopleCount(
    query?: Pick<$ObjectSet.Query<Person.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  personStub(
    identifier: PersonStub.$Identifier,
  ): Promise<purify.Either<Error, PersonStub>>;
  personStubIdentifiers(
    query?: $ObjectSet.Query<PersonStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly PersonStub.$Identifier[]>>;
  personStubs(
    query?: $ObjectSet.Query<PersonStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, PersonStub>[]>;
  personStubsCount(
    query?: Pick<$ObjectSet.Query<PersonStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  place(identifier: Place.$Identifier): Promise<purify.Either<Error, Place>>;
  placeIdentifiers(
    query?: $ObjectSet.Query<Place.$Identifier>,
  ): Promise<purify.Either<Error, readonly Place.$Identifier[]>>;
  places(
    query?: $ObjectSet.Query<Place.$Identifier>,
  ): Promise<readonly purify.Either<Error, Place>[]>;
  placesCount(
    query?: Pick<$ObjectSet.Query<Place.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  placeStub(
    identifier: PlaceStub.$Identifier,
  ): Promise<purify.Either<Error, PlaceStub>>;
  placeStubIdentifiers(
    query?: $ObjectSet.Query<PlaceStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly PlaceStub.$Identifier[]>>;
  placeStubs(
    query?: $ObjectSet.Query<PlaceStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, PlaceStub>[]>;
  placeStubsCount(
    query?: Pick<$ObjectSet.Query<PlaceStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  publicationEvent(
    identifier: PublicationEventStatic.$Identifier,
  ): Promise<purify.Either<Error, PublicationEvent>>;
  publicationEventIdentifiers(
    query?: $ObjectSet.Query<PublicationEventStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PublicationEventStatic.$Identifier[]>
  >;
  publicationEvents(
    query?: $ObjectSet.Query<PublicationEventStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PublicationEvent>[]>;
  publicationEventsCount(
    query?: Pick<$ObjectSet.Query<PublicationEventStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  publicationEventStub(
    identifier: PublicationEventStubStatic.$Identifier,
  ): Promise<purify.Either<Error, PublicationEventStub>>;
  publicationEventStubIdentifiers(
    query?: $ObjectSet.Query<PublicationEventStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PublicationEventStubStatic.$Identifier[]>
  >;
  publicationEventStubs(
    query?: $ObjectSet.Query<PublicationEventStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PublicationEventStub>[]>;
  publicationEventStubsCount(
    query?: Pick<
      $ObjectSet.Query<PublicationEventStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  quantitativeValue(
    identifier: QuantitativeValue.$Identifier,
  ): Promise<purify.Either<Error, QuantitativeValue>>;
  quantitativeValueIdentifiers(
    query?: $ObjectSet.Query<QuantitativeValue.$Identifier>,
  ): Promise<purify.Either<Error, readonly QuantitativeValue.$Identifier[]>>;
  quantitativeValues(
    query?: $ObjectSet.Query<QuantitativeValue.$Identifier>,
  ): Promise<readonly purify.Either<Error, QuantitativeValue>[]>;
  quantitativeValuesCount(
    query?: Pick<$ObjectSet.Query<QuantitativeValue.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  quantitativeValueStub(
    identifier: QuantitativeValueStub.$Identifier,
  ): Promise<purify.Either<Error, QuantitativeValueStub>>;
  quantitativeValueStubIdentifiers(
    query?: $ObjectSet.Query<QuantitativeValueStub.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly QuantitativeValueStub.$Identifier[]>
  >;
  quantitativeValueStubs(
    query?: $ObjectSet.Query<QuantitativeValueStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, QuantitativeValueStub>[]>;
  quantitativeValueStubsCount(
    query?: Pick<$ObjectSet.Query<QuantitativeValueStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  radioBroadcastService(
    identifier: RadioBroadcastService.$Identifier,
  ): Promise<purify.Either<Error, RadioBroadcastService>>;
  radioBroadcastServiceIdentifiers(
    query?: $ObjectSet.Query<RadioBroadcastService.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RadioBroadcastService.$Identifier[]>
  >;
  radioBroadcastServices(
    query?: $ObjectSet.Query<RadioBroadcastService.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioBroadcastService>[]>;
  radioBroadcastServicesCount(
    query?: Pick<$ObjectSet.Query<RadioBroadcastService.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  radioBroadcastServiceStub(
    identifier: RadioBroadcastServiceStub.$Identifier,
  ): Promise<purify.Either<Error, RadioBroadcastServiceStub>>;
  radioBroadcastServiceStubIdentifiers(
    query?: $ObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RadioBroadcastServiceStub.$Identifier[]>
  >;
  radioBroadcastServiceStubs(
    query?: $ObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioBroadcastServiceStub>[]>;
  radioBroadcastServiceStubsCount(
    query?: Pick<
      $ObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  radioEpisode(
    identifier: RadioEpisode.$Identifier,
  ): Promise<purify.Either<Error, RadioEpisode>>;
  radioEpisodeIdentifiers(
    query?: $ObjectSet.Query<RadioEpisode.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioEpisode.$Identifier[]>>;
  radioEpisodes(
    query?: $ObjectSet.Query<RadioEpisode.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioEpisode>[]>;
  radioEpisodesCount(
    query?: Pick<$ObjectSet.Query<RadioEpisode.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  radioEpisodeStub(
    identifier: RadioEpisodeStub.$Identifier,
  ): Promise<purify.Either<Error, RadioEpisodeStub>>;
  radioEpisodeStubIdentifiers(
    query?: $ObjectSet.Query<RadioEpisodeStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioEpisodeStub.$Identifier[]>>;
  radioEpisodeStubs(
    query?: $ObjectSet.Query<RadioEpisodeStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioEpisodeStub>[]>;
  radioEpisodeStubsCount(
    query?: Pick<$ObjectSet.Query<RadioEpisodeStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  radioSeries(
    identifier: RadioSeries.$Identifier,
  ): Promise<purify.Either<Error, RadioSeries>>;
  radioSeriesIdentifiers(
    query?: $ObjectSet.Query<RadioSeries.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioSeries.$Identifier[]>>;
  radioSeriess(
    query?: $ObjectSet.Query<RadioSeries.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioSeries>[]>;
  radioSeriessCount(
    query?: Pick<$ObjectSet.Query<RadioSeries.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  radioSeriesStub(
    identifier: RadioSeriesStub.$Identifier,
  ): Promise<purify.Either<Error, RadioSeriesStub>>;
  radioSeriesStubIdentifiers(
    query?: $ObjectSet.Query<RadioSeriesStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioSeriesStub.$Identifier[]>>;
  radioSeriesStubs(
    query?: $ObjectSet.Query<RadioSeriesStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioSeriesStub>[]>;
  radioSeriesStubsCount(
    query?: Pick<$ObjectSet.Query<RadioSeriesStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  report(identifier: Report.$Identifier): Promise<purify.Either<Error, Report>>;
  reportIdentifiers(
    query?: $ObjectSet.Query<Report.$Identifier>,
  ): Promise<purify.Either<Error, readonly Report.$Identifier[]>>;
  reports(
    query?: $ObjectSet.Query<Report.$Identifier>,
  ): Promise<readonly purify.Either<Error, Report>[]>;
  reportsCount(
    query?: Pick<$ObjectSet.Query<Report.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  reportStub(
    identifier: ReportStub.$Identifier,
  ): Promise<purify.Either<Error, ReportStub>>;
  reportStubIdentifiers(
    query?: $ObjectSet.Query<ReportStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ReportStub.$Identifier[]>>;
  reportStubs(
    query?: $ObjectSet.Query<ReportStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ReportStub>[]>;
  reportStubsCount(
    query?: Pick<$ObjectSet.Query<ReportStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  roleStub(
    identifier: RoleStub.$Identifier,
  ): Promise<purify.Either<Error, RoleStub>>;
  roleStubIdentifiers(
    query?: $ObjectSet.Query<RoleStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly RoleStub.$Identifier[]>>;
  roleStubs(
    query?: $ObjectSet.Query<RoleStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RoleStub>[]>;
  roleStubsCount(
    query?: Pick<$ObjectSet.Query<RoleStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  service(
    identifier: ServiceStatic.$Identifier,
  ): Promise<purify.Either<Error, Service>>;
  serviceIdentifiers(
    query?: $ObjectSet.Query<ServiceStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ServiceStatic.$Identifier[]>>;
  services(
    query?: $ObjectSet.Query<ServiceStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Service>[]>;
  servicesCount(
    query?: Pick<$ObjectSet.Query<ServiceStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  serviceStub(
    identifier: ServiceStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ServiceStub>>;
  serviceStubIdentifiers(
    query?: $ObjectSet.Query<ServiceStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ServiceStubStatic.$Identifier[]>>;
  serviceStubs(
    query?: $ObjectSet.Query<ServiceStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ServiceStub>[]>;
  serviceStubsCount(
    query?: Pick<$ObjectSet.Query<ServiceStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  structuredValue(
    identifier: StructuredValueStatic.$Identifier,
  ): Promise<purify.Either<Error, StructuredValue>>;
  structuredValueIdentifiers(
    query?: $ObjectSet.Query<StructuredValueStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly StructuredValueStatic.$Identifier[]>
  >;
  structuredValues(
    query?: $ObjectSet.Query<StructuredValueStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, StructuredValue>[]>;
  structuredValuesCount(
    query?: Pick<$ObjectSet.Query<StructuredValueStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  structuredValueStub(
    identifier: StructuredValueStubStatic.$Identifier,
  ): Promise<purify.Either<Error, StructuredValueStub>>;
  structuredValueStubIdentifiers(
    query?: $ObjectSet.Query<StructuredValueStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly StructuredValueStubStatic.$Identifier[]>
  >;
  structuredValueStubs(
    query?: $ObjectSet.Query<StructuredValueStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, StructuredValueStub>[]>;
  structuredValueStubsCount(
    query?: Pick<
      $ObjectSet.Query<StructuredValueStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>>;
  textObject(
    identifier: TextObject.$Identifier,
  ): Promise<purify.Either<Error, TextObject>>;
  textObjectIdentifiers(
    query?: $ObjectSet.Query<TextObject.$Identifier>,
  ): Promise<purify.Either<Error, readonly TextObject.$Identifier[]>>;
  textObjects(
    query?: $ObjectSet.Query<TextObject.$Identifier>,
  ): Promise<readonly purify.Either<Error, TextObject>[]>;
  textObjectsCount(
    query?: Pick<$ObjectSet.Query<TextObject.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  textObjectStub(
    identifier: TextObjectStub.$Identifier,
  ): Promise<purify.Either<Error, TextObjectStub>>;
  textObjectStubIdentifiers(
    query?: $ObjectSet.Query<TextObjectStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly TextObjectStub.$Identifier[]>>;
  textObjectStubs(
    query?: $ObjectSet.Query<TextObjectStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, TextObjectStub>[]>;
  textObjectStubsCount(
    query?: Pick<$ObjectSet.Query<TextObjectStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  thing(
    identifier: ThingStatic.$Identifier,
  ): Promise<purify.Either<Error, Thing>>;
  thingIdentifiers(
    query?: $ObjectSet.Query<ThingStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ThingStatic.$Identifier[]>>;
  things(
    query?: $ObjectSet.Query<ThingStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Thing>[]>;
  thingsCount(
    query?: Pick<$ObjectSet.Query<ThingStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  thingStub(
    identifier: ThingStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ThingStub>>;
  thingStubIdentifiers(
    query?: $ObjectSet.Query<ThingStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ThingStubStatic.$Identifier[]>>;
  thingStubs(
    query?: $ObjectSet.Query<ThingStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ThingStub>[]>;
  thingStubsCount(
    query?: Pick<$ObjectSet.Query<ThingStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  voteAction(
    identifier: VoteAction.$Identifier,
  ): Promise<purify.Either<Error, VoteAction>>;
  voteActionIdentifiers(
    query?: $ObjectSet.Query<VoteAction.$Identifier>,
  ): Promise<purify.Either<Error, readonly VoteAction.$Identifier[]>>;
  voteActions(
    query?: $ObjectSet.Query<VoteAction.$Identifier>,
  ): Promise<readonly purify.Either<Error, VoteAction>[]>;
  voteActionsCount(
    query?: Pick<$ObjectSet.Query<VoteAction.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  voteActionStub(
    identifier: VoteActionStub.$Identifier,
  ): Promise<purify.Either<Error, VoteActionStub>>;
  voteActionStubIdentifiers(
    query?: $ObjectSet.Query<VoteActionStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly VoteActionStub.$Identifier[]>>;
  voteActionStubs(
    query?: $ObjectSet.Query<VoteActionStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, VoteActionStub>[]>;
  voteActionStubsCount(
    query?: Pick<$ObjectSet.Query<VoteActionStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  agentStub(
    identifier: AgentStub.$Identifier,
  ): Promise<purify.Either<Error, AgentStub>>;
  agentStubIdentifiers(
    query?: $ObjectSet.Query<AgentStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly AgentStub.$Identifier[]>>;
  agentStubs(
    query?: $ObjectSet.Query<AgentStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, AgentStub>[]>;
  agentStubsCount(
    query?: Pick<$ObjectSet.Query<AgentStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
  musicArtistStub(
    identifier: MusicArtistStub.$Identifier,
  ): Promise<purify.Either<Error, MusicArtistStub>>;
  musicArtistStubIdentifiers(
    query?: $ObjectSet.Query<MusicArtistStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicArtistStub.$Identifier[]>>;
  musicArtistStubs(
    query?: $ObjectSet.Query<MusicArtistStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicArtistStub>[]>;
  musicArtistStubsCount(
    query?: Pick<$ObjectSet.Query<MusicArtistStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>>;
}

export namespace $ObjectSet {
  export type Query<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > = {
    readonly limit?: number;
    readonly offset?: number;
    readonly where?: Where<ObjectIdentifierT>;
  };
  export type Where<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > = {
    readonly identifiers: readonly ObjectIdentifierT[];
    readonly type: "identifiers";
  };
}

export class $RdfjsDatasetObjectSet implements $ObjectSet {
  readonly resourceSet: rdfjsResource.ResourceSet;

  constructor({ dataset }: { dataset: rdfjs.DatasetCore }) {
    this.resourceSet = new rdfjsResource.ResourceSet({ dataset });
  }

  async action(
    identifier: ActionStatic.$Identifier,
  ): Promise<purify.Either<Error, Action>> {
    return this.actionSync(identifier);
  }

  actionSync(
    identifier: ActionStatic.$Identifier,
  ): purify.Either<Error, Action> {
    return this.actionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async actionIdentifiers(
    query?: $ObjectSet.Query<ActionStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ActionStatic.$Identifier[]>> {
    return this.actionIdentifiersSync(query);
  }

  actionIdentifiersSync(
    query?: $ObjectSet.Query<ActionStatic.$Identifier>,
  ): purify.Either<Error, readonly ActionStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Action, ActionStatic.$Identifier>(
        ActionStatic,
        query,
      ),
    ]);
  }

  async actions(
    query?: $ObjectSet.Query<ActionStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Action>[]> {
    return this.actionsSync(query);
  }

  actionsSync(
    query?: $ObjectSet.Query<ActionStatic.$Identifier>,
  ): readonly purify.Either<Error, Action>[] {
    return [
      ...this.$objectsSync<Action, ActionStatic.$Identifier>(
        ActionStatic,
        query,
      ),
    ];
  }

  async actionsCount(
    query?: Pick<$ObjectSet.Query<ActionStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.actionsCountSync(query);
  }

  actionsCountSync(
    query?: Pick<$ObjectSet.Query<ActionStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Action, ActionStatic.$Identifier>(
      ActionStatic,
      query,
    );
  }

  async actionStub(
    identifier: ActionStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ActionStub>> {
    return this.actionStubSync(identifier);
  }

  actionStubSync(
    identifier: ActionStubStatic.$Identifier,
  ): purify.Either<Error, ActionStub> {
    return this.actionStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async actionStubIdentifiers(
    query?: $ObjectSet.Query<ActionStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ActionStubStatic.$Identifier[]>> {
    return this.actionStubIdentifiersSync(query);
  }

  actionStubIdentifiersSync(
    query?: $ObjectSet.Query<ActionStubStatic.$Identifier>,
  ): purify.Either<Error, readonly ActionStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<ActionStub, ActionStubStatic.$Identifier>(
        ActionStubStatic,
        query,
      ),
    ]);
  }

  async actionStubs(
    query?: $ObjectSet.Query<ActionStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ActionStub>[]> {
    return this.actionStubsSync(query);
  }

  actionStubsSync(
    query?: $ObjectSet.Query<ActionStubStatic.$Identifier>,
  ): readonly purify.Either<Error, ActionStub>[] {
    return [
      ...this.$objectsSync<ActionStub, ActionStubStatic.$Identifier>(
        ActionStubStatic,
        query,
      ),
    ];
  }

  async actionStubsCount(
    query?: Pick<$ObjectSet.Query<ActionStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.actionStubsCountSync(query);
  }

  actionStubsCountSync(
    query?: Pick<$ObjectSet.Query<ActionStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ActionStub, ActionStubStatic.$Identifier>(
      ActionStubStatic,
      query,
    );
  }

  async article(
    identifier: ArticleStatic.$Identifier,
  ): Promise<purify.Either<Error, Article>> {
    return this.articleSync(identifier);
  }

  articleSync(
    identifier: ArticleStatic.$Identifier,
  ): purify.Either<Error, Article> {
    return this.articlesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async articleIdentifiers(
    query?: $ObjectSet.Query<ArticleStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ArticleStatic.$Identifier[]>> {
    return this.articleIdentifiersSync(query);
  }

  articleIdentifiersSync(
    query?: $ObjectSet.Query<ArticleStatic.$Identifier>,
  ): purify.Either<Error, readonly ArticleStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Article, ArticleStatic.$Identifier>(
        ArticleStatic,
        query,
      ),
    ]);
  }

  async articles(
    query?: $ObjectSet.Query<ArticleStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Article>[]> {
    return this.articlesSync(query);
  }

  articlesSync(
    query?: $ObjectSet.Query<ArticleStatic.$Identifier>,
  ): readonly purify.Either<Error, Article>[] {
    return [
      ...this.$objectsSync<Article, ArticleStatic.$Identifier>(
        ArticleStatic,
        query,
      ),
    ];
  }

  async articlesCount(
    query?: Pick<$ObjectSet.Query<ArticleStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.articlesCountSync(query);
  }

  articlesCountSync(
    query?: Pick<$ObjectSet.Query<ArticleStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Article, ArticleStatic.$Identifier>(
      ArticleStatic,
      query,
    );
  }

  async articleStub(
    identifier: ArticleStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ArticleStub>> {
    return this.articleStubSync(identifier);
  }

  articleStubSync(
    identifier: ArticleStubStatic.$Identifier,
  ): purify.Either<Error, ArticleStub> {
    return this.articleStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async articleStubIdentifiers(
    query?: $ObjectSet.Query<ArticleStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ArticleStubStatic.$Identifier[]>> {
    return this.articleStubIdentifiersSync(query);
  }

  articleStubIdentifiersSync(
    query?: $ObjectSet.Query<ArticleStubStatic.$Identifier>,
  ): purify.Either<Error, readonly ArticleStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        ArticleStub,
        ArticleStubStatic.$Identifier
      >(ArticleStubStatic, query),
    ]);
  }

  async articleStubs(
    query?: $ObjectSet.Query<ArticleStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ArticleStub>[]> {
    return this.articleStubsSync(query);
  }

  articleStubsSync(
    query?: $ObjectSet.Query<ArticleStubStatic.$Identifier>,
  ): readonly purify.Either<Error, ArticleStub>[] {
    return [
      ...this.$objectsSync<ArticleStub, ArticleStubStatic.$Identifier>(
        ArticleStubStatic,
        query,
      ),
    ];
  }

  async articleStubsCount(
    query?: Pick<$ObjectSet.Query<ArticleStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.articleStubsCountSync(query);
  }

  articleStubsCountSync(
    query?: Pick<$ObjectSet.Query<ArticleStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ArticleStub, ArticleStubStatic.$Identifier>(
      ArticleStubStatic,
      query,
    );
  }

  async assessAction(
    identifier: AssessActionStatic.$Identifier,
  ): Promise<purify.Either<Error, AssessAction>> {
    return this.assessActionSync(identifier);
  }

  assessActionSync(
    identifier: AssessActionStatic.$Identifier,
  ): purify.Either<Error, AssessAction> {
    return this.assessActionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async assessActionIdentifiers(
    query?: $ObjectSet.Query<AssessActionStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly AssessActionStatic.$Identifier[]>> {
    return this.assessActionIdentifiersSync(query);
  }

  assessActionIdentifiersSync(
    query?: $ObjectSet.Query<AssessActionStatic.$Identifier>,
  ): purify.Either<Error, readonly AssessActionStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        AssessAction,
        AssessActionStatic.$Identifier
      >(AssessActionStatic, query),
    ]);
  }

  async assessActions(
    query?: $ObjectSet.Query<AssessActionStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, AssessAction>[]> {
    return this.assessActionsSync(query);
  }

  assessActionsSync(
    query?: $ObjectSet.Query<AssessActionStatic.$Identifier>,
  ): readonly purify.Either<Error, AssessAction>[] {
    return [
      ...this.$objectsSync<AssessAction, AssessActionStatic.$Identifier>(
        AssessActionStatic,
        query,
      ),
    ];
  }

  async assessActionsCount(
    query?: Pick<$ObjectSet.Query<AssessActionStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.assessActionsCountSync(query);
  }

  assessActionsCountSync(
    query?: Pick<$ObjectSet.Query<AssessActionStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<AssessAction, AssessActionStatic.$Identifier>(
      AssessActionStatic,
      query,
    );
  }

  async assessActionStub(
    identifier: AssessActionStubStatic.$Identifier,
  ): Promise<purify.Either<Error, AssessActionStub>> {
    return this.assessActionStubSync(identifier);
  }

  assessActionStubSync(
    identifier: AssessActionStubStatic.$Identifier,
  ): purify.Either<Error, AssessActionStub> {
    return this.assessActionStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async assessActionStubIdentifiers(
    query?: $ObjectSet.Query<AssessActionStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly AssessActionStubStatic.$Identifier[]>
  > {
    return this.assessActionStubIdentifiersSync(query);
  }

  assessActionStubIdentifiersSync(
    query?: $ObjectSet.Query<AssessActionStubStatic.$Identifier>,
  ): purify.Either<Error, readonly AssessActionStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        AssessActionStub,
        AssessActionStubStatic.$Identifier
      >(AssessActionStubStatic, query),
    ]);
  }

  async assessActionStubs(
    query?: $ObjectSet.Query<AssessActionStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, AssessActionStub>[]> {
    return this.assessActionStubsSync(query);
  }

  assessActionStubsSync(
    query?: $ObjectSet.Query<AssessActionStubStatic.$Identifier>,
  ): readonly purify.Either<Error, AssessActionStub>[] {
    return [
      ...this.$objectsSync<
        AssessActionStub,
        AssessActionStubStatic.$Identifier
      >(AssessActionStubStatic, query),
    ];
  }

  async assessActionStubsCount(
    query?: Pick<$ObjectSet.Query<AssessActionStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.assessActionStubsCountSync(query);
  }

  assessActionStubsCountSync(
    query?: Pick<$ObjectSet.Query<AssessActionStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      AssessActionStub,
      AssessActionStubStatic.$Identifier
    >(AssessActionStubStatic, query);
  }

  async broadcastEvent(
    identifier: BroadcastEvent.$Identifier,
  ): Promise<purify.Either<Error, BroadcastEvent>> {
    return this.broadcastEventSync(identifier);
  }

  broadcastEventSync(
    identifier: BroadcastEvent.$Identifier,
  ): purify.Either<Error, BroadcastEvent> {
    return this.broadcastEventsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async broadcastEventIdentifiers(
    query?: $ObjectSet.Query<BroadcastEvent.$Identifier>,
  ): Promise<purify.Either<Error, readonly BroadcastEvent.$Identifier[]>> {
    return this.broadcastEventIdentifiersSync(query);
  }

  broadcastEventIdentifiersSync(
    query?: $ObjectSet.Query<BroadcastEvent.$Identifier>,
  ): purify.Either<Error, readonly BroadcastEvent.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        BroadcastEvent,
        BroadcastEvent.$Identifier
      >(BroadcastEvent, query),
    ]);
  }

  async broadcastEvents(
    query?: $ObjectSet.Query<BroadcastEvent.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastEvent>[]> {
    return this.broadcastEventsSync(query);
  }

  broadcastEventsSync(
    query?: $ObjectSet.Query<BroadcastEvent.$Identifier>,
  ): readonly purify.Either<Error, BroadcastEvent>[] {
    return [
      ...this.$objectsSync<BroadcastEvent, BroadcastEvent.$Identifier>(
        BroadcastEvent,
        query,
      ),
    ];
  }

  async broadcastEventsCount(
    query?: Pick<$ObjectSet.Query<BroadcastEvent.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.broadcastEventsCountSync(query);
  }

  broadcastEventsCountSync(
    query?: Pick<$ObjectSet.Query<BroadcastEvent.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<BroadcastEvent, BroadcastEvent.$Identifier>(
      BroadcastEvent,
      query,
    );
  }

  async broadcastEventStub(
    identifier: BroadcastEventStub.$Identifier,
  ): Promise<purify.Either<Error, BroadcastEventStub>> {
    return this.broadcastEventStubSync(identifier);
  }

  broadcastEventStubSync(
    identifier: BroadcastEventStub.$Identifier,
  ): purify.Either<Error, BroadcastEventStub> {
    return this.broadcastEventStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async broadcastEventStubIdentifiers(
    query?: $ObjectSet.Query<BroadcastEventStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly BroadcastEventStub.$Identifier[]>> {
    return this.broadcastEventStubIdentifiersSync(query);
  }

  broadcastEventStubIdentifiersSync(
    query?: $ObjectSet.Query<BroadcastEventStub.$Identifier>,
  ): purify.Either<Error, readonly BroadcastEventStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        BroadcastEventStub,
        BroadcastEventStub.$Identifier
      >(BroadcastEventStub, query),
    ]);
  }

  async broadcastEventStubs(
    query?: $ObjectSet.Query<BroadcastEventStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastEventStub>[]> {
    return this.broadcastEventStubsSync(query);
  }

  broadcastEventStubsSync(
    query?: $ObjectSet.Query<BroadcastEventStub.$Identifier>,
  ): readonly purify.Either<Error, BroadcastEventStub>[] {
    return [
      ...this.$objectsSync<BroadcastEventStub, BroadcastEventStub.$Identifier>(
        BroadcastEventStub,
        query,
      ),
    ];
  }

  async broadcastEventStubsCount(
    query?: Pick<$ObjectSet.Query<BroadcastEventStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.broadcastEventStubsCountSync(query);
  }

  broadcastEventStubsCountSync(
    query?: Pick<$ObjectSet.Query<BroadcastEventStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      BroadcastEventStub,
      BroadcastEventStub.$Identifier
    >(BroadcastEventStub, query);
  }

  async broadcastService(
    identifier: BroadcastServiceStatic.$Identifier,
  ): Promise<purify.Either<Error, BroadcastService>> {
    return this.broadcastServiceSync(identifier);
  }

  broadcastServiceSync(
    identifier: BroadcastServiceStatic.$Identifier,
  ): purify.Either<Error, BroadcastService> {
    return this.broadcastServicesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async broadcastServiceIdentifiers(
    query?: $ObjectSet.Query<BroadcastServiceStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BroadcastServiceStatic.$Identifier[]>
  > {
    return this.broadcastServiceIdentifiersSync(query);
  }

  broadcastServiceIdentifiersSync(
    query?: $ObjectSet.Query<BroadcastServiceStatic.$Identifier>,
  ): purify.Either<Error, readonly BroadcastServiceStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        BroadcastService,
        BroadcastServiceStatic.$Identifier
      >(BroadcastServiceStatic, query),
    ]);
  }

  async broadcastServices(
    query?: $ObjectSet.Query<BroadcastServiceStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastService>[]> {
    return this.broadcastServicesSync(query);
  }

  broadcastServicesSync(
    query?: $ObjectSet.Query<BroadcastServiceStatic.$Identifier>,
  ): readonly purify.Either<Error, BroadcastService>[] {
    return [
      ...this.$objectsSync<
        BroadcastService,
        BroadcastServiceStatic.$Identifier
      >(BroadcastServiceStatic, query),
    ];
  }

  async broadcastServicesCount(
    query?: Pick<$ObjectSet.Query<BroadcastServiceStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.broadcastServicesCountSync(query);
  }

  broadcastServicesCountSync(
    query?: Pick<$ObjectSet.Query<BroadcastServiceStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      BroadcastService,
      BroadcastServiceStatic.$Identifier
    >(BroadcastServiceStatic, query);
  }

  async broadcastServiceStub(
    identifier: BroadcastServiceStubStatic.$Identifier,
  ): Promise<purify.Either<Error, BroadcastServiceStub>> {
    return this.broadcastServiceStubSync(identifier);
  }

  broadcastServiceStubSync(
    identifier: BroadcastServiceStubStatic.$Identifier,
  ): purify.Either<Error, BroadcastServiceStub> {
    return this.broadcastServiceStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async broadcastServiceStubIdentifiers(
    query?: $ObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BroadcastServiceStubStatic.$Identifier[]>
  > {
    return this.broadcastServiceStubIdentifiersSync(query);
  }

  broadcastServiceStubIdentifiersSync(
    query?: $ObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
  ): purify.Either<Error, readonly BroadcastServiceStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        BroadcastServiceStub,
        BroadcastServiceStubStatic.$Identifier
      >(BroadcastServiceStubStatic, query),
    ]);
  }

  async broadcastServiceStubs(
    query?: $ObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastServiceStub>[]> {
    return this.broadcastServiceStubsSync(query);
  }

  broadcastServiceStubsSync(
    query?: $ObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
  ): readonly purify.Either<Error, BroadcastServiceStub>[] {
    return [
      ...this.$objectsSync<
        BroadcastServiceStub,
        BroadcastServiceStubStatic.$Identifier
      >(BroadcastServiceStubStatic, query),
    ];
  }

  async broadcastServiceStubsCount(
    query?: Pick<
      $ObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.broadcastServiceStubsCountSync(query);
  }

  broadcastServiceStubsCountSync(
    query?: Pick<
      $ObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      BroadcastServiceStub,
      BroadcastServiceStubStatic.$Identifier
    >(BroadcastServiceStubStatic, query);
  }

  async chooseAction(
    identifier: ChooseActionStatic.$Identifier,
  ): Promise<purify.Either<Error, ChooseAction>> {
    return this.chooseActionSync(identifier);
  }

  chooseActionSync(
    identifier: ChooseActionStatic.$Identifier,
  ): purify.Either<Error, ChooseAction> {
    return this.chooseActionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async chooseActionIdentifiers(
    query?: $ObjectSet.Query<ChooseActionStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ChooseActionStatic.$Identifier[]>> {
    return this.chooseActionIdentifiersSync(query);
  }

  chooseActionIdentifiersSync(
    query?: $ObjectSet.Query<ChooseActionStatic.$Identifier>,
  ): purify.Either<Error, readonly ChooseActionStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        ChooseAction,
        ChooseActionStatic.$Identifier
      >(ChooseActionStatic, query),
    ]);
  }

  async chooseActions(
    query?: $ObjectSet.Query<ChooseActionStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ChooseAction>[]> {
    return this.chooseActionsSync(query);
  }

  chooseActionsSync(
    query?: $ObjectSet.Query<ChooseActionStatic.$Identifier>,
  ): readonly purify.Either<Error, ChooseAction>[] {
    return [
      ...this.$objectsSync<ChooseAction, ChooseActionStatic.$Identifier>(
        ChooseActionStatic,
        query,
      ),
    ];
  }

  async chooseActionsCount(
    query?: Pick<$ObjectSet.Query<ChooseActionStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.chooseActionsCountSync(query);
  }

  chooseActionsCountSync(
    query?: Pick<$ObjectSet.Query<ChooseActionStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ChooseAction, ChooseActionStatic.$Identifier>(
      ChooseActionStatic,
      query,
    );
  }

  async chooseActionStub(
    identifier: ChooseActionStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ChooseActionStub>> {
    return this.chooseActionStubSync(identifier);
  }

  chooseActionStubSync(
    identifier: ChooseActionStubStatic.$Identifier,
  ): purify.Either<Error, ChooseActionStub> {
    return this.chooseActionStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async chooseActionStubIdentifiers(
    query?: $ObjectSet.Query<ChooseActionStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ChooseActionStubStatic.$Identifier[]>
  > {
    return this.chooseActionStubIdentifiersSync(query);
  }

  chooseActionStubIdentifiersSync(
    query?: $ObjectSet.Query<ChooseActionStubStatic.$Identifier>,
  ): purify.Either<Error, readonly ChooseActionStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        ChooseActionStub,
        ChooseActionStubStatic.$Identifier
      >(ChooseActionStubStatic, query),
    ]);
  }

  async chooseActionStubs(
    query?: $ObjectSet.Query<ChooseActionStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ChooseActionStub>[]> {
    return this.chooseActionStubsSync(query);
  }

  chooseActionStubsSync(
    query?: $ObjectSet.Query<ChooseActionStubStatic.$Identifier>,
  ): readonly purify.Either<Error, ChooseActionStub>[] {
    return [
      ...this.$objectsSync<
        ChooseActionStub,
        ChooseActionStubStatic.$Identifier
      >(ChooseActionStubStatic, query),
    ];
  }

  async chooseActionStubsCount(
    query?: Pick<$ObjectSet.Query<ChooseActionStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.chooseActionStubsCountSync(query);
  }

  chooseActionStubsCountSync(
    query?: Pick<$ObjectSet.Query<ChooseActionStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      ChooseActionStub,
      ChooseActionStubStatic.$Identifier
    >(ChooseActionStubStatic, query);
  }

  async creativeWork(
    identifier: CreativeWorkStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWork>> {
    return this.creativeWorkSync(identifier);
  }

  creativeWorkSync(
    identifier: CreativeWorkStatic.$Identifier,
  ): purify.Either<Error, CreativeWork> {
    return this.creativeWorksSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async creativeWorkIdentifiers(
    query?: $ObjectSet.Query<CreativeWorkStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly CreativeWorkStatic.$Identifier[]>> {
    return this.creativeWorkIdentifiersSync(query);
  }

  creativeWorkIdentifiersSync(
    query?: $ObjectSet.Query<CreativeWorkStatic.$Identifier>,
  ): purify.Either<Error, readonly CreativeWorkStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        CreativeWork,
        CreativeWorkStatic.$Identifier
      >(CreativeWorkStatic, query),
    ]);
  }

  async creativeWorks(
    query?: $ObjectSet.Query<CreativeWorkStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWork>[]> {
    return this.creativeWorksSync(query);
  }

  creativeWorksSync(
    query?: $ObjectSet.Query<CreativeWorkStatic.$Identifier>,
  ): readonly purify.Either<Error, CreativeWork>[] {
    return [
      ...this.$objectsSync<CreativeWork, CreativeWorkStatic.$Identifier>(
        CreativeWorkStatic,
        query,
      ),
    ];
  }

  async creativeWorksCount(
    query?: Pick<$ObjectSet.Query<CreativeWorkStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.creativeWorksCountSync(query);
  }

  creativeWorksCountSync(
    query?: Pick<$ObjectSet.Query<CreativeWorkStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<CreativeWork, CreativeWorkStatic.$Identifier>(
      CreativeWorkStatic,
      query,
    );
  }

  async creativeWorkSeries(
    identifier: CreativeWorkSeriesStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWorkSeries>> {
    return this.creativeWorkSeriesSync(identifier);
  }

  creativeWorkSeriesSync(
    identifier: CreativeWorkSeriesStatic.$Identifier,
  ): purify.Either<Error, CreativeWorkSeries> {
    return this.creativeWorkSeriessSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async creativeWorkSeriesIdentifiers(
    query?: $ObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly CreativeWorkSeriesStatic.$Identifier[]>
  > {
    return this.creativeWorkSeriesIdentifiersSync(query);
  }

  creativeWorkSeriesIdentifiersSync(
    query?: $ObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
  ): purify.Either<Error, readonly CreativeWorkSeriesStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        CreativeWorkSeries,
        CreativeWorkSeriesStatic.$Identifier
      >(CreativeWorkSeriesStatic, query),
    ]);
  }

  async creativeWorkSeriess(
    query?: $ObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWorkSeries>[]> {
    return this.creativeWorkSeriessSync(query);
  }

  creativeWorkSeriessSync(
    query?: $ObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
  ): readonly purify.Either<Error, CreativeWorkSeries>[] {
    return [
      ...this.$objectsSync<
        CreativeWorkSeries,
        CreativeWorkSeriesStatic.$Identifier
      >(CreativeWorkSeriesStatic, query),
    ];
  }

  async creativeWorkSeriessCount(
    query?: Pick<
      $ObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.creativeWorkSeriessCountSync(query);
  }

  creativeWorkSeriessCountSync(
    query?: Pick<
      $ObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      CreativeWorkSeries,
      CreativeWorkSeriesStatic.$Identifier
    >(CreativeWorkSeriesStatic, query);
  }

  async creativeWorkSeriesStub(
    identifier: CreativeWorkSeriesStubStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWorkSeriesStub>> {
    return this.creativeWorkSeriesStubSync(identifier);
  }

  creativeWorkSeriesStubSync(
    identifier: CreativeWorkSeriesStubStatic.$Identifier,
  ): purify.Either<Error, CreativeWorkSeriesStub> {
    return this.creativeWorkSeriesStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async creativeWorkSeriesStubIdentifiers(
    query?: $ObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly CreativeWorkSeriesStubStatic.$Identifier[]>
  > {
    return this.creativeWorkSeriesStubIdentifiersSync(query);
  }

  creativeWorkSeriesStubIdentifiersSync(
    query?: $ObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
  ): purify.Either<Error, readonly CreativeWorkSeriesStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        CreativeWorkSeriesStub,
        CreativeWorkSeriesStubStatic.$Identifier
      >(CreativeWorkSeriesStubStatic, query),
    ]);
  }

  async creativeWorkSeriesStubs(
    query?: $ObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWorkSeriesStub>[]> {
    return this.creativeWorkSeriesStubsSync(query);
  }

  creativeWorkSeriesStubsSync(
    query?: $ObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
  ): readonly purify.Either<Error, CreativeWorkSeriesStub>[] {
    return [
      ...this.$objectsSync<
        CreativeWorkSeriesStub,
        CreativeWorkSeriesStubStatic.$Identifier
      >(CreativeWorkSeriesStubStatic, query),
    ];
  }

  async creativeWorkSeriesStubsCount(
    query?: Pick<
      $ObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.creativeWorkSeriesStubsCountSync(query);
  }

  creativeWorkSeriesStubsCountSync(
    query?: Pick<
      $ObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      CreativeWorkSeriesStub,
      CreativeWorkSeriesStubStatic.$Identifier
    >(CreativeWorkSeriesStubStatic, query);
  }

  async creativeWorkStub(
    identifier: CreativeWorkStubStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWorkStub>> {
    return this.creativeWorkStubSync(identifier);
  }

  creativeWorkStubSync(
    identifier: CreativeWorkStubStatic.$Identifier,
  ): purify.Either<Error, CreativeWorkStub> {
    return this.creativeWorkStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async creativeWorkStubIdentifiers(
    query?: $ObjectSet.Query<CreativeWorkStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly CreativeWorkStubStatic.$Identifier[]>
  > {
    return this.creativeWorkStubIdentifiersSync(query);
  }

  creativeWorkStubIdentifiersSync(
    query?: $ObjectSet.Query<CreativeWorkStubStatic.$Identifier>,
  ): purify.Either<Error, readonly CreativeWorkStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        CreativeWorkStub,
        CreativeWorkStubStatic.$Identifier
      >(CreativeWorkStubStatic, query),
    ]);
  }

  async creativeWorkStubs(
    query?: $ObjectSet.Query<CreativeWorkStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWorkStub>[]> {
    return this.creativeWorkStubsSync(query);
  }

  creativeWorkStubsSync(
    query?: $ObjectSet.Query<CreativeWorkStubStatic.$Identifier>,
  ): readonly purify.Either<Error, CreativeWorkStub>[] {
    return [
      ...this.$objectsSync<
        CreativeWorkStub,
        CreativeWorkStubStatic.$Identifier
      >(CreativeWorkStubStatic, query),
    ];
  }

  async creativeWorkStubsCount(
    query?: Pick<$ObjectSet.Query<CreativeWorkStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.creativeWorkStubsCountSync(query);
  }

  creativeWorkStubsCountSync(
    query?: Pick<$ObjectSet.Query<CreativeWorkStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      CreativeWorkStub,
      CreativeWorkStubStatic.$Identifier
    >(CreativeWorkStubStatic, query);
  }

  async enumeration(
    identifier: EnumerationStatic.$Identifier,
  ): Promise<purify.Either<Error, Enumeration>> {
    return this.enumerationSync(identifier);
  }

  enumerationSync(
    identifier: EnumerationStatic.$Identifier,
  ): purify.Either<Error, Enumeration> {
    return this.enumerationsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async enumerationIdentifiers(
    query?: $ObjectSet.Query<EnumerationStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EnumerationStatic.$Identifier[]>> {
    return this.enumerationIdentifiersSync(query);
  }

  enumerationIdentifiersSync(
    query?: $ObjectSet.Query<EnumerationStatic.$Identifier>,
  ): purify.Either<Error, readonly EnumerationStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        Enumeration,
        EnumerationStatic.$Identifier
      >(EnumerationStatic, query),
    ]);
  }

  async enumerations(
    query?: $ObjectSet.Query<EnumerationStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Enumeration>[]> {
    return this.enumerationsSync(query);
  }

  enumerationsSync(
    query?: $ObjectSet.Query<EnumerationStatic.$Identifier>,
  ): readonly purify.Either<Error, Enumeration>[] {
    return [
      ...this.$objectsSync<Enumeration, EnumerationStatic.$Identifier>(
        EnumerationStatic,
        query,
      ),
    ];
  }

  async enumerationsCount(
    query?: Pick<$ObjectSet.Query<EnumerationStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.enumerationsCountSync(query);
  }

  enumerationsCountSync(
    query?: Pick<$ObjectSet.Query<EnumerationStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Enumeration, EnumerationStatic.$Identifier>(
      EnumerationStatic,
      query,
    );
  }

  async episode(
    identifier: EpisodeStatic.$Identifier,
  ): Promise<purify.Either<Error, Episode>> {
    return this.episodeSync(identifier);
  }

  episodeSync(
    identifier: EpisodeStatic.$Identifier,
  ): purify.Either<Error, Episode> {
    return this.episodesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async episodeIdentifiers(
    query?: $ObjectSet.Query<EpisodeStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EpisodeStatic.$Identifier[]>> {
    return this.episodeIdentifiersSync(query);
  }

  episodeIdentifiersSync(
    query?: $ObjectSet.Query<EpisodeStatic.$Identifier>,
  ): purify.Either<Error, readonly EpisodeStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Episode, EpisodeStatic.$Identifier>(
        EpisodeStatic,
        query,
      ),
    ]);
  }

  async episodes(
    query?: $ObjectSet.Query<EpisodeStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Episode>[]> {
    return this.episodesSync(query);
  }

  episodesSync(
    query?: $ObjectSet.Query<EpisodeStatic.$Identifier>,
  ): readonly purify.Either<Error, Episode>[] {
    return [
      ...this.$objectsSync<Episode, EpisodeStatic.$Identifier>(
        EpisodeStatic,
        query,
      ),
    ];
  }

  async episodesCount(
    query?: Pick<$ObjectSet.Query<EpisodeStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.episodesCountSync(query);
  }

  episodesCountSync(
    query?: Pick<$ObjectSet.Query<EpisodeStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Episode, EpisodeStatic.$Identifier>(
      EpisodeStatic,
      query,
    );
  }

  async episodeStub(
    identifier: EpisodeStubStatic.$Identifier,
  ): Promise<purify.Either<Error, EpisodeStub>> {
    return this.episodeStubSync(identifier);
  }

  episodeStubSync(
    identifier: EpisodeStubStatic.$Identifier,
  ): purify.Either<Error, EpisodeStub> {
    return this.episodeStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async episodeStubIdentifiers(
    query?: $ObjectSet.Query<EpisodeStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EpisodeStubStatic.$Identifier[]>> {
    return this.episodeStubIdentifiersSync(query);
  }

  episodeStubIdentifiersSync(
    query?: $ObjectSet.Query<EpisodeStubStatic.$Identifier>,
  ): purify.Either<Error, readonly EpisodeStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        EpisodeStub,
        EpisodeStubStatic.$Identifier
      >(EpisodeStubStatic, query),
    ]);
  }

  async episodeStubs(
    query?: $ObjectSet.Query<EpisodeStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, EpisodeStub>[]> {
    return this.episodeStubsSync(query);
  }

  episodeStubsSync(
    query?: $ObjectSet.Query<EpisodeStubStatic.$Identifier>,
  ): readonly purify.Either<Error, EpisodeStub>[] {
    return [
      ...this.$objectsSync<EpisodeStub, EpisodeStubStatic.$Identifier>(
        EpisodeStubStatic,
        query,
      ),
    ];
  }

  async episodeStubsCount(
    query?: Pick<$ObjectSet.Query<EpisodeStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.episodeStubsCountSync(query);
  }

  episodeStubsCountSync(
    query?: Pick<$ObjectSet.Query<EpisodeStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<EpisodeStub, EpisodeStubStatic.$Identifier>(
      EpisodeStubStatic,
      query,
    );
  }

  async event(
    identifier: EventStatic.$Identifier,
  ): Promise<purify.Either<Error, Event>> {
    return this.eventSync(identifier);
  }

  eventSync(identifier: EventStatic.$Identifier): purify.Either<Error, Event> {
    return this.eventsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async eventIdentifiers(
    query?: $ObjectSet.Query<EventStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EventStatic.$Identifier[]>> {
    return this.eventIdentifiersSync(query);
  }

  eventIdentifiersSync(
    query?: $ObjectSet.Query<EventStatic.$Identifier>,
  ): purify.Either<Error, readonly EventStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Event, EventStatic.$Identifier>(
        EventStatic,
        query,
      ),
    ]);
  }

  async events(
    query?: $ObjectSet.Query<EventStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Event>[]> {
    return this.eventsSync(query);
  }

  eventsSync(
    query?: $ObjectSet.Query<EventStatic.$Identifier>,
  ): readonly purify.Either<Error, Event>[] {
    return [
      ...this.$objectsSync<Event, EventStatic.$Identifier>(EventStatic, query),
    ];
  }

  async eventsCount(
    query?: Pick<$ObjectSet.Query<EventStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.eventsCountSync(query);
  }

  eventsCountSync(
    query?: Pick<$ObjectSet.Query<EventStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Event, EventStatic.$Identifier>(
      EventStatic,
      query,
    );
  }

  async eventStub(
    identifier: EventStubStatic.$Identifier,
  ): Promise<purify.Either<Error, EventStub>> {
    return this.eventStubSync(identifier);
  }

  eventStubSync(
    identifier: EventStubStatic.$Identifier,
  ): purify.Either<Error, EventStub> {
    return this.eventStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async eventStubIdentifiers(
    query?: $ObjectSet.Query<EventStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EventStubStatic.$Identifier[]>> {
    return this.eventStubIdentifiersSync(query);
  }

  eventStubIdentifiersSync(
    query?: $ObjectSet.Query<EventStubStatic.$Identifier>,
  ): purify.Either<Error, readonly EventStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<EventStub, EventStubStatic.$Identifier>(
        EventStubStatic,
        query,
      ),
    ]);
  }

  async eventStubs(
    query?: $ObjectSet.Query<EventStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, EventStub>[]> {
    return this.eventStubsSync(query);
  }

  eventStubsSync(
    query?: $ObjectSet.Query<EventStubStatic.$Identifier>,
  ): readonly purify.Either<Error, EventStub>[] {
    return [
      ...this.$objectsSync<EventStub, EventStubStatic.$Identifier>(
        EventStubStatic,
        query,
      ),
    ];
  }

  async eventStubsCount(
    query?: Pick<$ObjectSet.Query<EventStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.eventStubsCountSync(query);
  }

  eventStubsCountSync(
    query?: Pick<$ObjectSet.Query<EventStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<EventStub, EventStubStatic.$Identifier>(
      EventStubStatic,
      query,
    );
  }

  async genderType(
    identifier: GenderType.$Identifier,
  ): Promise<purify.Either<Error, GenderType>> {
    return this.genderTypeSync(identifier);
  }

  genderTypeSync(
    identifier: GenderType.$Identifier,
  ): purify.Either<Error, GenderType> {
    return this.genderTypesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async genderTypeIdentifiers(
    query?: $ObjectSet.Query<GenderType.$Identifier>,
  ): Promise<purify.Either<Error, readonly GenderType.$Identifier[]>> {
    return this.genderTypeIdentifiersSync(query);
  }

  genderTypeIdentifiersSync(
    query?: $ObjectSet.Query<GenderType.$Identifier>,
  ): purify.Either<Error, readonly GenderType.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<GenderType, GenderType.$Identifier>(
        GenderType,
        query,
      ),
    ]);
  }

  async genderTypes(
    query?: $ObjectSet.Query<GenderType.$Identifier>,
  ): Promise<readonly purify.Either<Error, GenderType>[]> {
    return this.genderTypesSync(query);
  }

  genderTypesSync(
    query?: $ObjectSet.Query<GenderType.$Identifier>,
  ): readonly purify.Either<Error, GenderType>[] {
    return [
      ...this.$objectsSync<GenderType, GenderType.$Identifier>(
        GenderType,
        query,
      ),
    ];
  }

  async genderTypesCount(
    query?: Pick<$ObjectSet.Query<GenderType.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.genderTypesCountSync(query);
  }

  genderTypesCountSync(
    query?: Pick<$ObjectSet.Query<GenderType.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<GenderType, GenderType.$Identifier>(
      GenderType,
      query,
    );
  }

  async imageObject(
    identifier: ImageObject.$Identifier,
  ): Promise<purify.Either<Error, ImageObject>> {
    return this.imageObjectSync(identifier);
  }

  imageObjectSync(
    identifier: ImageObject.$Identifier,
  ): purify.Either<Error, ImageObject> {
    return this.imageObjectsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async imageObjectIdentifiers(
    query?: $ObjectSet.Query<ImageObject.$Identifier>,
  ): Promise<purify.Either<Error, readonly ImageObject.$Identifier[]>> {
    return this.imageObjectIdentifiersSync(query);
  }

  imageObjectIdentifiersSync(
    query?: $ObjectSet.Query<ImageObject.$Identifier>,
  ): purify.Either<Error, readonly ImageObject.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<ImageObject, ImageObject.$Identifier>(
        ImageObject,
        query,
      ),
    ]);
  }

  async imageObjects(
    query?: $ObjectSet.Query<ImageObject.$Identifier>,
  ): Promise<readonly purify.Either<Error, ImageObject>[]> {
    return this.imageObjectsSync(query);
  }

  imageObjectsSync(
    query?: $ObjectSet.Query<ImageObject.$Identifier>,
  ): readonly purify.Either<Error, ImageObject>[] {
    return [
      ...this.$objectsSync<ImageObject, ImageObject.$Identifier>(
        ImageObject,
        query,
      ),
    ];
  }

  async imageObjectsCount(
    query?: Pick<$ObjectSet.Query<ImageObject.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.imageObjectsCountSync(query);
  }

  imageObjectsCountSync(
    query?: Pick<$ObjectSet.Query<ImageObject.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ImageObject, ImageObject.$Identifier>(
      ImageObject,
      query,
    );
  }

  async imageObjectStub(
    identifier: ImageObjectStub.$Identifier,
  ): Promise<purify.Either<Error, ImageObjectStub>> {
    return this.imageObjectStubSync(identifier);
  }

  imageObjectStubSync(
    identifier: ImageObjectStub.$Identifier,
  ): purify.Either<Error, ImageObjectStub> {
    return this.imageObjectStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async imageObjectStubIdentifiers(
    query?: $ObjectSet.Query<ImageObjectStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ImageObjectStub.$Identifier[]>> {
    return this.imageObjectStubIdentifiersSync(query);
  }

  imageObjectStubIdentifiersSync(
    query?: $ObjectSet.Query<ImageObjectStub.$Identifier>,
  ): purify.Either<Error, readonly ImageObjectStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        ImageObjectStub,
        ImageObjectStub.$Identifier
      >(ImageObjectStub, query),
    ]);
  }

  async imageObjectStubs(
    query?: $ObjectSet.Query<ImageObjectStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ImageObjectStub>[]> {
    return this.imageObjectStubsSync(query);
  }

  imageObjectStubsSync(
    query?: $ObjectSet.Query<ImageObjectStub.$Identifier>,
  ): readonly purify.Either<Error, ImageObjectStub>[] {
    return [
      ...this.$objectsSync<ImageObjectStub, ImageObjectStub.$Identifier>(
        ImageObjectStub,
        query,
      ),
    ];
  }

  async imageObjectStubsCount(
    query?: Pick<$ObjectSet.Query<ImageObjectStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.imageObjectStubsCountSync(query);
  }

  imageObjectStubsCountSync(
    query?: Pick<$ObjectSet.Query<ImageObjectStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ImageObjectStub, ImageObjectStub.$Identifier>(
      ImageObjectStub,
      query,
    );
  }

  async intangible(
    identifier: IntangibleStatic.$Identifier,
  ): Promise<purify.Either<Error, Intangible>> {
    return this.intangibleSync(identifier);
  }

  intangibleSync(
    identifier: IntangibleStatic.$Identifier,
  ): purify.Either<Error, Intangible> {
    return this.intangiblesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async intangibleIdentifiers(
    query?: $ObjectSet.Query<IntangibleStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IntangibleStatic.$Identifier[]>> {
    return this.intangibleIdentifiersSync(query);
  }

  intangibleIdentifiersSync(
    query?: $ObjectSet.Query<IntangibleStatic.$Identifier>,
  ): purify.Either<Error, readonly IntangibleStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Intangible, IntangibleStatic.$Identifier>(
        IntangibleStatic,
        query,
      ),
    ]);
  }

  async intangibles(
    query?: $ObjectSet.Query<IntangibleStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Intangible>[]> {
    return this.intangiblesSync(query);
  }

  intangiblesSync(
    query?: $ObjectSet.Query<IntangibleStatic.$Identifier>,
  ): readonly purify.Either<Error, Intangible>[] {
    return [
      ...this.$objectsSync<Intangible, IntangibleStatic.$Identifier>(
        IntangibleStatic,
        query,
      ),
    ];
  }

  async intangiblesCount(
    query?: Pick<$ObjectSet.Query<IntangibleStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.intangiblesCountSync(query);
  }

  intangiblesCountSync(
    query?: Pick<$ObjectSet.Query<IntangibleStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Intangible, IntangibleStatic.$Identifier>(
      IntangibleStatic,
      query,
    );
  }

  async intangibleStub(
    identifier: IntangibleStubStatic.$Identifier,
  ): Promise<purify.Either<Error, IntangibleStub>> {
    return this.intangibleStubSync(identifier);
  }

  intangibleStubSync(
    identifier: IntangibleStubStatic.$Identifier,
  ): purify.Either<Error, IntangibleStub> {
    return this.intangibleStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async intangibleStubIdentifiers(
    query?: $ObjectSet.Query<IntangibleStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IntangibleStubStatic.$Identifier[]>
  > {
    return this.intangibleStubIdentifiersSync(query);
  }

  intangibleStubIdentifiersSync(
    query?: $ObjectSet.Query<IntangibleStubStatic.$Identifier>,
  ): purify.Either<Error, readonly IntangibleStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        IntangibleStub,
        IntangibleStubStatic.$Identifier
      >(IntangibleStubStatic, query),
    ]);
  }

  async intangibleStubs(
    query?: $ObjectSet.Query<IntangibleStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, IntangibleStub>[]> {
    return this.intangibleStubsSync(query);
  }

  intangibleStubsSync(
    query?: $ObjectSet.Query<IntangibleStubStatic.$Identifier>,
  ): readonly purify.Either<Error, IntangibleStub>[] {
    return [
      ...this.$objectsSync<IntangibleStub, IntangibleStubStatic.$Identifier>(
        IntangibleStubStatic,
        query,
      ),
    ];
  }

  async intangibleStubsCount(
    query?: Pick<$ObjectSet.Query<IntangibleStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.intangibleStubsCountSync(query);
  }

  intangibleStubsCountSync(
    query?: Pick<$ObjectSet.Query<IntangibleStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      IntangibleStub,
      IntangibleStubStatic.$Identifier
    >(IntangibleStubStatic, query);
  }

  async invoice(
    identifier: Invoice.$Identifier,
  ): Promise<purify.Either<Error, Invoice>> {
    return this.invoiceSync(identifier);
  }

  invoiceSync(identifier: Invoice.$Identifier): purify.Either<Error, Invoice> {
    return this.invoicesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async invoiceIdentifiers(
    query?: $ObjectSet.Query<Invoice.$Identifier>,
  ): Promise<purify.Either<Error, readonly Invoice.$Identifier[]>> {
    return this.invoiceIdentifiersSync(query);
  }

  invoiceIdentifiersSync(
    query?: $ObjectSet.Query<Invoice.$Identifier>,
  ): purify.Either<Error, readonly Invoice.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Invoice, Invoice.$Identifier>(
        Invoice,
        query,
      ),
    ]);
  }

  async invoices(
    query?: $ObjectSet.Query<Invoice.$Identifier>,
  ): Promise<readonly purify.Either<Error, Invoice>[]> {
    return this.invoicesSync(query);
  }

  invoicesSync(
    query?: $ObjectSet.Query<Invoice.$Identifier>,
  ): readonly purify.Either<Error, Invoice>[] {
    return [...this.$objectsSync<Invoice, Invoice.$Identifier>(Invoice, query)];
  }

  async invoicesCount(
    query?: Pick<$ObjectSet.Query<Invoice.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.invoicesCountSync(query);
  }

  invoicesCountSync(
    query?: Pick<$ObjectSet.Query<Invoice.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Invoice, Invoice.$Identifier>(Invoice, query);
  }

  async invoiceStub(
    identifier: InvoiceStub.$Identifier,
  ): Promise<purify.Either<Error, InvoiceStub>> {
    return this.invoiceStubSync(identifier);
  }

  invoiceStubSync(
    identifier: InvoiceStub.$Identifier,
  ): purify.Either<Error, InvoiceStub> {
    return this.invoiceStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async invoiceStubIdentifiers(
    query?: $ObjectSet.Query<InvoiceStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly InvoiceStub.$Identifier[]>> {
    return this.invoiceStubIdentifiersSync(query);
  }

  invoiceStubIdentifiersSync(
    query?: $ObjectSet.Query<InvoiceStub.$Identifier>,
  ): purify.Either<Error, readonly InvoiceStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<InvoiceStub, InvoiceStub.$Identifier>(
        InvoiceStub,
        query,
      ),
    ]);
  }

  async invoiceStubs(
    query?: $ObjectSet.Query<InvoiceStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, InvoiceStub>[]> {
    return this.invoiceStubsSync(query);
  }

  invoiceStubsSync(
    query?: $ObjectSet.Query<InvoiceStub.$Identifier>,
  ): readonly purify.Either<Error, InvoiceStub>[] {
    return [
      ...this.$objectsSync<InvoiceStub, InvoiceStub.$Identifier>(
        InvoiceStub,
        query,
      ),
    ];
  }

  async invoiceStubsCount(
    query?: Pick<$ObjectSet.Query<InvoiceStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.invoiceStubsCountSync(query);
  }

  invoiceStubsCountSync(
    query?: Pick<$ObjectSet.Query<InvoiceStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<InvoiceStub, InvoiceStub.$Identifier>(
      InvoiceStub,
      query,
    );
  }

  async itemList(
    identifier: ItemList.$Identifier,
  ): Promise<purify.Either<Error, ItemList>> {
    return this.itemListSync(identifier);
  }

  itemListSync(
    identifier: ItemList.$Identifier,
  ): purify.Either<Error, ItemList> {
    return this.itemListsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async itemListIdentifiers(
    query?: $ObjectSet.Query<ItemList.$Identifier>,
  ): Promise<purify.Either<Error, readonly ItemList.$Identifier[]>> {
    return this.itemListIdentifiersSync(query);
  }

  itemListIdentifiersSync(
    query?: $ObjectSet.Query<ItemList.$Identifier>,
  ): purify.Either<Error, readonly ItemList.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<ItemList, ItemList.$Identifier>(
        ItemList,
        query,
      ),
    ]);
  }

  async itemLists(
    query?: $ObjectSet.Query<ItemList.$Identifier>,
  ): Promise<readonly purify.Either<Error, ItemList>[]> {
    return this.itemListsSync(query);
  }

  itemListsSync(
    query?: $ObjectSet.Query<ItemList.$Identifier>,
  ): readonly purify.Either<Error, ItemList>[] {
    return [
      ...this.$objectsSync<ItemList, ItemList.$Identifier>(ItemList, query),
    ];
  }

  async itemListsCount(
    query?: Pick<$ObjectSet.Query<ItemList.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.itemListsCountSync(query);
  }

  itemListsCountSync(
    query?: Pick<$ObjectSet.Query<ItemList.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ItemList, ItemList.$Identifier>(
      ItemList,
      query,
    );
  }

  async itemListStub(
    identifier: ItemListStub.$Identifier,
  ): Promise<purify.Either<Error, ItemListStub>> {
    return this.itemListStubSync(identifier);
  }

  itemListStubSync(
    identifier: ItemListStub.$Identifier,
  ): purify.Either<Error, ItemListStub> {
    return this.itemListStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async itemListStubIdentifiers(
    query?: $ObjectSet.Query<ItemListStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ItemListStub.$Identifier[]>> {
    return this.itemListStubIdentifiersSync(query);
  }

  itemListStubIdentifiersSync(
    query?: $ObjectSet.Query<ItemListStub.$Identifier>,
  ): purify.Either<Error, readonly ItemListStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<ItemListStub, ItemListStub.$Identifier>(
        ItemListStub,
        query,
      ),
    ]);
  }

  async itemListStubs(
    query?: $ObjectSet.Query<ItemListStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ItemListStub>[]> {
    return this.itemListStubsSync(query);
  }

  itemListStubsSync(
    query?: $ObjectSet.Query<ItemListStub.$Identifier>,
  ): readonly purify.Either<Error, ItemListStub>[] {
    return [
      ...this.$objectsSync<ItemListStub, ItemListStub.$Identifier>(
        ItemListStub,
        query,
      ),
    ];
  }

  async itemListStubsCount(
    query?: Pick<$ObjectSet.Query<ItemListStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.itemListStubsCountSync(query);
  }

  itemListStubsCountSync(
    query?: Pick<$ObjectSet.Query<ItemListStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ItemListStub, ItemListStub.$Identifier>(
      ItemListStub,
      query,
    );
  }

  async listItem(
    identifier: ListItem.$Identifier,
  ): Promise<purify.Either<Error, ListItem>> {
    return this.listItemSync(identifier);
  }

  listItemSync(
    identifier: ListItem.$Identifier,
  ): purify.Either<Error, ListItem> {
    return this.listItemsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async listItemIdentifiers(
    query?: $ObjectSet.Query<ListItem.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListItem.$Identifier[]>> {
    return this.listItemIdentifiersSync(query);
  }

  listItemIdentifiersSync(
    query?: $ObjectSet.Query<ListItem.$Identifier>,
  ): purify.Either<Error, readonly ListItem.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<ListItem, ListItem.$Identifier>(
        ListItem,
        query,
      ),
    ]);
  }

  async listItems(
    query?: $ObjectSet.Query<ListItem.$Identifier>,
  ): Promise<readonly purify.Either<Error, ListItem>[]> {
    return this.listItemsSync(query);
  }

  listItemsSync(
    query?: $ObjectSet.Query<ListItem.$Identifier>,
  ): readonly purify.Either<Error, ListItem>[] {
    return [
      ...this.$objectsSync<ListItem, ListItem.$Identifier>(ListItem, query),
    ];
  }

  async listItemsCount(
    query?: Pick<$ObjectSet.Query<ListItem.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.listItemsCountSync(query);
  }

  listItemsCountSync(
    query?: Pick<$ObjectSet.Query<ListItem.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ListItem, ListItem.$Identifier>(
      ListItem,
      query,
    );
  }

  async listItemStub(
    identifier: ListItemStub.$Identifier,
  ): Promise<purify.Either<Error, ListItemStub>> {
    return this.listItemStubSync(identifier);
  }

  listItemStubSync(
    identifier: ListItemStub.$Identifier,
  ): purify.Either<Error, ListItemStub> {
    return this.listItemStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async listItemStubIdentifiers(
    query?: $ObjectSet.Query<ListItemStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListItemStub.$Identifier[]>> {
    return this.listItemStubIdentifiersSync(query);
  }

  listItemStubIdentifiersSync(
    query?: $ObjectSet.Query<ListItemStub.$Identifier>,
  ): purify.Either<Error, readonly ListItemStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<ListItemStub, ListItemStub.$Identifier>(
        ListItemStub,
        query,
      ),
    ]);
  }

  async listItemStubs(
    query?: $ObjectSet.Query<ListItemStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ListItemStub>[]> {
    return this.listItemStubsSync(query);
  }

  listItemStubsSync(
    query?: $ObjectSet.Query<ListItemStub.$Identifier>,
  ): readonly purify.Either<Error, ListItemStub>[] {
    return [
      ...this.$objectsSync<ListItemStub, ListItemStub.$Identifier>(
        ListItemStub,
        query,
      ),
    ];
  }

  async listItemStubsCount(
    query?: Pick<$ObjectSet.Query<ListItemStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.listItemStubsCountSync(query);
  }

  listItemStubsCountSync(
    query?: Pick<$ObjectSet.Query<ListItemStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ListItemStub, ListItemStub.$Identifier>(
      ListItemStub,
      query,
    );
  }

  async mediaObject(
    identifier: MediaObjectStatic.$Identifier,
  ): Promise<purify.Either<Error, MediaObject>> {
    return this.mediaObjectSync(identifier);
  }

  mediaObjectSync(
    identifier: MediaObjectStatic.$Identifier,
  ): purify.Either<Error, MediaObject> {
    return this.mediaObjectsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async mediaObjectIdentifiers(
    query?: $ObjectSet.Query<MediaObjectStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly MediaObjectStatic.$Identifier[]>> {
    return this.mediaObjectIdentifiersSync(query);
  }

  mediaObjectIdentifiersSync(
    query?: $ObjectSet.Query<MediaObjectStatic.$Identifier>,
  ): purify.Either<Error, readonly MediaObjectStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MediaObject,
        MediaObjectStatic.$Identifier
      >(MediaObjectStatic, query),
    ]);
  }

  async mediaObjects(
    query?: $ObjectSet.Query<MediaObjectStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, MediaObject>[]> {
    return this.mediaObjectsSync(query);
  }

  mediaObjectsSync(
    query?: $ObjectSet.Query<MediaObjectStatic.$Identifier>,
  ): readonly purify.Either<Error, MediaObject>[] {
    return [
      ...this.$objectsSync<MediaObject, MediaObjectStatic.$Identifier>(
        MediaObjectStatic,
        query,
      ),
    ];
  }

  async mediaObjectsCount(
    query?: Pick<$ObjectSet.Query<MediaObjectStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.mediaObjectsCountSync(query);
  }

  mediaObjectsCountSync(
    query?: Pick<$ObjectSet.Query<MediaObjectStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<MediaObject, MediaObjectStatic.$Identifier>(
      MediaObjectStatic,
      query,
    );
  }

  async mediaObjectStub(
    identifier: MediaObjectStubStatic.$Identifier,
  ): Promise<purify.Either<Error, MediaObjectStub>> {
    return this.mediaObjectStubSync(identifier);
  }

  mediaObjectStubSync(
    identifier: MediaObjectStubStatic.$Identifier,
  ): purify.Either<Error, MediaObjectStub> {
    return this.mediaObjectStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async mediaObjectStubIdentifiers(
    query?: $ObjectSet.Query<MediaObjectStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MediaObjectStubStatic.$Identifier[]>
  > {
    return this.mediaObjectStubIdentifiersSync(query);
  }

  mediaObjectStubIdentifiersSync(
    query?: $ObjectSet.Query<MediaObjectStubStatic.$Identifier>,
  ): purify.Either<Error, readonly MediaObjectStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MediaObjectStub,
        MediaObjectStubStatic.$Identifier
      >(MediaObjectStubStatic, query),
    ]);
  }

  async mediaObjectStubs(
    query?: $ObjectSet.Query<MediaObjectStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, MediaObjectStub>[]> {
    return this.mediaObjectStubsSync(query);
  }

  mediaObjectStubsSync(
    query?: $ObjectSet.Query<MediaObjectStubStatic.$Identifier>,
  ): readonly purify.Either<Error, MediaObjectStub>[] {
    return [
      ...this.$objectsSync<MediaObjectStub, MediaObjectStubStatic.$Identifier>(
        MediaObjectStubStatic,
        query,
      ),
    ];
  }

  async mediaObjectStubsCount(
    query?: Pick<$ObjectSet.Query<MediaObjectStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.mediaObjectStubsCountSync(query);
  }

  mediaObjectStubsCountSync(
    query?: Pick<$ObjectSet.Query<MediaObjectStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      MediaObjectStub,
      MediaObjectStubStatic.$Identifier
    >(MediaObjectStubStatic, query);
  }

  async message(
    identifier: Message.$Identifier,
  ): Promise<purify.Either<Error, Message>> {
    return this.messageSync(identifier);
  }

  messageSync(identifier: Message.$Identifier): purify.Either<Error, Message> {
    return this.messagesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async messageIdentifiers(
    query?: $ObjectSet.Query<Message.$Identifier>,
  ): Promise<purify.Either<Error, readonly Message.$Identifier[]>> {
    return this.messageIdentifiersSync(query);
  }

  messageIdentifiersSync(
    query?: $ObjectSet.Query<Message.$Identifier>,
  ): purify.Either<Error, readonly Message.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Message, Message.$Identifier>(
        Message,
        query,
      ),
    ]);
  }

  async messages(
    query?: $ObjectSet.Query<Message.$Identifier>,
  ): Promise<readonly purify.Either<Error, Message>[]> {
    return this.messagesSync(query);
  }

  messagesSync(
    query?: $ObjectSet.Query<Message.$Identifier>,
  ): readonly purify.Either<Error, Message>[] {
    return [...this.$objectsSync<Message, Message.$Identifier>(Message, query)];
  }

  async messagesCount(
    query?: Pick<$ObjectSet.Query<Message.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.messagesCountSync(query);
  }

  messagesCountSync(
    query?: Pick<$ObjectSet.Query<Message.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Message, Message.$Identifier>(Message, query);
  }

  async messageStub(
    identifier: MessageStub.$Identifier,
  ): Promise<purify.Either<Error, MessageStub>> {
    return this.messageStubSync(identifier);
  }

  messageStubSync(
    identifier: MessageStub.$Identifier,
  ): purify.Either<Error, MessageStub> {
    return this.messageStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async messageStubIdentifiers(
    query?: $ObjectSet.Query<MessageStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MessageStub.$Identifier[]>> {
    return this.messageStubIdentifiersSync(query);
  }

  messageStubIdentifiersSync(
    query?: $ObjectSet.Query<MessageStub.$Identifier>,
  ): purify.Either<Error, readonly MessageStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<MessageStub, MessageStub.$Identifier>(
        MessageStub,
        query,
      ),
    ]);
  }

  async messageStubs(
    query?: $ObjectSet.Query<MessageStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MessageStub>[]> {
    return this.messageStubsSync(query);
  }

  messageStubsSync(
    query?: $ObjectSet.Query<MessageStub.$Identifier>,
  ): readonly purify.Either<Error, MessageStub>[] {
    return [
      ...this.$objectsSync<MessageStub, MessageStub.$Identifier>(
        MessageStub,
        query,
      ),
    ];
  }

  async messageStubsCount(
    query?: Pick<$ObjectSet.Query<MessageStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.messageStubsCountSync(query);
  }

  messageStubsCountSync(
    query?: Pick<$ObjectSet.Query<MessageStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<MessageStub, MessageStub.$Identifier>(
      MessageStub,
      query,
    );
  }

  async monetaryAmount(
    identifier: MonetaryAmount.$Identifier,
  ): Promise<purify.Either<Error, MonetaryAmount>> {
    return this.monetaryAmountSync(identifier);
  }

  monetaryAmountSync(
    identifier: MonetaryAmount.$Identifier,
  ): purify.Either<Error, MonetaryAmount> {
    return this.monetaryAmountsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async monetaryAmountIdentifiers(
    query?: $ObjectSet.Query<MonetaryAmount.$Identifier>,
  ): Promise<purify.Either<Error, readonly MonetaryAmount.$Identifier[]>> {
    return this.monetaryAmountIdentifiersSync(query);
  }

  monetaryAmountIdentifiersSync(
    query?: $ObjectSet.Query<MonetaryAmount.$Identifier>,
  ): purify.Either<Error, readonly MonetaryAmount.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MonetaryAmount,
        MonetaryAmount.$Identifier
      >(MonetaryAmount, query),
    ]);
  }

  async monetaryAmounts(
    query?: $ObjectSet.Query<MonetaryAmount.$Identifier>,
  ): Promise<readonly purify.Either<Error, MonetaryAmount>[]> {
    return this.monetaryAmountsSync(query);
  }

  monetaryAmountsSync(
    query?: $ObjectSet.Query<MonetaryAmount.$Identifier>,
  ): readonly purify.Either<Error, MonetaryAmount>[] {
    return [
      ...this.$objectsSync<MonetaryAmount, MonetaryAmount.$Identifier>(
        MonetaryAmount,
        query,
      ),
    ];
  }

  async monetaryAmountsCount(
    query?: Pick<$ObjectSet.Query<MonetaryAmount.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.monetaryAmountsCountSync(query);
  }

  monetaryAmountsCountSync(
    query?: Pick<$ObjectSet.Query<MonetaryAmount.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<MonetaryAmount, MonetaryAmount.$Identifier>(
      MonetaryAmount,
      query,
    );
  }

  async monetaryAmountStub(
    identifier: MonetaryAmountStub.$Identifier,
  ): Promise<purify.Either<Error, MonetaryAmountStub>> {
    return this.monetaryAmountStubSync(identifier);
  }

  monetaryAmountStubSync(
    identifier: MonetaryAmountStub.$Identifier,
  ): purify.Either<Error, MonetaryAmountStub> {
    return this.monetaryAmountStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async monetaryAmountStubIdentifiers(
    query?: $ObjectSet.Query<MonetaryAmountStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MonetaryAmountStub.$Identifier[]>> {
    return this.monetaryAmountStubIdentifiersSync(query);
  }

  monetaryAmountStubIdentifiersSync(
    query?: $ObjectSet.Query<MonetaryAmountStub.$Identifier>,
  ): purify.Either<Error, readonly MonetaryAmountStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MonetaryAmountStub,
        MonetaryAmountStub.$Identifier
      >(MonetaryAmountStub, query),
    ]);
  }

  async monetaryAmountStubs(
    query?: $ObjectSet.Query<MonetaryAmountStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MonetaryAmountStub>[]> {
    return this.monetaryAmountStubsSync(query);
  }

  monetaryAmountStubsSync(
    query?: $ObjectSet.Query<MonetaryAmountStub.$Identifier>,
  ): readonly purify.Either<Error, MonetaryAmountStub>[] {
    return [
      ...this.$objectsSync<MonetaryAmountStub, MonetaryAmountStub.$Identifier>(
        MonetaryAmountStub,
        query,
      ),
    ];
  }

  async monetaryAmountStubsCount(
    query?: Pick<$ObjectSet.Query<MonetaryAmountStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.monetaryAmountStubsCountSync(query);
  }

  monetaryAmountStubsCountSync(
    query?: Pick<$ObjectSet.Query<MonetaryAmountStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      MonetaryAmountStub,
      MonetaryAmountStub.$Identifier
    >(MonetaryAmountStub, query);
  }

  async musicAlbum(
    identifier: MusicAlbum.$Identifier,
  ): Promise<purify.Either<Error, MusicAlbum>> {
    return this.musicAlbumSync(identifier);
  }

  musicAlbumSync(
    identifier: MusicAlbum.$Identifier,
  ): purify.Either<Error, MusicAlbum> {
    return this.musicAlbumsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicAlbumIdentifiers(
    query?: $ObjectSet.Query<MusicAlbum.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicAlbum.$Identifier[]>> {
    return this.musicAlbumIdentifiersSync(query);
  }

  musicAlbumIdentifiersSync(
    query?: $ObjectSet.Query<MusicAlbum.$Identifier>,
  ): purify.Either<Error, readonly MusicAlbum.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<MusicAlbum, MusicAlbum.$Identifier>(
        MusicAlbum,
        query,
      ),
    ]);
  }

  async musicAlbums(
    query?: $ObjectSet.Query<MusicAlbum.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicAlbum>[]> {
    return this.musicAlbumsSync(query);
  }

  musicAlbumsSync(
    query?: $ObjectSet.Query<MusicAlbum.$Identifier>,
  ): readonly purify.Either<Error, MusicAlbum>[] {
    return [
      ...this.$objectsSync<MusicAlbum, MusicAlbum.$Identifier>(
        MusicAlbum,
        query,
      ),
    ];
  }

  async musicAlbumsCount(
    query?: Pick<$ObjectSet.Query<MusicAlbum.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicAlbumsCountSync(query);
  }

  musicAlbumsCountSync(
    query?: Pick<$ObjectSet.Query<MusicAlbum.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<MusicAlbum, MusicAlbum.$Identifier>(
      MusicAlbum,
      query,
    );
  }

  async musicAlbumStub(
    identifier: MusicAlbumStub.$Identifier,
  ): Promise<purify.Either<Error, MusicAlbumStub>> {
    return this.musicAlbumStubSync(identifier);
  }

  musicAlbumStubSync(
    identifier: MusicAlbumStub.$Identifier,
  ): purify.Either<Error, MusicAlbumStub> {
    return this.musicAlbumStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicAlbumStubIdentifiers(
    query?: $ObjectSet.Query<MusicAlbumStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicAlbumStub.$Identifier[]>> {
    return this.musicAlbumStubIdentifiersSync(query);
  }

  musicAlbumStubIdentifiersSync(
    query?: $ObjectSet.Query<MusicAlbumStub.$Identifier>,
  ): purify.Either<Error, readonly MusicAlbumStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MusicAlbumStub,
        MusicAlbumStub.$Identifier
      >(MusicAlbumStub, query),
    ]);
  }

  async musicAlbumStubs(
    query?: $ObjectSet.Query<MusicAlbumStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicAlbumStub>[]> {
    return this.musicAlbumStubsSync(query);
  }

  musicAlbumStubsSync(
    query?: $ObjectSet.Query<MusicAlbumStub.$Identifier>,
  ): readonly purify.Either<Error, MusicAlbumStub>[] {
    return [
      ...this.$objectsSync<MusicAlbumStub, MusicAlbumStub.$Identifier>(
        MusicAlbumStub,
        query,
      ),
    ];
  }

  async musicAlbumStubsCount(
    query?: Pick<$ObjectSet.Query<MusicAlbumStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicAlbumStubsCountSync(query);
  }

  musicAlbumStubsCountSync(
    query?: Pick<$ObjectSet.Query<MusicAlbumStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<MusicAlbumStub, MusicAlbumStub.$Identifier>(
      MusicAlbumStub,
      query,
    );
  }

  async musicArtistRoleStub(
    identifier: MusicArtistRoleStub.$Identifier,
  ): Promise<purify.Either<Error, MusicArtistRoleStub>> {
    return this.musicArtistRoleStubSync(identifier);
  }

  musicArtistRoleStubSync(
    identifier: MusicArtistRoleStub.$Identifier,
  ): purify.Either<Error, MusicArtistRoleStub> {
    return this.musicArtistRoleStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicArtistRoleStubIdentifiers(
    query?: $ObjectSet.Query<MusicArtistRoleStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicArtistRoleStub.$Identifier[]>> {
    return this.musicArtistRoleStubIdentifiersSync(query);
  }

  musicArtistRoleStubIdentifiersSync(
    query?: $ObjectSet.Query<MusicArtistRoleStub.$Identifier>,
  ): purify.Either<Error, readonly MusicArtistRoleStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MusicArtistRoleStub,
        MusicArtistRoleStub.$Identifier
      >(MusicArtistRoleStub, query),
    ]);
  }

  async musicArtistRoleStubs(
    query?: $ObjectSet.Query<MusicArtistRoleStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicArtistRoleStub>[]> {
    return this.musicArtistRoleStubsSync(query);
  }

  musicArtistRoleStubsSync(
    query?: $ObjectSet.Query<MusicArtistRoleStub.$Identifier>,
  ): readonly purify.Either<Error, MusicArtistRoleStub>[] {
    return [
      ...this.$objectsSync<
        MusicArtistRoleStub,
        MusicArtistRoleStub.$Identifier
      >(MusicArtistRoleStub, query),
    ];
  }

  async musicArtistRoleStubsCount(
    query?: Pick<$ObjectSet.Query<MusicArtistRoleStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicArtistRoleStubsCountSync(query);
  }

  musicArtistRoleStubsCountSync(
    query?: Pick<$ObjectSet.Query<MusicArtistRoleStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      MusicArtistRoleStub,
      MusicArtistRoleStub.$Identifier
    >(MusicArtistRoleStub, query);
  }

  async musicComposition(
    identifier: MusicComposition.$Identifier,
  ): Promise<purify.Either<Error, MusicComposition>> {
    return this.musicCompositionSync(identifier);
  }

  musicCompositionSync(
    identifier: MusicComposition.$Identifier,
  ): purify.Either<Error, MusicComposition> {
    return this.musicCompositionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicCompositionIdentifiers(
    query?: $ObjectSet.Query<MusicComposition.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicComposition.$Identifier[]>> {
    return this.musicCompositionIdentifiersSync(query);
  }

  musicCompositionIdentifiersSync(
    query?: $ObjectSet.Query<MusicComposition.$Identifier>,
  ): purify.Either<Error, readonly MusicComposition.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MusicComposition,
        MusicComposition.$Identifier
      >(MusicComposition, query),
    ]);
  }

  async musicCompositions(
    query?: $ObjectSet.Query<MusicComposition.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicComposition>[]> {
    return this.musicCompositionsSync(query);
  }

  musicCompositionsSync(
    query?: $ObjectSet.Query<MusicComposition.$Identifier>,
  ): readonly purify.Either<Error, MusicComposition>[] {
    return [
      ...this.$objectsSync<MusicComposition, MusicComposition.$Identifier>(
        MusicComposition,
        query,
      ),
    ];
  }

  async musicCompositionsCount(
    query?: Pick<$ObjectSet.Query<MusicComposition.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicCompositionsCountSync(query);
  }

  musicCompositionsCountSync(
    query?: Pick<$ObjectSet.Query<MusicComposition.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      MusicComposition,
      MusicComposition.$Identifier
    >(MusicComposition, query);
  }

  async musicCompositionStub(
    identifier: MusicCompositionStub.$Identifier,
  ): Promise<purify.Either<Error, MusicCompositionStub>> {
    return this.musicCompositionStubSync(identifier);
  }

  musicCompositionStubSync(
    identifier: MusicCompositionStub.$Identifier,
  ): purify.Either<Error, MusicCompositionStub> {
    return this.musicCompositionStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicCompositionStubIdentifiers(
    query?: $ObjectSet.Query<MusicCompositionStub.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MusicCompositionStub.$Identifier[]>
  > {
    return this.musicCompositionStubIdentifiersSync(query);
  }

  musicCompositionStubIdentifiersSync(
    query?: $ObjectSet.Query<MusicCompositionStub.$Identifier>,
  ): purify.Either<Error, readonly MusicCompositionStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MusicCompositionStub,
        MusicCompositionStub.$Identifier
      >(MusicCompositionStub, query),
    ]);
  }

  async musicCompositionStubs(
    query?: $ObjectSet.Query<MusicCompositionStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicCompositionStub>[]> {
    return this.musicCompositionStubsSync(query);
  }

  musicCompositionStubsSync(
    query?: $ObjectSet.Query<MusicCompositionStub.$Identifier>,
  ): readonly purify.Either<Error, MusicCompositionStub>[] {
    return [
      ...this.$objectsSync<
        MusicCompositionStub,
        MusicCompositionStub.$Identifier
      >(MusicCompositionStub, query),
    ];
  }

  async musicCompositionStubsCount(
    query?: Pick<$ObjectSet.Query<MusicCompositionStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicCompositionStubsCountSync(query);
  }

  musicCompositionStubsCountSync(
    query?: Pick<$ObjectSet.Query<MusicCompositionStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      MusicCompositionStub,
      MusicCompositionStub.$Identifier
    >(MusicCompositionStub, query);
  }

  async musicGroup(
    identifier: MusicGroup.$Identifier,
  ): Promise<purify.Either<Error, MusicGroup>> {
    return this.musicGroupSync(identifier);
  }

  musicGroupSync(
    identifier: MusicGroup.$Identifier,
  ): purify.Either<Error, MusicGroup> {
    return this.musicGroupsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicGroupIdentifiers(
    query?: $ObjectSet.Query<MusicGroup.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicGroup.$Identifier[]>> {
    return this.musicGroupIdentifiersSync(query);
  }

  musicGroupIdentifiersSync(
    query?: $ObjectSet.Query<MusicGroup.$Identifier>,
  ): purify.Either<Error, readonly MusicGroup.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<MusicGroup, MusicGroup.$Identifier>(
        MusicGroup,
        query,
      ),
    ]);
  }

  async musicGroups(
    query?: $ObjectSet.Query<MusicGroup.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicGroup>[]> {
    return this.musicGroupsSync(query);
  }

  musicGroupsSync(
    query?: $ObjectSet.Query<MusicGroup.$Identifier>,
  ): readonly purify.Either<Error, MusicGroup>[] {
    return [
      ...this.$objectsSync<MusicGroup, MusicGroup.$Identifier>(
        MusicGroup,
        query,
      ),
    ];
  }

  async musicGroupsCount(
    query?: Pick<$ObjectSet.Query<MusicGroup.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicGroupsCountSync(query);
  }

  musicGroupsCountSync(
    query?: Pick<$ObjectSet.Query<MusicGroup.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<MusicGroup, MusicGroup.$Identifier>(
      MusicGroup,
      query,
    );
  }

  async musicGroupStub(
    identifier: MusicGroupStub.$Identifier,
  ): Promise<purify.Either<Error, MusicGroupStub>> {
    return this.musicGroupStubSync(identifier);
  }

  musicGroupStubSync(
    identifier: MusicGroupStub.$Identifier,
  ): purify.Either<Error, MusicGroupStub> {
    return this.musicGroupStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicGroupStubIdentifiers(
    query?: $ObjectSet.Query<MusicGroupStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicGroupStub.$Identifier[]>> {
    return this.musicGroupStubIdentifiersSync(query);
  }

  musicGroupStubIdentifiersSync(
    query?: $ObjectSet.Query<MusicGroupStub.$Identifier>,
  ): purify.Either<Error, readonly MusicGroupStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MusicGroupStub,
        MusicGroupStub.$Identifier
      >(MusicGroupStub, query),
    ]);
  }

  async musicGroupStubs(
    query?: $ObjectSet.Query<MusicGroupStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicGroupStub>[]> {
    return this.musicGroupStubsSync(query);
  }

  musicGroupStubsSync(
    query?: $ObjectSet.Query<MusicGroupStub.$Identifier>,
  ): readonly purify.Either<Error, MusicGroupStub>[] {
    return [
      ...this.$objectsSync<MusicGroupStub, MusicGroupStub.$Identifier>(
        MusicGroupStub,
        query,
      ),
    ];
  }

  async musicGroupStubsCount(
    query?: Pick<$ObjectSet.Query<MusicGroupStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicGroupStubsCountSync(query);
  }

  musicGroupStubsCountSync(
    query?: Pick<$ObjectSet.Query<MusicGroupStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<MusicGroupStub, MusicGroupStub.$Identifier>(
      MusicGroupStub,
      query,
    );
  }

  async musicPlaylist(
    identifier: MusicPlaylist.$Identifier,
  ): Promise<purify.Either<Error, MusicPlaylist>> {
    return this.musicPlaylistSync(identifier);
  }

  musicPlaylistSync(
    identifier: MusicPlaylist.$Identifier,
  ): purify.Either<Error, MusicPlaylist> {
    return this.musicPlaylistsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicPlaylistIdentifiers(
    query?: $ObjectSet.Query<MusicPlaylist.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicPlaylist.$Identifier[]>> {
    return this.musicPlaylistIdentifiersSync(query);
  }

  musicPlaylistIdentifiersSync(
    query?: $ObjectSet.Query<MusicPlaylist.$Identifier>,
  ): purify.Either<Error, readonly MusicPlaylist.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<MusicPlaylist, MusicPlaylist.$Identifier>(
        MusicPlaylist,
        query,
      ),
    ]);
  }

  async musicPlaylists(
    query?: $ObjectSet.Query<MusicPlaylist.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicPlaylist>[]> {
    return this.musicPlaylistsSync(query);
  }

  musicPlaylistsSync(
    query?: $ObjectSet.Query<MusicPlaylist.$Identifier>,
  ): readonly purify.Either<Error, MusicPlaylist>[] {
    return [
      ...this.$objectsSync<MusicPlaylist, MusicPlaylist.$Identifier>(
        MusicPlaylist,
        query,
      ),
    ];
  }

  async musicPlaylistsCount(
    query?: Pick<$ObjectSet.Query<MusicPlaylist.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicPlaylistsCountSync(query);
  }

  musicPlaylistsCountSync(
    query?: Pick<$ObjectSet.Query<MusicPlaylist.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<MusicPlaylist, MusicPlaylist.$Identifier>(
      MusicPlaylist,
      query,
    );
  }

  async musicPlaylistStub(
    identifier: MusicPlaylistStub.$Identifier,
  ): Promise<purify.Either<Error, MusicPlaylistStub>> {
    return this.musicPlaylistStubSync(identifier);
  }

  musicPlaylistStubSync(
    identifier: MusicPlaylistStub.$Identifier,
  ): purify.Either<Error, MusicPlaylistStub> {
    return this.musicPlaylistStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicPlaylistStubIdentifiers(
    query?: $ObjectSet.Query<MusicPlaylistStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicPlaylistStub.$Identifier[]>> {
    return this.musicPlaylistStubIdentifiersSync(query);
  }

  musicPlaylistStubIdentifiersSync(
    query?: $ObjectSet.Query<MusicPlaylistStub.$Identifier>,
  ): purify.Either<Error, readonly MusicPlaylistStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MusicPlaylistStub,
        MusicPlaylistStub.$Identifier
      >(MusicPlaylistStub, query),
    ]);
  }

  async musicPlaylistStubs(
    query?: $ObjectSet.Query<MusicPlaylistStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicPlaylistStub>[]> {
    return this.musicPlaylistStubsSync(query);
  }

  musicPlaylistStubsSync(
    query?: $ObjectSet.Query<MusicPlaylistStub.$Identifier>,
  ): readonly purify.Either<Error, MusicPlaylistStub>[] {
    return [
      ...this.$objectsSync<MusicPlaylistStub, MusicPlaylistStub.$Identifier>(
        MusicPlaylistStub,
        query,
      ),
    ];
  }

  async musicPlaylistStubsCount(
    query?: Pick<$ObjectSet.Query<MusicPlaylistStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicPlaylistStubsCountSync(query);
  }

  musicPlaylistStubsCountSync(
    query?: Pick<$ObjectSet.Query<MusicPlaylistStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      MusicPlaylistStub,
      MusicPlaylistStub.$Identifier
    >(MusicPlaylistStub, query);
  }

  async musicRecording(
    identifier: MusicRecording.$Identifier,
  ): Promise<purify.Either<Error, MusicRecording>> {
    return this.musicRecordingSync(identifier);
  }

  musicRecordingSync(
    identifier: MusicRecording.$Identifier,
  ): purify.Either<Error, MusicRecording> {
    return this.musicRecordingsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicRecordingIdentifiers(
    query?: $ObjectSet.Query<MusicRecording.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicRecording.$Identifier[]>> {
    return this.musicRecordingIdentifiersSync(query);
  }

  musicRecordingIdentifiersSync(
    query?: $ObjectSet.Query<MusicRecording.$Identifier>,
  ): purify.Either<Error, readonly MusicRecording.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MusicRecording,
        MusicRecording.$Identifier
      >(MusicRecording, query),
    ]);
  }

  async musicRecordings(
    query?: $ObjectSet.Query<MusicRecording.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicRecording>[]> {
    return this.musicRecordingsSync(query);
  }

  musicRecordingsSync(
    query?: $ObjectSet.Query<MusicRecording.$Identifier>,
  ): readonly purify.Either<Error, MusicRecording>[] {
    return [
      ...this.$objectsSync<MusicRecording, MusicRecording.$Identifier>(
        MusicRecording,
        query,
      ),
    ];
  }

  async musicRecordingsCount(
    query?: Pick<$ObjectSet.Query<MusicRecording.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicRecordingsCountSync(query);
  }

  musicRecordingsCountSync(
    query?: Pick<$ObjectSet.Query<MusicRecording.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<MusicRecording, MusicRecording.$Identifier>(
      MusicRecording,
      query,
    );
  }

  async musicRecordingStub(
    identifier: MusicRecordingStub.$Identifier,
  ): Promise<purify.Either<Error, MusicRecordingStub>> {
    return this.musicRecordingStubSync(identifier);
  }

  musicRecordingStubSync(
    identifier: MusicRecordingStub.$Identifier,
  ): purify.Either<Error, MusicRecordingStub> {
    return this.musicRecordingStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicRecordingStubIdentifiers(
    query?: $ObjectSet.Query<MusicRecordingStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicRecordingStub.$Identifier[]>> {
    return this.musicRecordingStubIdentifiersSync(query);
  }

  musicRecordingStubIdentifiersSync(
    query?: $ObjectSet.Query<MusicRecordingStub.$Identifier>,
  ): purify.Either<Error, readonly MusicRecordingStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        MusicRecordingStub,
        MusicRecordingStub.$Identifier
      >(MusicRecordingStub, query),
    ]);
  }

  async musicRecordingStubs(
    query?: $ObjectSet.Query<MusicRecordingStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicRecordingStub>[]> {
    return this.musicRecordingStubsSync(query);
  }

  musicRecordingStubsSync(
    query?: $ObjectSet.Query<MusicRecordingStub.$Identifier>,
  ): readonly purify.Either<Error, MusicRecordingStub>[] {
    return [
      ...this.$objectsSync<MusicRecordingStub, MusicRecordingStub.$Identifier>(
        MusicRecordingStub,
        query,
      ),
    ];
  }

  async musicRecordingStubsCount(
    query?: Pick<$ObjectSet.Query<MusicRecordingStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicRecordingStubsCountSync(query);
  }

  musicRecordingStubsCountSync(
    query?: Pick<$ObjectSet.Query<MusicRecordingStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      MusicRecordingStub,
      MusicRecordingStub.$Identifier
    >(MusicRecordingStub, query);
  }

  async occupationStub(
    identifier: OccupationStub.$Identifier,
  ): Promise<purify.Either<Error, OccupationStub>> {
    return this.occupationStubSync(identifier);
  }

  occupationStubSync(
    identifier: OccupationStub.$Identifier,
  ): purify.Either<Error, OccupationStub> {
    return this.occupationStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async occupationStubIdentifiers(
    query?: $ObjectSet.Query<OccupationStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly OccupationStub.$Identifier[]>> {
    return this.occupationStubIdentifiersSync(query);
  }

  occupationStubIdentifiersSync(
    query?: $ObjectSet.Query<OccupationStub.$Identifier>,
  ): purify.Either<Error, readonly OccupationStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        OccupationStub,
        OccupationStub.$Identifier
      >(OccupationStub, query),
    ]);
  }

  async occupationStubs(
    query?: $ObjectSet.Query<OccupationStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, OccupationStub>[]> {
    return this.occupationStubsSync(query);
  }

  occupationStubsSync(
    query?: $ObjectSet.Query<OccupationStub.$Identifier>,
  ): readonly purify.Either<Error, OccupationStub>[] {
    return [
      ...this.$objectsSync<OccupationStub, OccupationStub.$Identifier>(
        OccupationStub,
        query,
      ),
    ];
  }

  async occupationStubsCount(
    query?: Pick<$ObjectSet.Query<OccupationStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.occupationStubsCountSync(query);
  }

  occupationStubsCountSync(
    query?: Pick<$ObjectSet.Query<OccupationStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<OccupationStub, OccupationStub.$Identifier>(
      OccupationStub,
      query,
    );
  }

  async order(
    identifier: Order.$Identifier,
  ): Promise<purify.Either<Error, Order>> {
    return this.orderSync(identifier);
  }

  orderSync(identifier: Order.$Identifier): purify.Either<Error, Order> {
    return this.ordersSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async orderIdentifiers(
    query?: $ObjectSet.Query<Order.$Identifier>,
  ): Promise<purify.Either<Error, readonly Order.$Identifier[]>> {
    return this.orderIdentifiersSync(query);
  }

  orderIdentifiersSync(
    query?: $ObjectSet.Query<Order.$Identifier>,
  ): purify.Either<Error, readonly Order.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Order, Order.$Identifier>(Order, query),
    ]);
  }

  async orders(
    query?: $ObjectSet.Query<Order.$Identifier>,
  ): Promise<readonly purify.Either<Error, Order>[]> {
    return this.ordersSync(query);
  }

  ordersSync(
    query?: $ObjectSet.Query<Order.$Identifier>,
  ): readonly purify.Either<Error, Order>[] {
    return [...this.$objectsSync<Order, Order.$Identifier>(Order, query)];
  }

  async ordersCount(
    query?: Pick<$ObjectSet.Query<Order.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.ordersCountSync(query);
  }

  ordersCountSync(
    query?: Pick<$ObjectSet.Query<Order.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Order, Order.$Identifier>(Order, query);
  }

  async orderStub(
    identifier: OrderStub.$Identifier,
  ): Promise<purify.Either<Error, OrderStub>> {
    return this.orderStubSync(identifier);
  }

  orderStubSync(
    identifier: OrderStub.$Identifier,
  ): purify.Either<Error, OrderStub> {
    return this.orderStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async orderStubIdentifiers(
    query?: $ObjectSet.Query<OrderStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrderStub.$Identifier[]>> {
    return this.orderStubIdentifiersSync(query);
  }

  orderStubIdentifiersSync(
    query?: $ObjectSet.Query<OrderStub.$Identifier>,
  ): purify.Either<Error, readonly OrderStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<OrderStub, OrderStub.$Identifier>(
        OrderStub,
        query,
      ),
    ]);
  }

  async orderStubs(
    query?: $ObjectSet.Query<OrderStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, OrderStub>[]> {
    return this.orderStubsSync(query);
  }

  orderStubsSync(
    query?: $ObjectSet.Query<OrderStub.$Identifier>,
  ): readonly purify.Either<Error, OrderStub>[] {
    return [
      ...this.$objectsSync<OrderStub, OrderStub.$Identifier>(OrderStub, query),
    ];
  }

  async orderStubsCount(
    query?: Pick<$ObjectSet.Query<OrderStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.orderStubsCountSync(query);
  }

  orderStubsCountSync(
    query?: Pick<$ObjectSet.Query<OrderStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<OrderStub, OrderStub.$Identifier>(
      OrderStub,
      query,
    );
  }

  async organization(
    identifier: OrganizationStatic.$Identifier,
  ): Promise<purify.Either<Error, Organization>> {
    return this.organizationSync(identifier);
  }

  organizationSync(
    identifier: OrganizationStatic.$Identifier,
  ): purify.Either<Error, Organization> {
    return this.organizationsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async organizationIdentifiers(
    query?: $ObjectSet.Query<OrganizationStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrganizationStatic.$Identifier[]>> {
    return this.organizationIdentifiersSync(query);
  }

  organizationIdentifiersSync(
    query?: $ObjectSet.Query<OrganizationStatic.$Identifier>,
  ): purify.Either<Error, readonly OrganizationStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        Organization,
        OrganizationStatic.$Identifier
      >(OrganizationStatic, query),
    ]);
  }

  async organizations(
    query?: $ObjectSet.Query<OrganizationStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Organization>[]> {
    return this.organizationsSync(query);
  }

  organizationsSync(
    query?: $ObjectSet.Query<OrganizationStatic.$Identifier>,
  ): readonly purify.Either<Error, Organization>[] {
    return [
      ...this.$objectsSync<Organization, OrganizationStatic.$Identifier>(
        OrganizationStatic,
        query,
      ),
    ];
  }

  async organizationsCount(
    query?: Pick<$ObjectSet.Query<OrganizationStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.organizationsCountSync(query);
  }

  organizationsCountSync(
    query?: Pick<$ObjectSet.Query<OrganizationStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Organization, OrganizationStatic.$Identifier>(
      OrganizationStatic,
      query,
    );
  }

  async organizationStub(
    identifier: OrganizationStubStatic.$Identifier,
  ): Promise<purify.Either<Error, OrganizationStub>> {
    return this.organizationStubSync(identifier);
  }

  organizationStubSync(
    identifier: OrganizationStubStatic.$Identifier,
  ): purify.Either<Error, OrganizationStub> {
    return this.organizationStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async organizationStubIdentifiers(
    query?: $ObjectSet.Query<OrganizationStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly OrganizationStubStatic.$Identifier[]>
  > {
    return this.organizationStubIdentifiersSync(query);
  }

  organizationStubIdentifiersSync(
    query?: $ObjectSet.Query<OrganizationStubStatic.$Identifier>,
  ): purify.Either<Error, readonly OrganizationStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        OrganizationStub,
        OrganizationStubStatic.$Identifier
      >(OrganizationStubStatic, query),
    ]);
  }

  async organizationStubs(
    query?: $ObjectSet.Query<OrganizationStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, OrganizationStub>[]> {
    return this.organizationStubsSync(query);
  }

  organizationStubsSync(
    query?: $ObjectSet.Query<OrganizationStubStatic.$Identifier>,
  ): readonly purify.Either<Error, OrganizationStub>[] {
    return [
      ...this.$objectsSync<
        OrganizationStub,
        OrganizationStubStatic.$Identifier
      >(OrganizationStubStatic, query),
    ];
  }

  async organizationStubsCount(
    query?: Pick<$ObjectSet.Query<OrganizationStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.organizationStubsCountSync(query);
  }

  organizationStubsCountSync(
    query?: Pick<$ObjectSet.Query<OrganizationStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      OrganizationStub,
      OrganizationStubStatic.$Identifier
    >(OrganizationStubStatic, query);
  }

  async performingGroup(
    identifier: PerformingGroupStatic.$Identifier,
  ): Promise<purify.Either<Error, PerformingGroup>> {
    return this.performingGroupSync(identifier);
  }

  performingGroupSync(
    identifier: PerformingGroupStatic.$Identifier,
  ): purify.Either<Error, PerformingGroup> {
    return this.performingGroupsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async performingGroupIdentifiers(
    query?: $ObjectSet.Query<PerformingGroupStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PerformingGroupStatic.$Identifier[]>
  > {
    return this.performingGroupIdentifiersSync(query);
  }

  performingGroupIdentifiersSync(
    query?: $ObjectSet.Query<PerformingGroupStatic.$Identifier>,
  ): purify.Either<Error, readonly PerformingGroupStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        PerformingGroup,
        PerformingGroupStatic.$Identifier
      >(PerformingGroupStatic, query),
    ]);
  }

  async performingGroups(
    query?: $ObjectSet.Query<PerformingGroupStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PerformingGroup>[]> {
    return this.performingGroupsSync(query);
  }

  performingGroupsSync(
    query?: $ObjectSet.Query<PerformingGroupStatic.$Identifier>,
  ): readonly purify.Either<Error, PerformingGroup>[] {
    return [
      ...this.$objectsSync<PerformingGroup, PerformingGroupStatic.$Identifier>(
        PerformingGroupStatic,
        query,
      ),
    ];
  }

  async performingGroupsCount(
    query?: Pick<$ObjectSet.Query<PerformingGroupStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.performingGroupsCountSync(query);
  }

  performingGroupsCountSync(
    query?: Pick<$ObjectSet.Query<PerformingGroupStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PerformingGroup,
      PerformingGroupStatic.$Identifier
    >(PerformingGroupStatic, query);
  }

  async performingGroupStub(
    identifier: PerformingGroupStubStatic.$Identifier,
  ): Promise<purify.Either<Error, PerformingGroupStub>> {
    return this.performingGroupStubSync(identifier);
  }

  performingGroupStubSync(
    identifier: PerformingGroupStubStatic.$Identifier,
  ): purify.Either<Error, PerformingGroupStub> {
    return this.performingGroupStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async performingGroupStubIdentifiers(
    query?: $ObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PerformingGroupStubStatic.$Identifier[]>
  > {
    return this.performingGroupStubIdentifiersSync(query);
  }

  performingGroupStubIdentifiersSync(
    query?: $ObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
  ): purify.Either<Error, readonly PerformingGroupStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        PerformingGroupStub,
        PerformingGroupStubStatic.$Identifier
      >(PerformingGroupStubStatic, query),
    ]);
  }

  async performingGroupStubs(
    query?: $ObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PerformingGroupStub>[]> {
    return this.performingGroupStubsSync(query);
  }

  performingGroupStubsSync(
    query?: $ObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
  ): readonly purify.Either<Error, PerformingGroupStub>[] {
    return [
      ...this.$objectsSync<
        PerformingGroupStub,
        PerformingGroupStubStatic.$Identifier
      >(PerformingGroupStubStatic, query),
    ];
  }

  async performingGroupStubsCount(
    query?: Pick<
      $ObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.performingGroupStubsCountSync(query);
  }

  performingGroupStubsCountSync(
    query?: Pick<
      $ObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PerformingGroupStub,
      PerformingGroupStubStatic.$Identifier
    >(PerformingGroupStubStatic, query);
  }

  async person(
    identifier: Person.$Identifier,
  ): Promise<purify.Either<Error, Person>> {
    return this.personSync(identifier);
  }

  personSync(identifier: Person.$Identifier): purify.Either<Error, Person> {
    return this.peopleSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async personIdentifiers(
    query?: $ObjectSet.Query<Person.$Identifier>,
  ): Promise<purify.Either<Error, readonly Person.$Identifier[]>> {
    return this.personIdentifiersSync(query);
  }

  personIdentifiersSync(
    query?: $ObjectSet.Query<Person.$Identifier>,
  ): purify.Either<Error, readonly Person.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Person, Person.$Identifier>(Person, query),
    ]);
  }

  async people(
    query?: $ObjectSet.Query<Person.$Identifier>,
  ): Promise<readonly purify.Either<Error, Person>[]> {
    return this.peopleSync(query);
  }

  peopleSync(
    query?: $ObjectSet.Query<Person.$Identifier>,
  ): readonly purify.Either<Error, Person>[] {
    return [...this.$objectsSync<Person, Person.$Identifier>(Person, query)];
  }

  async peopleCount(
    query?: Pick<$ObjectSet.Query<Person.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.peopleCountSync(query);
  }

  peopleCountSync(
    query?: Pick<$ObjectSet.Query<Person.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Person, Person.$Identifier>(Person, query);
  }

  async personStub(
    identifier: PersonStub.$Identifier,
  ): Promise<purify.Either<Error, PersonStub>> {
    return this.personStubSync(identifier);
  }

  personStubSync(
    identifier: PersonStub.$Identifier,
  ): purify.Either<Error, PersonStub> {
    return this.personStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async personStubIdentifiers(
    query?: $ObjectSet.Query<PersonStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly PersonStub.$Identifier[]>> {
    return this.personStubIdentifiersSync(query);
  }

  personStubIdentifiersSync(
    query?: $ObjectSet.Query<PersonStub.$Identifier>,
  ): purify.Either<Error, readonly PersonStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<PersonStub, PersonStub.$Identifier>(
        PersonStub,
        query,
      ),
    ]);
  }

  async personStubs(
    query?: $ObjectSet.Query<PersonStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, PersonStub>[]> {
    return this.personStubsSync(query);
  }

  personStubsSync(
    query?: $ObjectSet.Query<PersonStub.$Identifier>,
  ): readonly purify.Either<Error, PersonStub>[] {
    return [
      ...this.$objectsSync<PersonStub, PersonStub.$Identifier>(
        PersonStub,
        query,
      ),
    ];
  }

  async personStubsCount(
    query?: Pick<$ObjectSet.Query<PersonStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.personStubsCountSync(query);
  }

  personStubsCountSync(
    query?: Pick<$ObjectSet.Query<PersonStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<PersonStub, PersonStub.$Identifier>(
      PersonStub,
      query,
    );
  }

  async place(
    identifier: Place.$Identifier,
  ): Promise<purify.Either<Error, Place>> {
    return this.placeSync(identifier);
  }

  placeSync(identifier: Place.$Identifier): purify.Either<Error, Place> {
    return this.placesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async placeIdentifiers(
    query?: $ObjectSet.Query<Place.$Identifier>,
  ): Promise<purify.Either<Error, readonly Place.$Identifier[]>> {
    return this.placeIdentifiersSync(query);
  }

  placeIdentifiersSync(
    query?: $ObjectSet.Query<Place.$Identifier>,
  ): purify.Either<Error, readonly Place.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Place, Place.$Identifier>(Place, query),
    ]);
  }

  async places(
    query?: $ObjectSet.Query<Place.$Identifier>,
  ): Promise<readonly purify.Either<Error, Place>[]> {
    return this.placesSync(query);
  }

  placesSync(
    query?: $ObjectSet.Query<Place.$Identifier>,
  ): readonly purify.Either<Error, Place>[] {
    return [...this.$objectsSync<Place, Place.$Identifier>(Place, query)];
  }

  async placesCount(
    query?: Pick<$ObjectSet.Query<Place.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.placesCountSync(query);
  }

  placesCountSync(
    query?: Pick<$ObjectSet.Query<Place.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Place, Place.$Identifier>(Place, query);
  }

  async placeStub(
    identifier: PlaceStub.$Identifier,
  ): Promise<purify.Either<Error, PlaceStub>> {
    return this.placeStubSync(identifier);
  }

  placeStubSync(
    identifier: PlaceStub.$Identifier,
  ): purify.Either<Error, PlaceStub> {
    return this.placeStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async placeStubIdentifiers(
    query?: $ObjectSet.Query<PlaceStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly PlaceStub.$Identifier[]>> {
    return this.placeStubIdentifiersSync(query);
  }

  placeStubIdentifiersSync(
    query?: $ObjectSet.Query<PlaceStub.$Identifier>,
  ): purify.Either<Error, readonly PlaceStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<PlaceStub, PlaceStub.$Identifier>(
        PlaceStub,
        query,
      ),
    ]);
  }

  async placeStubs(
    query?: $ObjectSet.Query<PlaceStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, PlaceStub>[]> {
    return this.placeStubsSync(query);
  }

  placeStubsSync(
    query?: $ObjectSet.Query<PlaceStub.$Identifier>,
  ): readonly purify.Either<Error, PlaceStub>[] {
    return [
      ...this.$objectsSync<PlaceStub, PlaceStub.$Identifier>(PlaceStub, query),
    ];
  }

  async placeStubsCount(
    query?: Pick<$ObjectSet.Query<PlaceStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.placeStubsCountSync(query);
  }

  placeStubsCountSync(
    query?: Pick<$ObjectSet.Query<PlaceStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<PlaceStub, PlaceStub.$Identifier>(
      PlaceStub,
      query,
    );
  }

  async publicationEvent(
    identifier: PublicationEventStatic.$Identifier,
  ): Promise<purify.Either<Error, PublicationEvent>> {
    return this.publicationEventSync(identifier);
  }

  publicationEventSync(
    identifier: PublicationEventStatic.$Identifier,
  ): purify.Either<Error, PublicationEvent> {
    return this.publicationEventsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async publicationEventIdentifiers(
    query?: $ObjectSet.Query<PublicationEventStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PublicationEventStatic.$Identifier[]>
  > {
    return this.publicationEventIdentifiersSync(query);
  }

  publicationEventIdentifiersSync(
    query?: $ObjectSet.Query<PublicationEventStatic.$Identifier>,
  ): purify.Either<Error, readonly PublicationEventStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        PublicationEvent,
        PublicationEventStatic.$Identifier
      >(PublicationEventStatic, query),
    ]);
  }

  async publicationEvents(
    query?: $ObjectSet.Query<PublicationEventStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PublicationEvent>[]> {
    return this.publicationEventsSync(query);
  }

  publicationEventsSync(
    query?: $ObjectSet.Query<PublicationEventStatic.$Identifier>,
  ): readonly purify.Either<Error, PublicationEvent>[] {
    return [
      ...this.$objectsSync<
        PublicationEvent,
        PublicationEventStatic.$Identifier
      >(PublicationEventStatic, query),
    ];
  }

  async publicationEventsCount(
    query?: Pick<$ObjectSet.Query<PublicationEventStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.publicationEventsCountSync(query);
  }

  publicationEventsCountSync(
    query?: Pick<$ObjectSet.Query<PublicationEventStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PublicationEvent,
      PublicationEventStatic.$Identifier
    >(PublicationEventStatic, query);
  }

  async publicationEventStub(
    identifier: PublicationEventStubStatic.$Identifier,
  ): Promise<purify.Either<Error, PublicationEventStub>> {
    return this.publicationEventStubSync(identifier);
  }

  publicationEventStubSync(
    identifier: PublicationEventStubStatic.$Identifier,
  ): purify.Either<Error, PublicationEventStub> {
    return this.publicationEventStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async publicationEventStubIdentifiers(
    query?: $ObjectSet.Query<PublicationEventStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PublicationEventStubStatic.$Identifier[]>
  > {
    return this.publicationEventStubIdentifiersSync(query);
  }

  publicationEventStubIdentifiersSync(
    query?: $ObjectSet.Query<PublicationEventStubStatic.$Identifier>,
  ): purify.Either<Error, readonly PublicationEventStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        PublicationEventStub,
        PublicationEventStubStatic.$Identifier
      >(PublicationEventStubStatic, query),
    ]);
  }

  async publicationEventStubs(
    query?: $ObjectSet.Query<PublicationEventStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PublicationEventStub>[]> {
    return this.publicationEventStubsSync(query);
  }

  publicationEventStubsSync(
    query?: $ObjectSet.Query<PublicationEventStubStatic.$Identifier>,
  ): readonly purify.Either<Error, PublicationEventStub>[] {
    return [
      ...this.$objectsSync<
        PublicationEventStub,
        PublicationEventStubStatic.$Identifier
      >(PublicationEventStubStatic, query),
    ];
  }

  async publicationEventStubsCount(
    query?: Pick<
      $ObjectSet.Query<PublicationEventStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.publicationEventStubsCountSync(query);
  }

  publicationEventStubsCountSync(
    query?: Pick<
      $ObjectSet.Query<PublicationEventStubStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      PublicationEventStub,
      PublicationEventStubStatic.$Identifier
    >(PublicationEventStubStatic, query);
  }

  async quantitativeValue(
    identifier: QuantitativeValue.$Identifier,
  ): Promise<purify.Either<Error, QuantitativeValue>> {
    return this.quantitativeValueSync(identifier);
  }

  quantitativeValueSync(
    identifier: QuantitativeValue.$Identifier,
  ): purify.Either<Error, QuantitativeValue> {
    return this.quantitativeValuesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async quantitativeValueIdentifiers(
    query?: $ObjectSet.Query<QuantitativeValue.$Identifier>,
  ): Promise<purify.Either<Error, readonly QuantitativeValue.$Identifier[]>> {
    return this.quantitativeValueIdentifiersSync(query);
  }

  quantitativeValueIdentifiersSync(
    query?: $ObjectSet.Query<QuantitativeValue.$Identifier>,
  ): purify.Either<Error, readonly QuantitativeValue.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        QuantitativeValue,
        QuantitativeValue.$Identifier
      >(QuantitativeValue, query),
    ]);
  }

  async quantitativeValues(
    query?: $ObjectSet.Query<QuantitativeValue.$Identifier>,
  ): Promise<readonly purify.Either<Error, QuantitativeValue>[]> {
    return this.quantitativeValuesSync(query);
  }

  quantitativeValuesSync(
    query?: $ObjectSet.Query<QuantitativeValue.$Identifier>,
  ): readonly purify.Either<Error, QuantitativeValue>[] {
    return [
      ...this.$objectsSync<QuantitativeValue, QuantitativeValue.$Identifier>(
        QuantitativeValue,
        query,
      ),
    ];
  }

  async quantitativeValuesCount(
    query?: Pick<$ObjectSet.Query<QuantitativeValue.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.quantitativeValuesCountSync(query);
  }

  quantitativeValuesCountSync(
    query?: Pick<$ObjectSet.Query<QuantitativeValue.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      QuantitativeValue,
      QuantitativeValue.$Identifier
    >(QuantitativeValue, query);
  }

  async quantitativeValueStub(
    identifier: QuantitativeValueStub.$Identifier,
  ): Promise<purify.Either<Error, QuantitativeValueStub>> {
    return this.quantitativeValueStubSync(identifier);
  }

  quantitativeValueStubSync(
    identifier: QuantitativeValueStub.$Identifier,
  ): purify.Either<Error, QuantitativeValueStub> {
    return this.quantitativeValueStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async quantitativeValueStubIdentifiers(
    query?: $ObjectSet.Query<QuantitativeValueStub.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly QuantitativeValueStub.$Identifier[]>
  > {
    return this.quantitativeValueStubIdentifiersSync(query);
  }

  quantitativeValueStubIdentifiersSync(
    query?: $ObjectSet.Query<QuantitativeValueStub.$Identifier>,
  ): purify.Either<Error, readonly QuantitativeValueStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        QuantitativeValueStub,
        QuantitativeValueStub.$Identifier
      >(QuantitativeValueStub, query),
    ]);
  }

  async quantitativeValueStubs(
    query?: $ObjectSet.Query<QuantitativeValueStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, QuantitativeValueStub>[]> {
    return this.quantitativeValueStubsSync(query);
  }

  quantitativeValueStubsSync(
    query?: $ObjectSet.Query<QuantitativeValueStub.$Identifier>,
  ): readonly purify.Either<Error, QuantitativeValueStub>[] {
    return [
      ...this.$objectsSync<
        QuantitativeValueStub,
        QuantitativeValueStub.$Identifier
      >(QuantitativeValueStub, query),
    ];
  }

  async quantitativeValueStubsCount(
    query?: Pick<$ObjectSet.Query<QuantitativeValueStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.quantitativeValueStubsCountSync(query);
  }

  quantitativeValueStubsCountSync(
    query?: Pick<$ObjectSet.Query<QuantitativeValueStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      QuantitativeValueStub,
      QuantitativeValueStub.$Identifier
    >(QuantitativeValueStub, query);
  }

  async radioBroadcastService(
    identifier: RadioBroadcastService.$Identifier,
  ): Promise<purify.Either<Error, RadioBroadcastService>> {
    return this.radioBroadcastServiceSync(identifier);
  }

  radioBroadcastServiceSync(
    identifier: RadioBroadcastService.$Identifier,
  ): purify.Either<Error, RadioBroadcastService> {
    return this.radioBroadcastServicesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async radioBroadcastServiceIdentifiers(
    query?: $ObjectSet.Query<RadioBroadcastService.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RadioBroadcastService.$Identifier[]>
  > {
    return this.radioBroadcastServiceIdentifiersSync(query);
  }

  radioBroadcastServiceIdentifiersSync(
    query?: $ObjectSet.Query<RadioBroadcastService.$Identifier>,
  ): purify.Either<Error, readonly RadioBroadcastService.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        RadioBroadcastService,
        RadioBroadcastService.$Identifier
      >(RadioBroadcastService, query),
    ]);
  }

  async radioBroadcastServices(
    query?: $ObjectSet.Query<RadioBroadcastService.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioBroadcastService>[]> {
    return this.radioBroadcastServicesSync(query);
  }

  radioBroadcastServicesSync(
    query?: $ObjectSet.Query<RadioBroadcastService.$Identifier>,
  ): readonly purify.Either<Error, RadioBroadcastService>[] {
    return [
      ...this.$objectsSync<
        RadioBroadcastService,
        RadioBroadcastService.$Identifier
      >(RadioBroadcastService, query),
    ];
  }

  async radioBroadcastServicesCount(
    query?: Pick<$ObjectSet.Query<RadioBroadcastService.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.radioBroadcastServicesCountSync(query);
  }

  radioBroadcastServicesCountSync(
    query?: Pick<$ObjectSet.Query<RadioBroadcastService.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      RadioBroadcastService,
      RadioBroadcastService.$Identifier
    >(RadioBroadcastService, query);
  }

  async radioBroadcastServiceStub(
    identifier: RadioBroadcastServiceStub.$Identifier,
  ): Promise<purify.Either<Error, RadioBroadcastServiceStub>> {
    return this.radioBroadcastServiceStubSync(identifier);
  }

  radioBroadcastServiceStubSync(
    identifier: RadioBroadcastServiceStub.$Identifier,
  ): purify.Either<Error, RadioBroadcastServiceStub> {
    return this.radioBroadcastServiceStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async radioBroadcastServiceStubIdentifiers(
    query?: $ObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RadioBroadcastServiceStub.$Identifier[]>
  > {
    return this.radioBroadcastServiceStubIdentifiersSync(query);
  }

  radioBroadcastServiceStubIdentifiersSync(
    query?: $ObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
  ): purify.Either<Error, readonly RadioBroadcastServiceStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        RadioBroadcastServiceStub,
        RadioBroadcastServiceStub.$Identifier
      >(RadioBroadcastServiceStub, query),
    ]);
  }

  async radioBroadcastServiceStubs(
    query?: $ObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioBroadcastServiceStub>[]> {
    return this.radioBroadcastServiceStubsSync(query);
  }

  radioBroadcastServiceStubsSync(
    query?: $ObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
  ): readonly purify.Either<Error, RadioBroadcastServiceStub>[] {
    return [
      ...this.$objectsSync<
        RadioBroadcastServiceStub,
        RadioBroadcastServiceStub.$Identifier
      >(RadioBroadcastServiceStub, query),
    ];
  }

  async radioBroadcastServiceStubsCount(
    query?: Pick<
      $ObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.radioBroadcastServiceStubsCountSync(query);
  }

  radioBroadcastServiceStubsCountSync(
    query?: Pick<
      $ObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      RadioBroadcastServiceStub,
      RadioBroadcastServiceStub.$Identifier
    >(RadioBroadcastServiceStub, query);
  }

  async radioEpisode(
    identifier: RadioEpisode.$Identifier,
  ): Promise<purify.Either<Error, RadioEpisode>> {
    return this.radioEpisodeSync(identifier);
  }

  radioEpisodeSync(
    identifier: RadioEpisode.$Identifier,
  ): purify.Either<Error, RadioEpisode> {
    return this.radioEpisodesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async radioEpisodeIdentifiers(
    query?: $ObjectSet.Query<RadioEpisode.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioEpisode.$Identifier[]>> {
    return this.radioEpisodeIdentifiersSync(query);
  }

  radioEpisodeIdentifiersSync(
    query?: $ObjectSet.Query<RadioEpisode.$Identifier>,
  ): purify.Either<Error, readonly RadioEpisode.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<RadioEpisode, RadioEpisode.$Identifier>(
        RadioEpisode,
        query,
      ),
    ]);
  }

  async radioEpisodes(
    query?: $ObjectSet.Query<RadioEpisode.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioEpisode>[]> {
    return this.radioEpisodesSync(query);
  }

  radioEpisodesSync(
    query?: $ObjectSet.Query<RadioEpisode.$Identifier>,
  ): readonly purify.Either<Error, RadioEpisode>[] {
    return [
      ...this.$objectsSync<RadioEpisode, RadioEpisode.$Identifier>(
        RadioEpisode,
        query,
      ),
    ];
  }

  async radioEpisodesCount(
    query?: Pick<$ObjectSet.Query<RadioEpisode.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.radioEpisodesCountSync(query);
  }

  radioEpisodesCountSync(
    query?: Pick<$ObjectSet.Query<RadioEpisode.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<RadioEpisode, RadioEpisode.$Identifier>(
      RadioEpisode,
      query,
    );
  }

  async radioEpisodeStub(
    identifier: RadioEpisodeStub.$Identifier,
  ): Promise<purify.Either<Error, RadioEpisodeStub>> {
    return this.radioEpisodeStubSync(identifier);
  }

  radioEpisodeStubSync(
    identifier: RadioEpisodeStub.$Identifier,
  ): purify.Either<Error, RadioEpisodeStub> {
    return this.radioEpisodeStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async radioEpisodeStubIdentifiers(
    query?: $ObjectSet.Query<RadioEpisodeStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioEpisodeStub.$Identifier[]>> {
    return this.radioEpisodeStubIdentifiersSync(query);
  }

  radioEpisodeStubIdentifiersSync(
    query?: $ObjectSet.Query<RadioEpisodeStub.$Identifier>,
  ): purify.Either<Error, readonly RadioEpisodeStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        RadioEpisodeStub,
        RadioEpisodeStub.$Identifier
      >(RadioEpisodeStub, query),
    ]);
  }

  async radioEpisodeStubs(
    query?: $ObjectSet.Query<RadioEpisodeStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioEpisodeStub>[]> {
    return this.radioEpisodeStubsSync(query);
  }

  radioEpisodeStubsSync(
    query?: $ObjectSet.Query<RadioEpisodeStub.$Identifier>,
  ): readonly purify.Either<Error, RadioEpisodeStub>[] {
    return [
      ...this.$objectsSync<RadioEpisodeStub, RadioEpisodeStub.$Identifier>(
        RadioEpisodeStub,
        query,
      ),
    ];
  }

  async radioEpisodeStubsCount(
    query?: Pick<$ObjectSet.Query<RadioEpisodeStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.radioEpisodeStubsCountSync(query);
  }

  radioEpisodeStubsCountSync(
    query?: Pick<$ObjectSet.Query<RadioEpisodeStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      RadioEpisodeStub,
      RadioEpisodeStub.$Identifier
    >(RadioEpisodeStub, query);
  }

  async radioSeries(
    identifier: RadioSeries.$Identifier,
  ): Promise<purify.Either<Error, RadioSeries>> {
    return this.radioSeriesSync(identifier);
  }

  radioSeriesSync(
    identifier: RadioSeries.$Identifier,
  ): purify.Either<Error, RadioSeries> {
    return this.radioSeriessSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async radioSeriesIdentifiers(
    query?: $ObjectSet.Query<RadioSeries.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioSeries.$Identifier[]>> {
    return this.radioSeriesIdentifiersSync(query);
  }

  radioSeriesIdentifiersSync(
    query?: $ObjectSet.Query<RadioSeries.$Identifier>,
  ): purify.Either<Error, readonly RadioSeries.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<RadioSeries, RadioSeries.$Identifier>(
        RadioSeries,
        query,
      ),
    ]);
  }

  async radioSeriess(
    query?: $ObjectSet.Query<RadioSeries.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioSeries>[]> {
    return this.radioSeriessSync(query);
  }

  radioSeriessSync(
    query?: $ObjectSet.Query<RadioSeries.$Identifier>,
  ): readonly purify.Either<Error, RadioSeries>[] {
    return [
      ...this.$objectsSync<RadioSeries, RadioSeries.$Identifier>(
        RadioSeries,
        query,
      ),
    ];
  }

  async radioSeriessCount(
    query?: Pick<$ObjectSet.Query<RadioSeries.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.radioSeriessCountSync(query);
  }

  radioSeriessCountSync(
    query?: Pick<$ObjectSet.Query<RadioSeries.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<RadioSeries, RadioSeries.$Identifier>(
      RadioSeries,
      query,
    );
  }

  async radioSeriesStub(
    identifier: RadioSeriesStub.$Identifier,
  ): Promise<purify.Either<Error, RadioSeriesStub>> {
    return this.radioSeriesStubSync(identifier);
  }

  radioSeriesStubSync(
    identifier: RadioSeriesStub.$Identifier,
  ): purify.Either<Error, RadioSeriesStub> {
    return this.radioSeriesStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async radioSeriesStubIdentifiers(
    query?: $ObjectSet.Query<RadioSeriesStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioSeriesStub.$Identifier[]>> {
    return this.radioSeriesStubIdentifiersSync(query);
  }

  radioSeriesStubIdentifiersSync(
    query?: $ObjectSet.Query<RadioSeriesStub.$Identifier>,
  ): purify.Either<Error, readonly RadioSeriesStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        RadioSeriesStub,
        RadioSeriesStub.$Identifier
      >(RadioSeriesStub, query),
    ]);
  }

  async radioSeriesStubs(
    query?: $ObjectSet.Query<RadioSeriesStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioSeriesStub>[]> {
    return this.radioSeriesStubsSync(query);
  }

  radioSeriesStubsSync(
    query?: $ObjectSet.Query<RadioSeriesStub.$Identifier>,
  ): readonly purify.Either<Error, RadioSeriesStub>[] {
    return [
      ...this.$objectsSync<RadioSeriesStub, RadioSeriesStub.$Identifier>(
        RadioSeriesStub,
        query,
      ),
    ];
  }

  async radioSeriesStubsCount(
    query?: Pick<$ObjectSet.Query<RadioSeriesStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.radioSeriesStubsCountSync(query);
  }

  radioSeriesStubsCountSync(
    query?: Pick<$ObjectSet.Query<RadioSeriesStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<RadioSeriesStub, RadioSeriesStub.$Identifier>(
      RadioSeriesStub,
      query,
    );
  }

  async report(
    identifier: Report.$Identifier,
  ): Promise<purify.Either<Error, Report>> {
    return this.reportSync(identifier);
  }

  reportSync(identifier: Report.$Identifier): purify.Either<Error, Report> {
    return this.reportsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async reportIdentifiers(
    query?: $ObjectSet.Query<Report.$Identifier>,
  ): Promise<purify.Either<Error, readonly Report.$Identifier[]>> {
    return this.reportIdentifiersSync(query);
  }

  reportIdentifiersSync(
    query?: $ObjectSet.Query<Report.$Identifier>,
  ): purify.Either<Error, readonly Report.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Report, Report.$Identifier>(Report, query),
    ]);
  }

  async reports(
    query?: $ObjectSet.Query<Report.$Identifier>,
  ): Promise<readonly purify.Either<Error, Report>[]> {
    return this.reportsSync(query);
  }

  reportsSync(
    query?: $ObjectSet.Query<Report.$Identifier>,
  ): readonly purify.Either<Error, Report>[] {
    return [...this.$objectsSync<Report, Report.$Identifier>(Report, query)];
  }

  async reportsCount(
    query?: Pick<$ObjectSet.Query<Report.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.reportsCountSync(query);
  }

  reportsCountSync(
    query?: Pick<$ObjectSet.Query<Report.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Report, Report.$Identifier>(Report, query);
  }

  async reportStub(
    identifier: ReportStub.$Identifier,
  ): Promise<purify.Either<Error, ReportStub>> {
    return this.reportStubSync(identifier);
  }

  reportStubSync(
    identifier: ReportStub.$Identifier,
  ): purify.Either<Error, ReportStub> {
    return this.reportStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async reportStubIdentifiers(
    query?: $ObjectSet.Query<ReportStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ReportStub.$Identifier[]>> {
    return this.reportStubIdentifiersSync(query);
  }

  reportStubIdentifiersSync(
    query?: $ObjectSet.Query<ReportStub.$Identifier>,
  ): purify.Either<Error, readonly ReportStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<ReportStub, ReportStub.$Identifier>(
        ReportStub,
        query,
      ),
    ]);
  }

  async reportStubs(
    query?: $ObjectSet.Query<ReportStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ReportStub>[]> {
    return this.reportStubsSync(query);
  }

  reportStubsSync(
    query?: $ObjectSet.Query<ReportStub.$Identifier>,
  ): readonly purify.Either<Error, ReportStub>[] {
    return [
      ...this.$objectsSync<ReportStub, ReportStub.$Identifier>(
        ReportStub,
        query,
      ),
    ];
  }

  async reportStubsCount(
    query?: Pick<$ObjectSet.Query<ReportStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.reportStubsCountSync(query);
  }

  reportStubsCountSync(
    query?: Pick<$ObjectSet.Query<ReportStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ReportStub, ReportStub.$Identifier>(
      ReportStub,
      query,
    );
  }

  async roleStub(
    identifier: RoleStub.$Identifier,
  ): Promise<purify.Either<Error, RoleStub>> {
    return this.roleStubSync(identifier);
  }

  roleStubSync(
    identifier: RoleStub.$Identifier,
  ): purify.Either<Error, RoleStub> {
    return this.roleStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async roleStubIdentifiers(
    query?: $ObjectSet.Query<RoleStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly RoleStub.$Identifier[]>> {
    return this.roleStubIdentifiersSync(query);
  }

  roleStubIdentifiersSync(
    query?: $ObjectSet.Query<RoleStub.$Identifier>,
  ): purify.Either<Error, readonly RoleStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<RoleStub, RoleStub.$Identifier>(
        RoleStub,
        query,
      ),
    ]);
  }

  async roleStubs(
    query?: $ObjectSet.Query<RoleStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RoleStub>[]> {
    return this.roleStubsSync(query);
  }

  roleStubsSync(
    query?: $ObjectSet.Query<RoleStub.$Identifier>,
  ): readonly purify.Either<Error, RoleStub>[] {
    return [
      ...this.$objectsSync<RoleStub, RoleStub.$Identifier>(RoleStub, query),
    ];
  }

  async roleStubsCount(
    query?: Pick<$ObjectSet.Query<RoleStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.roleStubsCountSync(query);
  }

  roleStubsCountSync(
    query?: Pick<$ObjectSet.Query<RoleStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<RoleStub, RoleStub.$Identifier>(
      RoleStub,
      query,
    );
  }

  async service(
    identifier: ServiceStatic.$Identifier,
  ): Promise<purify.Either<Error, Service>> {
    return this.serviceSync(identifier);
  }

  serviceSync(
    identifier: ServiceStatic.$Identifier,
  ): purify.Either<Error, Service> {
    return this.servicesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async serviceIdentifiers(
    query?: $ObjectSet.Query<ServiceStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ServiceStatic.$Identifier[]>> {
    return this.serviceIdentifiersSync(query);
  }

  serviceIdentifiersSync(
    query?: $ObjectSet.Query<ServiceStatic.$Identifier>,
  ): purify.Either<Error, readonly ServiceStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Service, ServiceStatic.$Identifier>(
        ServiceStatic,
        query,
      ),
    ]);
  }

  async services(
    query?: $ObjectSet.Query<ServiceStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Service>[]> {
    return this.servicesSync(query);
  }

  servicesSync(
    query?: $ObjectSet.Query<ServiceStatic.$Identifier>,
  ): readonly purify.Either<Error, Service>[] {
    return [
      ...this.$objectsSync<Service, ServiceStatic.$Identifier>(
        ServiceStatic,
        query,
      ),
    ];
  }

  async servicesCount(
    query?: Pick<$ObjectSet.Query<ServiceStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.servicesCountSync(query);
  }

  servicesCountSync(
    query?: Pick<$ObjectSet.Query<ServiceStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Service, ServiceStatic.$Identifier>(
      ServiceStatic,
      query,
    );
  }

  async serviceStub(
    identifier: ServiceStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ServiceStub>> {
    return this.serviceStubSync(identifier);
  }

  serviceStubSync(
    identifier: ServiceStubStatic.$Identifier,
  ): purify.Either<Error, ServiceStub> {
    return this.serviceStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async serviceStubIdentifiers(
    query?: $ObjectSet.Query<ServiceStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ServiceStubStatic.$Identifier[]>> {
    return this.serviceStubIdentifiersSync(query);
  }

  serviceStubIdentifiersSync(
    query?: $ObjectSet.Query<ServiceStubStatic.$Identifier>,
  ): purify.Either<Error, readonly ServiceStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        ServiceStub,
        ServiceStubStatic.$Identifier
      >(ServiceStubStatic, query),
    ]);
  }

  async serviceStubs(
    query?: $ObjectSet.Query<ServiceStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ServiceStub>[]> {
    return this.serviceStubsSync(query);
  }

  serviceStubsSync(
    query?: $ObjectSet.Query<ServiceStubStatic.$Identifier>,
  ): readonly purify.Either<Error, ServiceStub>[] {
    return [
      ...this.$objectsSync<ServiceStub, ServiceStubStatic.$Identifier>(
        ServiceStubStatic,
        query,
      ),
    ];
  }

  async serviceStubsCount(
    query?: Pick<$ObjectSet.Query<ServiceStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.serviceStubsCountSync(query);
  }

  serviceStubsCountSync(
    query?: Pick<$ObjectSet.Query<ServiceStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ServiceStub, ServiceStubStatic.$Identifier>(
      ServiceStubStatic,
      query,
    );
  }

  async structuredValue(
    identifier: StructuredValueStatic.$Identifier,
  ): Promise<purify.Either<Error, StructuredValue>> {
    return this.structuredValueSync(identifier);
  }

  structuredValueSync(
    identifier: StructuredValueStatic.$Identifier,
  ): purify.Either<Error, StructuredValue> {
    return this.structuredValuesSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async structuredValueIdentifiers(
    query?: $ObjectSet.Query<StructuredValueStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly StructuredValueStatic.$Identifier[]>
  > {
    return this.structuredValueIdentifiersSync(query);
  }

  structuredValueIdentifiersSync(
    query?: $ObjectSet.Query<StructuredValueStatic.$Identifier>,
  ): purify.Either<Error, readonly StructuredValueStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        StructuredValue,
        StructuredValueStatic.$Identifier
      >(StructuredValueStatic, query),
    ]);
  }

  async structuredValues(
    query?: $ObjectSet.Query<StructuredValueStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, StructuredValue>[]> {
    return this.structuredValuesSync(query);
  }

  structuredValuesSync(
    query?: $ObjectSet.Query<StructuredValueStatic.$Identifier>,
  ): readonly purify.Either<Error, StructuredValue>[] {
    return [
      ...this.$objectsSync<StructuredValue, StructuredValueStatic.$Identifier>(
        StructuredValueStatic,
        query,
      ),
    ];
  }

  async structuredValuesCount(
    query?: Pick<$ObjectSet.Query<StructuredValueStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.structuredValuesCountSync(query);
  }

  structuredValuesCountSync(
    query?: Pick<$ObjectSet.Query<StructuredValueStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      StructuredValue,
      StructuredValueStatic.$Identifier
    >(StructuredValueStatic, query);
  }

  async structuredValueStub(
    identifier: StructuredValueStubStatic.$Identifier,
  ): Promise<purify.Either<Error, StructuredValueStub>> {
    return this.structuredValueStubSync(identifier);
  }

  structuredValueStubSync(
    identifier: StructuredValueStubStatic.$Identifier,
  ): purify.Either<Error, StructuredValueStub> {
    return this.structuredValueStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async structuredValueStubIdentifiers(
    query?: $ObjectSet.Query<StructuredValueStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly StructuredValueStubStatic.$Identifier[]>
  > {
    return this.structuredValueStubIdentifiersSync(query);
  }

  structuredValueStubIdentifiersSync(
    query?: $ObjectSet.Query<StructuredValueStubStatic.$Identifier>,
  ): purify.Either<Error, readonly StructuredValueStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        StructuredValueStub,
        StructuredValueStubStatic.$Identifier
      >(StructuredValueStubStatic, query),
    ]);
  }

  async structuredValueStubs(
    query?: $ObjectSet.Query<StructuredValueStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, StructuredValueStub>[]> {
    return this.structuredValueStubsSync(query);
  }

  structuredValueStubsSync(
    query?: $ObjectSet.Query<StructuredValueStubStatic.$Identifier>,
  ): readonly purify.Either<Error, StructuredValueStub>[] {
    return [
      ...this.$objectsSync<
        StructuredValueStub,
        StructuredValueStubStatic.$Identifier
      >(StructuredValueStubStatic, query),
    ];
  }

  async structuredValueStubsCount(
    query?: Pick<
      $ObjectSet.Query<StructuredValueStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.structuredValueStubsCountSync(query);
  }

  structuredValueStubsCountSync(
    query?: Pick<
      $ObjectSet.Query<StructuredValueStubStatic.$Identifier>,
      "where"
    >,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<
      StructuredValueStub,
      StructuredValueStubStatic.$Identifier
    >(StructuredValueStubStatic, query);
  }

  async textObject(
    identifier: TextObject.$Identifier,
  ): Promise<purify.Either<Error, TextObject>> {
    return this.textObjectSync(identifier);
  }

  textObjectSync(
    identifier: TextObject.$Identifier,
  ): purify.Either<Error, TextObject> {
    return this.textObjectsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async textObjectIdentifiers(
    query?: $ObjectSet.Query<TextObject.$Identifier>,
  ): Promise<purify.Either<Error, readonly TextObject.$Identifier[]>> {
    return this.textObjectIdentifiersSync(query);
  }

  textObjectIdentifiersSync(
    query?: $ObjectSet.Query<TextObject.$Identifier>,
  ): purify.Either<Error, readonly TextObject.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<TextObject, TextObject.$Identifier>(
        TextObject,
        query,
      ),
    ]);
  }

  async textObjects(
    query?: $ObjectSet.Query<TextObject.$Identifier>,
  ): Promise<readonly purify.Either<Error, TextObject>[]> {
    return this.textObjectsSync(query);
  }

  textObjectsSync(
    query?: $ObjectSet.Query<TextObject.$Identifier>,
  ): readonly purify.Either<Error, TextObject>[] {
    return [
      ...this.$objectsSync<TextObject, TextObject.$Identifier>(
        TextObject,
        query,
      ),
    ];
  }

  async textObjectsCount(
    query?: Pick<$ObjectSet.Query<TextObject.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.textObjectsCountSync(query);
  }

  textObjectsCountSync(
    query?: Pick<$ObjectSet.Query<TextObject.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<TextObject, TextObject.$Identifier>(
      TextObject,
      query,
    );
  }

  async textObjectStub(
    identifier: TextObjectStub.$Identifier,
  ): Promise<purify.Either<Error, TextObjectStub>> {
    return this.textObjectStubSync(identifier);
  }

  textObjectStubSync(
    identifier: TextObjectStub.$Identifier,
  ): purify.Either<Error, TextObjectStub> {
    return this.textObjectStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async textObjectStubIdentifiers(
    query?: $ObjectSet.Query<TextObjectStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly TextObjectStub.$Identifier[]>> {
    return this.textObjectStubIdentifiersSync(query);
  }

  textObjectStubIdentifiersSync(
    query?: $ObjectSet.Query<TextObjectStub.$Identifier>,
  ): purify.Either<Error, readonly TextObjectStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        TextObjectStub,
        TextObjectStub.$Identifier
      >(TextObjectStub, query),
    ]);
  }

  async textObjectStubs(
    query?: $ObjectSet.Query<TextObjectStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, TextObjectStub>[]> {
    return this.textObjectStubsSync(query);
  }

  textObjectStubsSync(
    query?: $ObjectSet.Query<TextObjectStub.$Identifier>,
  ): readonly purify.Either<Error, TextObjectStub>[] {
    return [
      ...this.$objectsSync<TextObjectStub, TextObjectStub.$Identifier>(
        TextObjectStub,
        query,
      ),
    ];
  }

  async textObjectStubsCount(
    query?: Pick<$ObjectSet.Query<TextObjectStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.textObjectStubsCountSync(query);
  }

  textObjectStubsCountSync(
    query?: Pick<$ObjectSet.Query<TextObjectStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<TextObjectStub, TextObjectStub.$Identifier>(
      TextObjectStub,
      query,
    );
  }

  async thing(
    identifier: ThingStatic.$Identifier,
  ): Promise<purify.Either<Error, Thing>> {
    return this.thingSync(identifier);
  }

  thingSync(identifier: ThingStatic.$Identifier): purify.Either<Error, Thing> {
    return this.thingsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async thingIdentifiers(
    query?: $ObjectSet.Query<ThingStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ThingStatic.$Identifier[]>> {
    return this.thingIdentifiersSync(query);
  }

  thingIdentifiersSync(
    query?: $ObjectSet.Query<ThingStatic.$Identifier>,
  ): purify.Either<Error, readonly ThingStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<Thing, ThingStatic.$Identifier>(
        ThingStatic,
        query,
      ),
    ]);
  }

  async things(
    query?: $ObjectSet.Query<ThingStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Thing>[]> {
    return this.thingsSync(query);
  }

  thingsSync(
    query?: $ObjectSet.Query<ThingStatic.$Identifier>,
  ): readonly purify.Either<Error, Thing>[] {
    return [
      ...this.$objectsSync<Thing, ThingStatic.$Identifier>(ThingStatic, query),
    ];
  }

  async thingsCount(
    query?: Pick<$ObjectSet.Query<ThingStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.thingsCountSync(query);
  }

  thingsCountSync(
    query?: Pick<$ObjectSet.Query<ThingStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<Thing, ThingStatic.$Identifier>(
      ThingStatic,
      query,
    );
  }

  async thingStub(
    identifier: ThingStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ThingStub>> {
    return this.thingStubSync(identifier);
  }

  thingStubSync(
    identifier: ThingStubStatic.$Identifier,
  ): purify.Either<Error, ThingStub> {
    return this.thingStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async thingStubIdentifiers(
    query?: $ObjectSet.Query<ThingStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ThingStubStatic.$Identifier[]>> {
    return this.thingStubIdentifiersSync(query);
  }

  thingStubIdentifiersSync(
    query?: $ObjectSet.Query<ThingStubStatic.$Identifier>,
  ): purify.Either<Error, readonly ThingStubStatic.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<ThingStub, ThingStubStatic.$Identifier>(
        ThingStubStatic,
        query,
      ),
    ]);
  }

  async thingStubs(
    query?: $ObjectSet.Query<ThingStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ThingStub>[]> {
    return this.thingStubsSync(query);
  }

  thingStubsSync(
    query?: $ObjectSet.Query<ThingStubStatic.$Identifier>,
  ): readonly purify.Either<Error, ThingStub>[] {
    return [
      ...this.$objectsSync<ThingStub, ThingStubStatic.$Identifier>(
        ThingStubStatic,
        query,
      ),
    ];
  }

  async thingStubsCount(
    query?: Pick<$ObjectSet.Query<ThingStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.thingStubsCountSync(query);
  }

  thingStubsCountSync(
    query?: Pick<$ObjectSet.Query<ThingStubStatic.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<ThingStub, ThingStubStatic.$Identifier>(
      ThingStubStatic,
      query,
    );
  }

  async voteAction(
    identifier: VoteAction.$Identifier,
  ): Promise<purify.Either<Error, VoteAction>> {
    return this.voteActionSync(identifier);
  }

  voteActionSync(
    identifier: VoteAction.$Identifier,
  ): purify.Either<Error, VoteAction> {
    return this.voteActionsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async voteActionIdentifiers(
    query?: $ObjectSet.Query<VoteAction.$Identifier>,
  ): Promise<purify.Either<Error, readonly VoteAction.$Identifier[]>> {
    return this.voteActionIdentifiersSync(query);
  }

  voteActionIdentifiersSync(
    query?: $ObjectSet.Query<VoteAction.$Identifier>,
  ): purify.Either<Error, readonly VoteAction.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<VoteAction, VoteAction.$Identifier>(
        VoteAction,
        query,
      ),
    ]);
  }

  async voteActions(
    query?: $ObjectSet.Query<VoteAction.$Identifier>,
  ): Promise<readonly purify.Either<Error, VoteAction>[]> {
    return this.voteActionsSync(query);
  }

  voteActionsSync(
    query?: $ObjectSet.Query<VoteAction.$Identifier>,
  ): readonly purify.Either<Error, VoteAction>[] {
    return [
      ...this.$objectsSync<VoteAction, VoteAction.$Identifier>(
        VoteAction,
        query,
      ),
    ];
  }

  async voteActionsCount(
    query?: Pick<$ObjectSet.Query<VoteAction.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.voteActionsCountSync(query);
  }

  voteActionsCountSync(
    query?: Pick<$ObjectSet.Query<VoteAction.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<VoteAction, VoteAction.$Identifier>(
      VoteAction,
      query,
    );
  }

  async voteActionStub(
    identifier: VoteActionStub.$Identifier,
  ): Promise<purify.Either<Error, VoteActionStub>> {
    return this.voteActionStubSync(identifier);
  }

  voteActionStubSync(
    identifier: VoteActionStub.$Identifier,
  ): purify.Either<Error, VoteActionStub> {
    return this.voteActionStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async voteActionStubIdentifiers(
    query?: $ObjectSet.Query<VoteActionStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly VoteActionStub.$Identifier[]>> {
    return this.voteActionStubIdentifiersSync(query);
  }

  voteActionStubIdentifiersSync(
    query?: $ObjectSet.Query<VoteActionStub.$Identifier>,
  ): purify.Either<Error, readonly VoteActionStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectIdentifiersSync<
        VoteActionStub,
        VoteActionStub.$Identifier
      >(VoteActionStub, query),
    ]);
  }

  async voteActionStubs(
    query?: $ObjectSet.Query<VoteActionStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, VoteActionStub>[]> {
    return this.voteActionStubsSync(query);
  }

  voteActionStubsSync(
    query?: $ObjectSet.Query<VoteActionStub.$Identifier>,
  ): readonly purify.Either<Error, VoteActionStub>[] {
    return [
      ...this.$objectsSync<VoteActionStub, VoteActionStub.$Identifier>(
        VoteActionStub,
        query,
      ),
    ];
  }

  async voteActionStubsCount(
    query?: Pick<$ObjectSet.Query<VoteActionStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.voteActionStubsCountSync(query);
  }

  voteActionStubsCountSync(
    query?: Pick<$ObjectSet.Query<VoteActionStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectsCountSync<VoteActionStub, VoteActionStub.$Identifier>(
      VoteActionStub,
      query,
    );
  }

  async agentStub(
    identifier: AgentStub.$Identifier,
  ): Promise<purify.Either<Error, AgentStub>> {
    return this.agentStubSync(identifier);
  }

  agentStubSync(
    identifier: AgentStub.$Identifier,
  ): purify.Either<Error, AgentStub> {
    return this.agentStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async agentStubIdentifiers(
    query?: $ObjectSet.Query<AgentStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly AgentStub.$Identifier[]>> {
    return this.agentStubIdentifiersSync(query);
  }

  agentStubIdentifiersSync(
    query?: $ObjectSet.Query<AgentStub.$Identifier>,
  ): purify.Either<Error, readonly AgentStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectUnionIdentifiersSync<AgentStub, AgentStub.$Identifier>(
        [OrganizationStubStatic, PersonStub],
        query,
      ),
    ]);
  }

  async agentStubs(
    query?: $ObjectSet.Query<AgentStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, AgentStub>[]> {
    return this.agentStubsSync(query);
  }

  agentStubsSync(
    query?: $ObjectSet.Query<AgentStub.$Identifier>,
  ): readonly purify.Either<Error, AgentStub>[] {
    return [
      ...this.$objectUnionsSync<AgentStub, AgentStub.$Identifier>(
        [OrganizationStubStatic, PersonStub],
        query,
      ),
    ];
  }

  async agentStubsCount(
    query?: Pick<$ObjectSet.Query<AgentStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.agentStubsCountSync(query);
  }

  agentStubsCountSync(
    query?: Pick<$ObjectSet.Query<AgentStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectUnionsCountSync<AgentStub, AgentStub.$Identifier>(
      [OrganizationStubStatic, PersonStub],
      query,
    );
  }

  async musicArtistStub(
    identifier: MusicArtistStub.$Identifier,
  ): Promise<purify.Either<Error, MusicArtistStub>> {
    return this.musicArtistStubSync(identifier);
  }

  musicArtistStubSync(
    identifier: MusicArtistStub.$Identifier,
  ): purify.Either<Error, MusicArtistStub> {
    return this.musicArtistStubsSync({
      where: { identifiers: [identifier], type: "identifiers" },
    })[0];
  }

  async musicArtistStubIdentifiers(
    query?: $ObjectSet.Query<MusicArtistStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicArtistStub.$Identifier[]>> {
    return this.musicArtistStubIdentifiersSync(query);
  }

  musicArtistStubIdentifiersSync(
    query?: $ObjectSet.Query<MusicArtistStub.$Identifier>,
  ): purify.Either<Error, readonly MusicArtistStub.$Identifier[]> {
    return purify.Either.of([
      ...this.$objectUnionIdentifiersSync<
        MusicArtistStub,
        MusicArtistStub.$Identifier
      >([MusicGroupStub, PersonStub], query),
    ]);
  }

  async musicArtistStubs(
    query?: $ObjectSet.Query<MusicArtistStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicArtistStub>[]> {
    return this.musicArtistStubsSync(query);
  }

  musicArtistStubsSync(
    query?: $ObjectSet.Query<MusicArtistStub.$Identifier>,
  ): readonly purify.Either<Error, MusicArtistStub>[] {
    return [
      ...this.$objectUnionsSync<MusicArtistStub, MusicArtistStub.$Identifier>(
        [MusicGroupStub, PersonStub],
        query,
      ),
    ];
  }

  async musicArtistStubsCount(
    query?: Pick<$ObjectSet.Query<MusicArtistStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.musicArtistStubsCountSync(query);
  }

  musicArtistStubsCountSync(
    query?: Pick<$ObjectSet.Query<MusicArtistStub.$Identifier>, "where">,
  ): purify.Either<Error, number> {
    return this.$objectUnionsCountSync<
      MusicArtistStub,
      MusicArtistStub.$Identifier
    >([MusicGroupStub, PersonStub], query);
  }

  protected *$objectIdentifiersSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $fromRdf: (parameters: {
        resource: rdfjsResource.Resource;
      }) => purify.Either<rdfjsResource.Resource.ValueError, ObjectT>;
      $fromRdfType?: rdfjs.NamedNode;
    },
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): Generator<ObjectIdentifierT> {
    for (const object of this.$objectsSync<ObjectT, ObjectIdentifierT>(
      objectType,
      query,
    )) {
      if (object.isRight()) {
        yield object.unsafeCoerce().$identifier;
      }
    }
  }

  protected *$objectsSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $fromRdf: (parameters: {
        resource: rdfjsResource.Resource;
      }) => purify.Either<rdfjsResource.Resource.ValueError, ObjectT>;
      $fromRdfType?: rdfjs.NamedNode;
    },
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): Generator<purify.Either<Error, ObjectT>> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return;
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    if (query?.where) {
      for (const identifier of query.where.identifiers.slice(
        offset,
        offset + limit,
      )) {
        yield objectType.$fromRdf({
          resource: this.resourceSet.resource(identifier),
        });
      }
      return;
    }

    if (!objectType.$fromRdfType) {
      return;
    }

    const resources = [
      ...this.resourceSet.instancesOf(objectType.$fromRdfType),
    ];
    // Sort resources by identifier so limit and offset are deterministic
    resources.sort((left, right) =>
      left.identifier.value.localeCompare(right.identifier.value),
    );

    let objectCount = 0;
    let objectI = 0;
    for (const resource of resources) {
      const object = objectType.$fromRdf({ resource });
      if (object.isLeft()) {
        continue;
      }
      if (objectI++ >= offset) {
        yield object;
        if (++objectCount === limit) {
          return;
        }
      }
    }
  }

  protected $objectsCountSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $fromRdf: (parameters: {
        resource: rdfjsResource.Resource;
      }) => purify.Either<rdfjsResource.Resource.ValueError, ObjectT>;
      $fromRdfType?: rdfjs.NamedNode;
    },
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): purify.Either<Error, number> {
    let count = 0;
    for (const _ of this.$objectIdentifiersSync<ObjectT, ObjectIdentifierT>(
      objectType,
      query,
    )) {
      count++;
    }

    return purify.Either.of(count);
  }

  protected *$objectUnionIdentifiersSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectTypes: readonly {
      $fromRdf: (parameters: {
        resource: rdfjsResource.Resource;
      }) => purify.Either<rdfjsResource.Resource.ValueError, ObjectT>;
      $fromRdfType?: rdfjs.NamedNode;
    }[],
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): Generator<ObjectIdentifierT> {
    for (const object of this.$objectUnionsSync<ObjectT, ObjectIdentifierT>(
      objectTypes,
      query,
    )) {
      if (object.isRight()) {
        yield object.unsafeCoerce().$identifier;
      }
    }
  }

  protected *$objectUnionsSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectTypes: readonly {
      $fromRdf: (parameters: {
        resource: rdfjsResource.Resource;
      }) => purify.Either<rdfjsResource.Resource.ValueError, ObjectT>;
      $fromRdfType?: rdfjs.NamedNode;
    }[],
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): Generator<purify.Either<Error, ObjectT>> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return;
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    if (query?.where) {
      // Figure out which object type the identifiers belong to
      for (const identifier of query.where.identifiers.slice(
        offset,
        offset + limit,
      )) {
        const resource = this.resourceSet.resource(identifier);
        const lefts: purify.Either<Error, ObjectT>[] = [];
        for (const objectType of objectTypes) {
          const object = objectType.$fromRdf({ resource });
          if (object.isRight()) {
            yield object;
            break;
          }
          lefts.push(object);
        }
        // Doesn't appear to belong to any of the known object types, just assume the first
        if (lefts.length === objectTypes.length) {
          yield lefts[0];
        }
      }

      return;
    }

    let objectCount = 0;
    let objectI = 0;

    const resources: {
      objectType: {
        $fromRdf: (parameters: {
          resource: rdfjsResource.Resource;
        }) => purify.Either<rdfjsResource.Resource.ValueError, ObjectT>;
        $fromRdfType?: rdfjs.NamedNode;
      };
      resource: rdfjsResource.Resource;
    }[] = [];
    for (const objectType of objectTypes) {
      if (!objectType.$fromRdfType) {
        continue;
      }

      for (const resource of this.resourceSet.instancesOf(
        objectType.$fromRdfType,
      )) {
        resources.push({ objectType, resource });
      }
    }

    // Sort resources by identifier so limit and offset are deterministic
    resources.sort((left, right) =>
      left.resource.identifier.value.localeCompare(
        right.resource.identifier.value,
      ),
    );

    for (const { objectType, resource } of resources) {
      const object = objectType.$fromRdf({ resource });
      if (object.isLeft()) {
        continue;
      }
      if (objectI++ >= offset) {
        yield object;
        if (++objectCount === limit) {
          return;
        }
      }
    }
  }

  protected $objectUnionsCountSync<
    ObjectT extends { readonly $identifier: ObjectIdentifierT },
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectTypes: readonly {
      $fromRdf: (parameters: {
        resource: rdfjsResource.Resource;
      }) => purify.Either<rdfjsResource.Resource.ValueError, ObjectT>;
      $fromRdfType?: rdfjs.NamedNode;
    }[],
    query?: $ObjectSet.Query<ObjectIdentifierT>,
  ): purify.Either<Error, number> {
    let count = 0;
    for (const _ of this.$objectUnionIdentifiersSync<
      ObjectT,
      ObjectIdentifierT
    >(objectTypes, query)) {
      count++;
    }

    return purify.Either.of(count);
  }
}

export class $SparqlObjectSet implements $ObjectSet {
  protected readonly $countVariable = dataFactory.variable!("count");
  protected readonly $objectVariable = dataFactory.variable!("object");
  protected readonly $sparqlClient: {
    queryBindings: (
      query: string,
    ) => Promise<
      readonly Record<
        string,
        rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
      >[]
    >;
    queryQuads: (query: string) => Promise<readonly rdfjs.Quad[]>;
  };
  protected readonly $sparqlGenerator = new sparqljs.Generator();

  constructor({
    sparqlClient,
  }: { sparqlClient: $SparqlObjectSet["$sparqlClient"] }) {
    this.$sparqlClient = sparqlClient;
  }

  async action(
    identifier: ActionStatic.$Identifier,
  ): Promise<purify.Either<Error, Action>> {
    return (
      await this.actions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async actionIdentifiers(
    query?: $SparqlObjectSet.Query<ActionStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ActionStatic.$Identifier[]>> {
    return this.$objectIdentifiers<ActionStatic.$Identifier>(
      ActionStatic,
      query,
    );
  }

  async actions(
    query?: $SparqlObjectSet.Query<ActionStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Action>[]> {
    return this.$objects<Action, ActionStatic.$Identifier>(ActionStatic, query);
  }

  async actionsCount(
    query?: Pick<$SparqlObjectSet.Query<ActionStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ActionStatic.$Identifier>(ActionStatic, query);
  }

  async actionStub(
    identifier: ActionStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ActionStub>> {
    return (
      await this.actionStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async actionStubIdentifiers(
    query?: $SparqlObjectSet.Query<ActionStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ActionStubStatic.$Identifier[]>> {
    return this.$objectIdentifiers<ActionStubStatic.$Identifier>(
      ActionStubStatic,
      query,
    );
  }

  async actionStubs(
    query?: $SparqlObjectSet.Query<ActionStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ActionStub>[]> {
    return this.$objects<ActionStub, ActionStubStatic.$Identifier>(
      ActionStubStatic,
      query,
    );
  }

  async actionStubsCount(
    query?: Pick<$SparqlObjectSet.Query<ActionStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ActionStubStatic.$Identifier>(
      ActionStubStatic,
      query,
    );
  }

  async article(
    identifier: ArticleStatic.$Identifier,
  ): Promise<purify.Either<Error, Article>> {
    return (
      await this.articles({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async articleIdentifiers(
    query?: $SparqlObjectSet.Query<ArticleStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ArticleStatic.$Identifier[]>> {
    return this.$objectIdentifiers<ArticleStatic.$Identifier>(
      ArticleStatic,
      query,
    );
  }

  async articles(
    query?: $SparqlObjectSet.Query<ArticleStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Article>[]> {
    return this.$objects<Article, ArticleStatic.$Identifier>(
      ArticleStatic,
      query,
    );
  }

  async articlesCount(
    query?: Pick<$SparqlObjectSet.Query<ArticleStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ArticleStatic.$Identifier>(ArticleStatic, query);
  }

  async articleStub(
    identifier: ArticleStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ArticleStub>> {
    return (
      await this.articleStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async articleStubIdentifiers(
    query?: $SparqlObjectSet.Query<ArticleStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ArticleStubStatic.$Identifier[]>> {
    return this.$objectIdentifiers<ArticleStubStatic.$Identifier>(
      ArticleStubStatic,
      query,
    );
  }

  async articleStubs(
    query?: $SparqlObjectSet.Query<ArticleStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ArticleStub>[]> {
    return this.$objects<ArticleStub, ArticleStubStatic.$Identifier>(
      ArticleStubStatic,
      query,
    );
  }

  async articleStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<ArticleStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ArticleStubStatic.$Identifier>(
      ArticleStubStatic,
      query,
    );
  }

  async assessAction(
    identifier: AssessActionStatic.$Identifier,
  ): Promise<purify.Either<Error, AssessAction>> {
    return (
      await this.assessActions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async assessActionIdentifiers(
    query?: $SparqlObjectSet.Query<AssessActionStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly AssessActionStatic.$Identifier[]>> {
    return this.$objectIdentifiers<AssessActionStatic.$Identifier>(
      AssessActionStatic,
      query,
    );
  }

  async assessActions(
    query?: $SparqlObjectSet.Query<AssessActionStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, AssessAction>[]> {
    return this.$objects<AssessAction, AssessActionStatic.$Identifier>(
      AssessActionStatic,
      query,
    );
  }

  async assessActionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<AssessActionStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<AssessActionStatic.$Identifier>(
      AssessActionStatic,
      query,
    );
  }

  async assessActionStub(
    identifier: AssessActionStubStatic.$Identifier,
  ): Promise<purify.Either<Error, AssessActionStub>> {
    return (
      await this.assessActionStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async assessActionStubIdentifiers(
    query?: $SparqlObjectSet.Query<AssessActionStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly AssessActionStubStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<AssessActionStubStatic.$Identifier>(
      AssessActionStubStatic,
      query,
    );
  }

  async assessActionStubs(
    query?: $SparqlObjectSet.Query<AssessActionStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, AssessActionStub>[]> {
    return this.$objects<AssessActionStub, AssessActionStubStatic.$Identifier>(
      AssessActionStubStatic,
      query,
    );
  }

  async assessActionStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<AssessActionStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<AssessActionStubStatic.$Identifier>(
      AssessActionStubStatic,
      query,
    );
  }

  async broadcastEvent(
    identifier: BroadcastEvent.$Identifier,
  ): Promise<purify.Either<Error, BroadcastEvent>> {
    return (
      await this.broadcastEvents({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async broadcastEventIdentifiers(
    query?: $SparqlObjectSet.Query<BroadcastEvent.$Identifier>,
  ): Promise<purify.Either<Error, readonly BroadcastEvent.$Identifier[]>> {
    return this.$objectIdentifiers<BroadcastEvent.$Identifier>(
      BroadcastEvent,
      query,
    );
  }

  async broadcastEvents(
    query?: $SparqlObjectSet.Query<BroadcastEvent.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastEvent>[]> {
    return this.$objects<BroadcastEvent, BroadcastEvent.$Identifier>(
      BroadcastEvent,
      query,
    );
  }

  async broadcastEventsCount(
    query?: Pick<$SparqlObjectSet.Query<BroadcastEvent.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BroadcastEvent.$Identifier>(
      BroadcastEvent,
      query,
    );
  }

  async broadcastEventStub(
    identifier: BroadcastEventStub.$Identifier,
  ): Promise<purify.Either<Error, BroadcastEventStub>> {
    return (
      await this.broadcastEventStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async broadcastEventStubIdentifiers(
    query?: $SparqlObjectSet.Query<BroadcastEventStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly BroadcastEventStub.$Identifier[]>> {
    return this.$objectIdentifiers<BroadcastEventStub.$Identifier>(
      BroadcastEventStub,
      query,
    );
  }

  async broadcastEventStubs(
    query?: $SparqlObjectSet.Query<BroadcastEventStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastEventStub>[]> {
    return this.$objects<BroadcastEventStub, BroadcastEventStub.$Identifier>(
      BroadcastEventStub,
      query,
    );
  }

  async broadcastEventStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<BroadcastEventStub.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BroadcastEventStub.$Identifier>(
      BroadcastEventStub,
      query,
    );
  }

  async broadcastService(
    identifier: BroadcastServiceStatic.$Identifier,
  ): Promise<purify.Either<Error, BroadcastService>> {
    return (
      await this.broadcastServices({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async broadcastServiceIdentifiers(
    query?: $SparqlObjectSet.Query<BroadcastServiceStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BroadcastServiceStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<BroadcastServiceStatic.$Identifier>(
      BroadcastServiceStatic,
      query,
    );
  }

  async broadcastServices(
    query?: $SparqlObjectSet.Query<BroadcastServiceStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastService>[]> {
    return this.$objects<BroadcastService, BroadcastServiceStatic.$Identifier>(
      BroadcastServiceStatic,
      query,
    );
  }

  async broadcastServicesCount(
    query?: Pick<
      $SparqlObjectSet.Query<BroadcastServiceStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BroadcastServiceStatic.$Identifier>(
      BroadcastServiceStatic,
      query,
    );
  }

  async broadcastServiceStub(
    identifier: BroadcastServiceStubStatic.$Identifier,
  ): Promise<purify.Either<Error, BroadcastServiceStub>> {
    return (
      await this.broadcastServiceStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async broadcastServiceStubIdentifiers(
    query?: $SparqlObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly BroadcastServiceStubStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<BroadcastServiceStubStatic.$Identifier>(
      BroadcastServiceStubStatic,
      query,
    );
  }

  async broadcastServiceStubs(
    query?: $SparqlObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, BroadcastServiceStub>[]> {
    return this.$objects<
      BroadcastServiceStub,
      BroadcastServiceStubStatic.$Identifier
    >(BroadcastServiceStubStatic, query);
  }

  async broadcastServiceStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<BroadcastServiceStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<BroadcastServiceStubStatic.$Identifier>(
      BroadcastServiceStubStatic,
      query,
    );
  }

  async chooseAction(
    identifier: ChooseActionStatic.$Identifier,
  ): Promise<purify.Either<Error, ChooseAction>> {
    return (
      await this.chooseActions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async chooseActionIdentifiers(
    query?: $SparqlObjectSet.Query<ChooseActionStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ChooseActionStatic.$Identifier[]>> {
    return this.$objectIdentifiers<ChooseActionStatic.$Identifier>(
      ChooseActionStatic,
      query,
    );
  }

  async chooseActions(
    query?: $SparqlObjectSet.Query<ChooseActionStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ChooseAction>[]> {
    return this.$objects<ChooseAction, ChooseActionStatic.$Identifier>(
      ChooseActionStatic,
      query,
    );
  }

  async chooseActionsCount(
    query?: Pick<
      $SparqlObjectSet.Query<ChooseActionStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ChooseActionStatic.$Identifier>(
      ChooseActionStatic,
      query,
    );
  }

  async chooseActionStub(
    identifier: ChooseActionStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ChooseActionStub>> {
    return (
      await this.chooseActionStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async chooseActionStubIdentifiers(
    query?: $SparqlObjectSet.Query<ChooseActionStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly ChooseActionStubStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<ChooseActionStubStatic.$Identifier>(
      ChooseActionStubStatic,
      query,
    );
  }

  async chooseActionStubs(
    query?: $SparqlObjectSet.Query<ChooseActionStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ChooseActionStub>[]> {
    return this.$objects<ChooseActionStub, ChooseActionStubStatic.$Identifier>(
      ChooseActionStubStatic,
      query,
    );
  }

  async chooseActionStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<ChooseActionStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ChooseActionStubStatic.$Identifier>(
      ChooseActionStubStatic,
      query,
    );
  }

  async creativeWork(
    identifier: CreativeWorkStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWork>> {
    return (
      await this.creativeWorks({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async creativeWorkIdentifiers(
    query?: $SparqlObjectSet.Query<CreativeWorkStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly CreativeWorkStatic.$Identifier[]>> {
    return this.$objectIdentifiers<CreativeWorkStatic.$Identifier>(
      CreativeWorkStatic,
      query,
    );
  }

  async creativeWorks(
    query?: $SparqlObjectSet.Query<CreativeWorkStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWork>[]> {
    return this.$objects<CreativeWork, CreativeWorkStatic.$Identifier>(
      CreativeWorkStatic,
      query,
    );
  }

  async creativeWorksCount(
    query?: Pick<
      $SparqlObjectSet.Query<CreativeWorkStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<CreativeWorkStatic.$Identifier>(
      CreativeWorkStatic,
      query,
    );
  }

  async creativeWorkSeries(
    identifier: CreativeWorkSeriesStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWorkSeries>> {
    return (
      await this.creativeWorkSeriess({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async creativeWorkSeriesIdentifiers(
    query?: $SparqlObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly CreativeWorkSeriesStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<CreativeWorkSeriesStatic.$Identifier>(
      CreativeWorkSeriesStatic,
      query,
    );
  }

  async creativeWorkSeriess(
    query?: $SparqlObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWorkSeries>[]> {
    return this.$objects<
      CreativeWorkSeries,
      CreativeWorkSeriesStatic.$Identifier
    >(CreativeWorkSeriesStatic, query);
  }

  async creativeWorkSeriessCount(
    query?: Pick<
      $SparqlObjectSet.Query<CreativeWorkSeriesStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<CreativeWorkSeriesStatic.$Identifier>(
      CreativeWorkSeriesStatic,
      query,
    );
  }

  async creativeWorkSeriesStub(
    identifier: CreativeWorkSeriesStubStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWorkSeriesStub>> {
    return (
      await this.creativeWorkSeriesStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async creativeWorkSeriesStubIdentifiers(
    query?: $SparqlObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly CreativeWorkSeriesStubStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<CreativeWorkSeriesStubStatic.$Identifier>(
      CreativeWorkSeriesStubStatic,
      query,
    );
  }

  async creativeWorkSeriesStubs(
    query?: $SparqlObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWorkSeriesStub>[]> {
    return this.$objects<
      CreativeWorkSeriesStub,
      CreativeWorkSeriesStubStatic.$Identifier
    >(CreativeWorkSeriesStubStatic, query);
  }

  async creativeWorkSeriesStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<CreativeWorkSeriesStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<CreativeWorkSeriesStubStatic.$Identifier>(
      CreativeWorkSeriesStubStatic,
      query,
    );
  }

  async creativeWorkStub(
    identifier: CreativeWorkStubStatic.$Identifier,
  ): Promise<purify.Either<Error, CreativeWorkStub>> {
    return (
      await this.creativeWorkStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async creativeWorkStubIdentifiers(
    query?: $SparqlObjectSet.Query<CreativeWorkStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly CreativeWorkStubStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<CreativeWorkStubStatic.$Identifier>(
      CreativeWorkStubStatic,
      query,
    );
  }

  async creativeWorkStubs(
    query?: $SparqlObjectSet.Query<CreativeWorkStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, CreativeWorkStub>[]> {
    return this.$objects<CreativeWorkStub, CreativeWorkStubStatic.$Identifier>(
      CreativeWorkStubStatic,
      query,
    );
  }

  async creativeWorkStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<CreativeWorkStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<CreativeWorkStubStatic.$Identifier>(
      CreativeWorkStubStatic,
      query,
    );
  }

  async enumeration(
    identifier: EnumerationStatic.$Identifier,
  ): Promise<purify.Either<Error, Enumeration>> {
    return (
      await this.enumerations({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async enumerationIdentifiers(
    query?: $SparqlObjectSet.Query<EnumerationStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EnumerationStatic.$Identifier[]>> {
    return this.$objectIdentifiers<EnumerationStatic.$Identifier>(
      EnumerationStatic,
      query,
    );
  }

  async enumerations(
    query?: $SparqlObjectSet.Query<EnumerationStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Enumeration>[]> {
    return this.$objects<Enumeration, EnumerationStatic.$Identifier>(
      EnumerationStatic,
      query,
    );
  }

  async enumerationsCount(
    query?: Pick<
      $SparqlObjectSet.Query<EnumerationStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<EnumerationStatic.$Identifier>(
      EnumerationStatic,
      query,
    );
  }

  async episode(
    identifier: EpisodeStatic.$Identifier,
  ): Promise<purify.Either<Error, Episode>> {
    return (
      await this.episodes({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async episodeIdentifiers(
    query?: $SparqlObjectSet.Query<EpisodeStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EpisodeStatic.$Identifier[]>> {
    return this.$objectIdentifiers<EpisodeStatic.$Identifier>(
      EpisodeStatic,
      query,
    );
  }

  async episodes(
    query?: $SparqlObjectSet.Query<EpisodeStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Episode>[]> {
    return this.$objects<Episode, EpisodeStatic.$Identifier>(
      EpisodeStatic,
      query,
    );
  }

  async episodesCount(
    query?: Pick<$SparqlObjectSet.Query<EpisodeStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<EpisodeStatic.$Identifier>(EpisodeStatic, query);
  }

  async episodeStub(
    identifier: EpisodeStubStatic.$Identifier,
  ): Promise<purify.Either<Error, EpisodeStub>> {
    return (
      await this.episodeStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async episodeStubIdentifiers(
    query?: $SparqlObjectSet.Query<EpisodeStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EpisodeStubStatic.$Identifier[]>> {
    return this.$objectIdentifiers<EpisodeStubStatic.$Identifier>(
      EpisodeStubStatic,
      query,
    );
  }

  async episodeStubs(
    query?: $SparqlObjectSet.Query<EpisodeStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, EpisodeStub>[]> {
    return this.$objects<EpisodeStub, EpisodeStubStatic.$Identifier>(
      EpisodeStubStatic,
      query,
    );
  }

  async episodeStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<EpisodeStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<EpisodeStubStatic.$Identifier>(
      EpisodeStubStatic,
      query,
    );
  }

  async event(
    identifier: EventStatic.$Identifier,
  ): Promise<purify.Either<Error, Event>> {
    return (
      await this.events({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async eventIdentifiers(
    query?: $SparqlObjectSet.Query<EventStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EventStatic.$Identifier[]>> {
    return this.$objectIdentifiers<EventStatic.$Identifier>(EventStatic, query);
  }

  async events(
    query?: $SparqlObjectSet.Query<EventStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Event>[]> {
    return this.$objects<Event, EventStatic.$Identifier>(EventStatic, query);
  }

  async eventsCount(
    query?: Pick<$SparqlObjectSet.Query<EventStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<EventStatic.$Identifier>(EventStatic, query);
  }

  async eventStub(
    identifier: EventStubStatic.$Identifier,
  ): Promise<purify.Either<Error, EventStub>> {
    return (
      await this.eventStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async eventStubIdentifiers(
    query?: $SparqlObjectSet.Query<EventStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly EventStubStatic.$Identifier[]>> {
    return this.$objectIdentifiers<EventStubStatic.$Identifier>(
      EventStubStatic,
      query,
    );
  }

  async eventStubs(
    query?: $SparqlObjectSet.Query<EventStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, EventStub>[]> {
    return this.$objects<EventStub, EventStubStatic.$Identifier>(
      EventStubStatic,
      query,
    );
  }

  async eventStubsCount(
    query?: Pick<$SparqlObjectSet.Query<EventStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<EventStubStatic.$Identifier>(
      EventStubStatic,
      query,
    );
  }

  async genderType(
    identifier: GenderType.$Identifier,
  ): Promise<purify.Either<Error, GenderType>> {
    return (
      await this.genderTypes({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async genderTypeIdentifiers(
    query?: $SparqlObjectSet.Query<GenderType.$Identifier>,
  ): Promise<purify.Either<Error, readonly GenderType.$Identifier[]>> {
    return this.$objectIdentifiers<GenderType.$Identifier>(GenderType, query);
  }

  async genderTypes(
    query?: $SparqlObjectSet.Query<GenderType.$Identifier>,
  ): Promise<readonly purify.Either<Error, GenderType>[]> {
    return this.$objects<GenderType, GenderType.$Identifier>(GenderType, query);
  }

  async genderTypesCount(
    query?: Pick<$SparqlObjectSet.Query<GenderType.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<GenderType.$Identifier>(GenderType, query);
  }

  async imageObject(
    identifier: ImageObject.$Identifier,
  ): Promise<purify.Either<Error, ImageObject>> {
    return (
      await this.imageObjects({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async imageObjectIdentifiers(
    query?: $SparqlObjectSet.Query<ImageObject.$Identifier>,
  ): Promise<purify.Either<Error, readonly ImageObject.$Identifier[]>> {
    return this.$objectIdentifiers<ImageObject.$Identifier>(ImageObject, query);
  }

  async imageObjects(
    query?: $SparqlObjectSet.Query<ImageObject.$Identifier>,
  ): Promise<readonly purify.Either<Error, ImageObject>[]> {
    return this.$objects<ImageObject, ImageObject.$Identifier>(
      ImageObject,
      query,
    );
  }

  async imageObjectsCount(
    query?: Pick<$SparqlObjectSet.Query<ImageObject.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ImageObject.$Identifier>(ImageObject, query);
  }

  async imageObjectStub(
    identifier: ImageObjectStub.$Identifier,
  ): Promise<purify.Either<Error, ImageObjectStub>> {
    return (
      await this.imageObjectStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async imageObjectStubIdentifiers(
    query?: $SparqlObjectSet.Query<ImageObjectStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ImageObjectStub.$Identifier[]>> {
    return this.$objectIdentifiers<ImageObjectStub.$Identifier>(
      ImageObjectStub,
      query,
    );
  }

  async imageObjectStubs(
    query?: $SparqlObjectSet.Query<ImageObjectStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ImageObjectStub>[]> {
    return this.$objects<ImageObjectStub, ImageObjectStub.$Identifier>(
      ImageObjectStub,
      query,
    );
  }

  async imageObjectStubsCount(
    query?: Pick<$SparqlObjectSet.Query<ImageObjectStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ImageObjectStub.$Identifier>(
      ImageObjectStub,
      query,
    );
  }

  async intangible(
    identifier: IntangibleStatic.$Identifier,
  ): Promise<purify.Either<Error, Intangible>> {
    return (
      await this.intangibles({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async intangibleIdentifiers(
    query?: $SparqlObjectSet.Query<IntangibleStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly IntangibleStatic.$Identifier[]>> {
    return this.$objectIdentifiers<IntangibleStatic.$Identifier>(
      IntangibleStatic,
      query,
    );
  }

  async intangibles(
    query?: $SparqlObjectSet.Query<IntangibleStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Intangible>[]> {
    return this.$objects<Intangible, IntangibleStatic.$Identifier>(
      IntangibleStatic,
      query,
    );
  }

  async intangiblesCount(
    query?: Pick<$SparqlObjectSet.Query<IntangibleStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IntangibleStatic.$Identifier>(
      IntangibleStatic,
      query,
    );
  }

  async intangibleStub(
    identifier: IntangibleStubStatic.$Identifier,
  ): Promise<purify.Either<Error, IntangibleStub>> {
    return (
      await this.intangibleStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async intangibleStubIdentifiers(
    query?: $SparqlObjectSet.Query<IntangibleStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly IntangibleStubStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<IntangibleStubStatic.$Identifier>(
      IntangibleStubStatic,
      query,
    );
  }

  async intangibleStubs(
    query?: $SparqlObjectSet.Query<IntangibleStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, IntangibleStub>[]> {
    return this.$objects<IntangibleStub, IntangibleStubStatic.$Identifier>(
      IntangibleStubStatic,
      query,
    );
  }

  async intangibleStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<IntangibleStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<IntangibleStubStatic.$Identifier>(
      IntangibleStubStatic,
      query,
    );
  }

  async invoice(
    identifier: Invoice.$Identifier,
  ): Promise<purify.Either<Error, Invoice>> {
    return (
      await this.invoices({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async invoiceIdentifiers(
    query?: $SparqlObjectSet.Query<Invoice.$Identifier>,
  ): Promise<purify.Either<Error, readonly Invoice.$Identifier[]>> {
    return this.$objectIdentifiers<Invoice.$Identifier>(Invoice, query);
  }

  async invoices(
    query?: $SparqlObjectSet.Query<Invoice.$Identifier>,
  ): Promise<readonly purify.Either<Error, Invoice>[]> {
    return this.$objects<Invoice, Invoice.$Identifier>(Invoice, query);
  }

  async invoicesCount(
    query?: Pick<$SparqlObjectSet.Query<Invoice.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Invoice.$Identifier>(Invoice, query);
  }

  async invoiceStub(
    identifier: InvoiceStub.$Identifier,
  ): Promise<purify.Either<Error, InvoiceStub>> {
    return (
      await this.invoiceStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async invoiceStubIdentifiers(
    query?: $SparqlObjectSet.Query<InvoiceStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly InvoiceStub.$Identifier[]>> {
    return this.$objectIdentifiers<InvoiceStub.$Identifier>(InvoiceStub, query);
  }

  async invoiceStubs(
    query?: $SparqlObjectSet.Query<InvoiceStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, InvoiceStub>[]> {
    return this.$objects<InvoiceStub, InvoiceStub.$Identifier>(
      InvoiceStub,
      query,
    );
  }

  async invoiceStubsCount(
    query?: Pick<$SparqlObjectSet.Query<InvoiceStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<InvoiceStub.$Identifier>(InvoiceStub, query);
  }

  async itemList(
    identifier: ItemList.$Identifier,
  ): Promise<purify.Either<Error, ItemList>> {
    return (
      await this.itemLists({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async itemListIdentifiers(
    query?: $SparqlObjectSet.Query<ItemList.$Identifier>,
  ): Promise<purify.Either<Error, readonly ItemList.$Identifier[]>> {
    return this.$objectIdentifiers<ItemList.$Identifier>(ItemList, query);
  }

  async itemLists(
    query?: $SparqlObjectSet.Query<ItemList.$Identifier>,
  ): Promise<readonly purify.Either<Error, ItemList>[]> {
    return this.$objects<ItemList, ItemList.$Identifier>(ItemList, query);
  }

  async itemListsCount(
    query?: Pick<$SparqlObjectSet.Query<ItemList.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ItemList.$Identifier>(ItemList, query);
  }

  async itemListStub(
    identifier: ItemListStub.$Identifier,
  ): Promise<purify.Either<Error, ItemListStub>> {
    return (
      await this.itemListStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async itemListStubIdentifiers(
    query?: $SparqlObjectSet.Query<ItemListStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ItemListStub.$Identifier[]>> {
    return this.$objectIdentifiers<ItemListStub.$Identifier>(
      ItemListStub,
      query,
    );
  }

  async itemListStubs(
    query?: $SparqlObjectSet.Query<ItemListStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ItemListStub>[]> {
    return this.$objects<ItemListStub, ItemListStub.$Identifier>(
      ItemListStub,
      query,
    );
  }

  async itemListStubsCount(
    query?: Pick<$SparqlObjectSet.Query<ItemListStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ItemListStub.$Identifier>(ItemListStub, query);
  }

  async listItem(
    identifier: ListItem.$Identifier,
  ): Promise<purify.Either<Error, ListItem>> {
    return (
      await this.listItems({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async listItemIdentifiers(
    query?: $SparqlObjectSet.Query<ListItem.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListItem.$Identifier[]>> {
    return this.$objectIdentifiers<ListItem.$Identifier>(ListItem, query);
  }

  async listItems(
    query?: $SparqlObjectSet.Query<ListItem.$Identifier>,
  ): Promise<readonly purify.Either<Error, ListItem>[]> {
    return this.$objects<ListItem, ListItem.$Identifier>(ListItem, query);
  }

  async listItemsCount(
    query?: Pick<$SparqlObjectSet.Query<ListItem.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ListItem.$Identifier>(ListItem, query);
  }

  async listItemStub(
    identifier: ListItemStub.$Identifier,
  ): Promise<purify.Either<Error, ListItemStub>> {
    return (
      await this.listItemStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async listItemStubIdentifiers(
    query?: $SparqlObjectSet.Query<ListItemStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ListItemStub.$Identifier[]>> {
    return this.$objectIdentifiers<ListItemStub.$Identifier>(
      ListItemStub,
      query,
    );
  }

  async listItemStubs(
    query?: $SparqlObjectSet.Query<ListItemStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ListItemStub>[]> {
    return this.$objects<ListItemStub, ListItemStub.$Identifier>(
      ListItemStub,
      query,
    );
  }

  async listItemStubsCount(
    query?: Pick<$SparqlObjectSet.Query<ListItemStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ListItemStub.$Identifier>(ListItemStub, query);
  }

  async mediaObject(
    identifier: MediaObjectStatic.$Identifier,
  ): Promise<purify.Either<Error, MediaObject>> {
    return (
      await this.mediaObjects({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async mediaObjectIdentifiers(
    query?: $SparqlObjectSet.Query<MediaObjectStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly MediaObjectStatic.$Identifier[]>> {
    return this.$objectIdentifiers<MediaObjectStatic.$Identifier>(
      MediaObjectStatic,
      query,
    );
  }

  async mediaObjects(
    query?: $SparqlObjectSet.Query<MediaObjectStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, MediaObject>[]> {
    return this.$objects<MediaObject, MediaObjectStatic.$Identifier>(
      MediaObjectStatic,
      query,
    );
  }

  async mediaObjectsCount(
    query?: Pick<
      $SparqlObjectSet.Query<MediaObjectStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MediaObjectStatic.$Identifier>(
      MediaObjectStatic,
      query,
    );
  }

  async mediaObjectStub(
    identifier: MediaObjectStubStatic.$Identifier,
  ): Promise<purify.Either<Error, MediaObjectStub>> {
    return (
      await this.mediaObjectStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async mediaObjectStubIdentifiers(
    query?: $SparqlObjectSet.Query<MediaObjectStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MediaObjectStubStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<MediaObjectStubStatic.$Identifier>(
      MediaObjectStubStatic,
      query,
    );
  }

  async mediaObjectStubs(
    query?: $SparqlObjectSet.Query<MediaObjectStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, MediaObjectStub>[]> {
    return this.$objects<MediaObjectStub, MediaObjectStubStatic.$Identifier>(
      MediaObjectStubStatic,
      query,
    );
  }

  async mediaObjectStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<MediaObjectStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MediaObjectStubStatic.$Identifier>(
      MediaObjectStubStatic,
      query,
    );
  }

  async message(
    identifier: Message.$Identifier,
  ): Promise<purify.Either<Error, Message>> {
    return (
      await this.messages({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async messageIdentifiers(
    query?: $SparqlObjectSet.Query<Message.$Identifier>,
  ): Promise<purify.Either<Error, readonly Message.$Identifier[]>> {
    return this.$objectIdentifiers<Message.$Identifier>(Message, query);
  }

  async messages(
    query?: $SparqlObjectSet.Query<Message.$Identifier>,
  ): Promise<readonly purify.Either<Error, Message>[]> {
    return this.$objects<Message, Message.$Identifier>(Message, query);
  }

  async messagesCount(
    query?: Pick<$SparqlObjectSet.Query<Message.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Message.$Identifier>(Message, query);
  }

  async messageStub(
    identifier: MessageStub.$Identifier,
  ): Promise<purify.Either<Error, MessageStub>> {
    return (
      await this.messageStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async messageStubIdentifiers(
    query?: $SparqlObjectSet.Query<MessageStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MessageStub.$Identifier[]>> {
    return this.$objectIdentifiers<MessageStub.$Identifier>(MessageStub, query);
  }

  async messageStubs(
    query?: $SparqlObjectSet.Query<MessageStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MessageStub>[]> {
    return this.$objects<MessageStub, MessageStub.$Identifier>(
      MessageStub,
      query,
    );
  }

  async messageStubsCount(
    query?: Pick<$SparqlObjectSet.Query<MessageStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MessageStub.$Identifier>(MessageStub, query);
  }

  async monetaryAmount(
    identifier: MonetaryAmount.$Identifier,
  ): Promise<purify.Either<Error, MonetaryAmount>> {
    return (
      await this.monetaryAmounts({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async monetaryAmountIdentifiers(
    query?: $SparqlObjectSet.Query<MonetaryAmount.$Identifier>,
  ): Promise<purify.Either<Error, readonly MonetaryAmount.$Identifier[]>> {
    return this.$objectIdentifiers<MonetaryAmount.$Identifier>(
      MonetaryAmount,
      query,
    );
  }

  async monetaryAmounts(
    query?: $SparqlObjectSet.Query<MonetaryAmount.$Identifier>,
  ): Promise<readonly purify.Either<Error, MonetaryAmount>[]> {
    return this.$objects<MonetaryAmount, MonetaryAmount.$Identifier>(
      MonetaryAmount,
      query,
    );
  }

  async monetaryAmountsCount(
    query?: Pick<$SparqlObjectSet.Query<MonetaryAmount.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MonetaryAmount.$Identifier>(
      MonetaryAmount,
      query,
    );
  }

  async monetaryAmountStub(
    identifier: MonetaryAmountStub.$Identifier,
  ): Promise<purify.Either<Error, MonetaryAmountStub>> {
    return (
      await this.monetaryAmountStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async monetaryAmountStubIdentifiers(
    query?: $SparqlObjectSet.Query<MonetaryAmountStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MonetaryAmountStub.$Identifier[]>> {
    return this.$objectIdentifiers<MonetaryAmountStub.$Identifier>(
      MonetaryAmountStub,
      query,
    );
  }

  async monetaryAmountStubs(
    query?: $SparqlObjectSet.Query<MonetaryAmountStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MonetaryAmountStub>[]> {
    return this.$objects<MonetaryAmountStub, MonetaryAmountStub.$Identifier>(
      MonetaryAmountStub,
      query,
    );
  }

  async monetaryAmountStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<MonetaryAmountStub.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MonetaryAmountStub.$Identifier>(
      MonetaryAmountStub,
      query,
    );
  }

  async musicAlbum(
    identifier: MusicAlbum.$Identifier,
  ): Promise<purify.Either<Error, MusicAlbum>> {
    return (
      await this.musicAlbums({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicAlbumIdentifiers(
    query?: $SparqlObjectSet.Query<MusicAlbum.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicAlbum.$Identifier[]>> {
    return this.$objectIdentifiers<MusicAlbum.$Identifier>(MusicAlbum, query);
  }

  async musicAlbums(
    query?: $SparqlObjectSet.Query<MusicAlbum.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicAlbum>[]> {
    return this.$objects<MusicAlbum, MusicAlbum.$Identifier>(MusicAlbum, query);
  }

  async musicAlbumsCount(
    query?: Pick<$SparqlObjectSet.Query<MusicAlbum.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicAlbum.$Identifier>(MusicAlbum, query);
  }

  async musicAlbumStub(
    identifier: MusicAlbumStub.$Identifier,
  ): Promise<purify.Either<Error, MusicAlbumStub>> {
    return (
      await this.musicAlbumStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicAlbumStubIdentifiers(
    query?: $SparqlObjectSet.Query<MusicAlbumStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicAlbumStub.$Identifier[]>> {
    return this.$objectIdentifiers<MusicAlbumStub.$Identifier>(
      MusicAlbumStub,
      query,
    );
  }

  async musicAlbumStubs(
    query?: $SparqlObjectSet.Query<MusicAlbumStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicAlbumStub>[]> {
    return this.$objects<MusicAlbumStub, MusicAlbumStub.$Identifier>(
      MusicAlbumStub,
      query,
    );
  }

  async musicAlbumStubsCount(
    query?: Pick<$SparqlObjectSet.Query<MusicAlbumStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicAlbumStub.$Identifier>(
      MusicAlbumStub,
      query,
    );
  }

  async musicArtistRoleStub(
    identifier: MusicArtistRoleStub.$Identifier,
  ): Promise<purify.Either<Error, MusicArtistRoleStub>> {
    return (
      await this.musicArtistRoleStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicArtistRoleStubIdentifiers(
    query?: $SparqlObjectSet.Query<MusicArtistRoleStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicArtistRoleStub.$Identifier[]>> {
    return this.$objectIdentifiers<MusicArtistRoleStub.$Identifier>(
      MusicArtistRoleStub,
      query,
    );
  }

  async musicArtistRoleStubs(
    query?: $SparqlObjectSet.Query<MusicArtistRoleStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicArtistRoleStub>[]> {
    return this.$objects<MusicArtistRoleStub, MusicArtistRoleStub.$Identifier>(
      MusicArtistRoleStub,
      query,
    );
  }

  async musicArtistRoleStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<MusicArtistRoleStub.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicArtistRoleStub.$Identifier>(
      MusicArtistRoleStub,
      query,
    );
  }

  async musicComposition(
    identifier: MusicComposition.$Identifier,
  ): Promise<purify.Either<Error, MusicComposition>> {
    return (
      await this.musicCompositions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicCompositionIdentifiers(
    query?: $SparqlObjectSet.Query<MusicComposition.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicComposition.$Identifier[]>> {
    return this.$objectIdentifiers<MusicComposition.$Identifier>(
      MusicComposition,
      query,
    );
  }

  async musicCompositions(
    query?: $SparqlObjectSet.Query<MusicComposition.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicComposition>[]> {
    return this.$objects<MusicComposition, MusicComposition.$Identifier>(
      MusicComposition,
      query,
    );
  }

  async musicCompositionsCount(
    query?: Pick<$SparqlObjectSet.Query<MusicComposition.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicComposition.$Identifier>(
      MusicComposition,
      query,
    );
  }

  async musicCompositionStub(
    identifier: MusicCompositionStub.$Identifier,
  ): Promise<purify.Either<Error, MusicCompositionStub>> {
    return (
      await this.musicCompositionStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicCompositionStubIdentifiers(
    query?: $SparqlObjectSet.Query<MusicCompositionStub.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly MusicCompositionStub.$Identifier[]>
  > {
    return this.$objectIdentifiers<MusicCompositionStub.$Identifier>(
      MusicCompositionStub,
      query,
    );
  }

  async musicCompositionStubs(
    query?: $SparqlObjectSet.Query<MusicCompositionStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicCompositionStub>[]> {
    return this.$objects<
      MusicCompositionStub,
      MusicCompositionStub.$Identifier
    >(MusicCompositionStub, query);
  }

  async musicCompositionStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<MusicCompositionStub.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicCompositionStub.$Identifier>(
      MusicCompositionStub,
      query,
    );
  }

  async musicGroup(
    identifier: MusicGroup.$Identifier,
  ): Promise<purify.Either<Error, MusicGroup>> {
    return (
      await this.musicGroups({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicGroupIdentifiers(
    query?: $SparqlObjectSet.Query<MusicGroup.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicGroup.$Identifier[]>> {
    return this.$objectIdentifiers<MusicGroup.$Identifier>(MusicGroup, query);
  }

  async musicGroups(
    query?: $SparqlObjectSet.Query<MusicGroup.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicGroup>[]> {
    return this.$objects<MusicGroup, MusicGroup.$Identifier>(MusicGroup, query);
  }

  async musicGroupsCount(
    query?: Pick<$SparqlObjectSet.Query<MusicGroup.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicGroup.$Identifier>(MusicGroup, query);
  }

  async musicGroupStub(
    identifier: MusicGroupStub.$Identifier,
  ): Promise<purify.Either<Error, MusicGroupStub>> {
    return (
      await this.musicGroupStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicGroupStubIdentifiers(
    query?: $SparqlObjectSet.Query<MusicGroupStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicGroupStub.$Identifier[]>> {
    return this.$objectIdentifiers<MusicGroupStub.$Identifier>(
      MusicGroupStub,
      query,
    );
  }

  async musicGroupStubs(
    query?: $SparqlObjectSet.Query<MusicGroupStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicGroupStub>[]> {
    return this.$objects<MusicGroupStub, MusicGroupStub.$Identifier>(
      MusicGroupStub,
      query,
    );
  }

  async musicGroupStubsCount(
    query?: Pick<$SparqlObjectSet.Query<MusicGroupStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicGroupStub.$Identifier>(
      MusicGroupStub,
      query,
    );
  }

  async musicPlaylist(
    identifier: MusicPlaylist.$Identifier,
  ): Promise<purify.Either<Error, MusicPlaylist>> {
    return (
      await this.musicPlaylists({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicPlaylistIdentifiers(
    query?: $SparqlObjectSet.Query<MusicPlaylist.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicPlaylist.$Identifier[]>> {
    return this.$objectIdentifiers<MusicPlaylist.$Identifier>(
      MusicPlaylist,
      query,
    );
  }

  async musicPlaylists(
    query?: $SparqlObjectSet.Query<MusicPlaylist.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicPlaylist>[]> {
    return this.$objects<MusicPlaylist, MusicPlaylist.$Identifier>(
      MusicPlaylist,
      query,
    );
  }

  async musicPlaylistsCount(
    query?: Pick<$SparqlObjectSet.Query<MusicPlaylist.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicPlaylist.$Identifier>(MusicPlaylist, query);
  }

  async musicPlaylistStub(
    identifier: MusicPlaylistStub.$Identifier,
  ): Promise<purify.Either<Error, MusicPlaylistStub>> {
    return (
      await this.musicPlaylistStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicPlaylistStubIdentifiers(
    query?: $SparqlObjectSet.Query<MusicPlaylistStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicPlaylistStub.$Identifier[]>> {
    return this.$objectIdentifiers<MusicPlaylistStub.$Identifier>(
      MusicPlaylistStub,
      query,
    );
  }

  async musicPlaylistStubs(
    query?: $SparqlObjectSet.Query<MusicPlaylistStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicPlaylistStub>[]> {
    return this.$objects<MusicPlaylistStub, MusicPlaylistStub.$Identifier>(
      MusicPlaylistStub,
      query,
    );
  }

  async musicPlaylistStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<MusicPlaylistStub.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicPlaylistStub.$Identifier>(
      MusicPlaylistStub,
      query,
    );
  }

  async musicRecording(
    identifier: MusicRecording.$Identifier,
  ): Promise<purify.Either<Error, MusicRecording>> {
    return (
      await this.musicRecordings({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicRecordingIdentifiers(
    query?: $SparqlObjectSet.Query<MusicRecording.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicRecording.$Identifier[]>> {
    return this.$objectIdentifiers<MusicRecording.$Identifier>(
      MusicRecording,
      query,
    );
  }

  async musicRecordings(
    query?: $SparqlObjectSet.Query<MusicRecording.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicRecording>[]> {
    return this.$objects<MusicRecording, MusicRecording.$Identifier>(
      MusicRecording,
      query,
    );
  }

  async musicRecordingsCount(
    query?: Pick<$SparqlObjectSet.Query<MusicRecording.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicRecording.$Identifier>(
      MusicRecording,
      query,
    );
  }

  async musicRecordingStub(
    identifier: MusicRecordingStub.$Identifier,
  ): Promise<purify.Either<Error, MusicRecordingStub>> {
    return (
      await this.musicRecordingStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicRecordingStubIdentifiers(
    query?: $SparqlObjectSet.Query<MusicRecordingStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicRecordingStub.$Identifier[]>> {
    return this.$objectIdentifiers<MusicRecordingStub.$Identifier>(
      MusicRecordingStub,
      query,
    );
  }

  async musicRecordingStubs(
    query?: $SparqlObjectSet.Query<MusicRecordingStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicRecordingStub>[]> {
    return this.$objects<MusicRecordingStub, MusicRecordingStub.$Identifier>(
      MusicRecordingStub,
      query,
    );
  }

  async musicRecordingStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<MusicRecordingStub.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicRecordingStub.$Identifier>(
      MusicRecordingStub,
      query,
    );
  }

  async occupationStub(
    identifier: OccupationStub.$Identifier,
  ): Promise<purify.Either<Error, OccupationStub>> {
    return (
      await this.occupationStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async occupationStubIdentifiers(
    query?: $SparqlObjectSet.Query<OccupationStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly OccupationStub.$Identifier[]>> {
    return this.$objectIdentifiers<OccupationStub.$Identifier>(
      OccupationStub,
      query,
    );
  }

  async occupationStubs(
    query?: $SparqlObjectSet.Query<OccupationStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, OccupationStub>[]> {
    return this.$objects<OccupationStub, OccupationStub.$Identifier>(
      OccupationStub,
      query,
    );
  }

  async occupationStubsCount(
    query?: Pick<$SparqlObjectSet.Query<OccupationStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<OccupationStub.$Identifier>(
      OccupationStub,
      query,
    );
  }

  async order(
    identifier: Order.$Identifier,
  ): Promise<purify.Either<Error, Order>> {
    return (
      await this.orders({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async orderIdentifiers(
    query?: $SparqlObjectSet.Query<Order.$Identifier>,
  ): Promise<purify.Either<Error, readonly Order.$Identifier[]>> {
    return this.$objectIdentifiers<Order.$Identifier>(Order, query);
  }

  async orders(
    query?: $SparqlObjectSet.Query<Order.$Identifier>,
  ): Promise<readonly purify.Either<Error, Order>[]> {
    return this.$objects<Order, Order.$Identifier>(Order, query);
  }

  async ordersCount(
    query?: Pick<$SparqlObjectSet.Query<Order.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Order.$Identifier>(Order, query);
  }

  async orderStub(
    identifier: OrderStub.$Identifier,
  ): Promise<purify.Either<Error, OrderStub>> {
    return (
      await this.orderStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async orderStubIdentifiers(
    query?: $SparqlObjectSet.Query<OrderStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrderStub.$Identifier[]>> {
    return this.$objectIdentifiers<OrderStub.$Identifier>(OrderStub, query);
  }

  async orderStubs(
    query?: $SparqlObjectSet.Query<OrderStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, OrderStub>[]> {
    return this.$objects<OrderStub, OrderStub.$Identifier>(OrderStub, query);
  }

  async orderStubsCount(
    query?: Pick<$SparqlObjectSet.Query<OrderStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<OrderStub.$Identifier>(OrderStub, query);
  }

  async organization(
    identifier: OrganizationStatic.$Identifier,
  ): Promise<purify.Either<Error, Organization>> {
    return (
      await this.organizations({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async organizationIdentifiers(
    query?: $SparqlObjectSet.Query<OrganizationStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly OrganizationStatic.$Identifier[]>> {
    return this.$objectIdentifiers<OrganizationStatic.$Identifier>(
      OrganizationStatic,
      query,
    );
  }

  async organizations(
    query?: $SparqlObjectSet.Query<OrganizationStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Organization>[]> {
    return this.$objects<Organization, OrganizationStatic.$Identifier>(
      OrganizationStatic,
      query,
    );
  }

  async organizationsCount(
    query?: Pick<
      $SparqlObjectSet.Query<OrganizationStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<OrganizationStatic.$Identifier>(
      OrganizationStatic,
      query,
    );
  }

  async organizationStub(
    identifier: OrganizationStubStatic.$Identifier,
  ): Promise<purify.Either<Error, OrganizationStub>> {
    return (
      await this.organizationStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async organizationStubIdentifiers(
    query?: $SparqlObjectSet.Query<OrganizationStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly OrganizationStubStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<OrganizationStubStatic.$Identifier>(
      OrganizationStubStatic,
      query,
    );
  }

  async organizationStubs(
    query?: $SparqlObjectSet.Query<OrganizationStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, OrganizationStub>[]> {
    return this.$objects<OrganizationStub, OrganizationStubStatic.$Identifier>(
      OrganizationStubStatic,
      query,
    );
  }

  async organizationStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<OrganizationStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<OrganizationStubStatic.$Identifier>(
      OrganizationStubStatic,
      query,
    );
  }

  async performingGroup(
    identifier: PerformingGroupStatic.$Identifier,
  ): Promise<purify.Either<Error, PerformingGroup>> {
    return (
      await this.performingGroups({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async performingGroupIdentifiers(
    query?: $SparqlObjectSet.Query<PerformingGroupStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PerformingGroupStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<PerformingGroupStatic.$Identifier>(
      PerformingGroupStatic,
      query,
    );
  }

  async performingGroups(
    query?: $SparqlObjectSet.Query<PerformingGroupStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PerformingGroup>[]> {
    return this.$objects<PerformingGroup, PerformingGroupStatic.$Identifier>(
      PerformingGroupStatic,
      query,
    );
  }

  async performingGroupsCount(
    query?: Pick<
      $SparqlObjectSet.Query<PerformingGroupStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PerformingGroupStatic.$Identifier>(
      PerformingGroupStatic,
      query,
    );
  }

  async performingGroupStub(
    identifier: PerformingGroupStubStatic.$Identifier,
  ): Promise<purify.Either<Error, PerformingGroupStub>> {
    return (
      await this.performingGroupStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async performingGroupStubIdentifiers(
    query?: $SparqlObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PerformingGroupStubStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<PerformingGroupStubStatic.$Identifier>(
      PerformingGroupStubStatic,
      query,
    );
  }

  async performingGroupStubs(
    query?: $SparqlObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PerformingGroupStub>[]> {
    return this.$objects<
      PerformingGroupStub,
      PerformingGroupStubStatic.$Identifier
    >(PerformingGroupStubStatic, query);
  }

  async performingGroupStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<PerformingGroupStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PerformingGroupStubStatic.$Identifier>(
      PerformingGroupStubStatic,
      query,
    );
  }

  async person(
    identifier: Person.$Identifier,
  ): Promise<purify.Either<Error, Person>> {
    return (
      await this.people({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async personIdentifiers(
    query?: $SparqlObjectSet.Query<Person.$Identifier>,
  ): Promise<purify.Either<Error, readonly Person.$Identifier[]>> {
    return this.$objectIdentifiers<Person.$Identifier>(Person, query);
  }

  async people(
    query?: $SparqlObjectSet.Query<Person.$Identifier>,
  ): Promise<readonly purify.Either<Error, Person>[]> {
    return this.$objects<Person, Person.$Identifier>(Person, query);
  }

  async peopleCount(
    query?: Pick<$SparqlObjectSet.Query<Person.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Person.$Identifier>(Person, query);
  }

  async personStub(
    identifier: PersonStub.$Identifier,
  ): Promise<purify.Either<Error, PersonStub>> {
    return (
      await this.personStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async personStubIdentifiers(
    query?: $SparqlObjectSet.Query<PersonStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly PersonStub.$Identifier[]>> {
    return this.$objectIdentifiers<PersonStub.$Identifier>(PersonStub, query);
  }

  async personStubs(
    query?: $SparqlObjectSet.Query<PersonStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, PersonStub>[]> {
    return this.$objects<PersonStub, PersonStub.$Identifier>(PersonStub, query);
  }

  async personStubsCount(
    query?: Pick<$SparqlObjectSet.Query<PersonStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PersonStub.$Identifier>(PersonStub, query);
  }

  async place(
    identifier: Place.$Identifier,
  ): Promise<purify.Either<Error, Place>> {
    return (
      await this.places({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async placeIdentifiers(
    query?: $SparqlObjectSet.Query<Place.$Identifier>,
  ): Promise<purify.Either<Error, readonly Place.$Identifier[]>> {
    return this.$objectIdentifiers<Place.$Identifier>(Place, query);
  }

  async places(
    query?: $SparqlObjectSet.Query<Place.$Identifier>,
  ): Promise<readonly purify.Either<Error, Place>[]> {
    return this.$objects<Place, Place.$Identifier>(Place, query);
  }

  async placesCount(
    query?: Pick<$SparqlObjectSet.Query<Place.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Place.$Identifier>(Place, query);
  }

  async placeStub(
    identifier: PlaceStub.$Identifier,
  ): Promise<purify.Either<Error, PlaceStub>> {
    return (
      await this.placeStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async placeStubIdentifiers(
    query?: $SparqlObjectSet.Query<PlaceStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly PlaceStub.$Identifier[]>> {
    return this.$objectIdentifiers<PlaceStub.$Identifier>(PlaceStub, query);
  }

  async placeStubs(
    query?: $SparqlObjectSet.Query<PlaceStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, PlaceStub>[]> {
    return this.$objects<PlaceStub, PlaceStub.$Identifier>(PlaceStub, query);
  }

  async placeStubsCount(
    query?: Pick<$SparqlObjectSet.Query<PlaceStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PlaceStub.$Identifier>(PlaceStub, query);
  }

  async publicationEvent(
    identifier: PublicationEventStatic.$Identifier,
  ): Promise<purify.Either<Error, PublicationEvent>> {
    return (
      await this.publicationEvents({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async publicationEventIdentifiers(
    query?: $SparqlObjectSet.Query<PublicationEventStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PublicationEventStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<PublicationEventStatic.$Identifier>(
      PublicationEventStatic,
      query,
    );
  }

  async publicationEvents(
    query?: $SparqlObjectSet.Query<PublicationEventStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PublicationEvent>[]> {
    return this.$objects<PublicationEvent, PublicationEventStatic.$Identifier>(
      PublicationEventStatic,
      query,
    );
  }

  async publicationEventsCount(
    query?: Pick<
      $SparqlObjectSet.Query<PublicationEventStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PublicationEventStatic.$Identifier>(
      PublicationEventStatic,
      query,
    );
  }

  async publicationEventStub(
    identifier: PublicationEventStubStatic.$Identifier,
  ): Promise<purify.Either<Error, PublicationEventStub>> {
    return (
      await this.publicationEventStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async publicationEventStubIdentifiers(
    query?: $SparqlObjectSet.Query<PublicationEventStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly PublicationEventStubStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<PublicationEventStubStatic.$Identifier>(
      PublicationEventStubStatic,
      query,
    );
  }

  async publicationEventStubs(
    query?: $SparqlObjectSet.Query<PublicationEventStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, PublicationEventStub>[]> {
    return this.$objects<
      PublicationEventStub,
      PublicationEventStubStatic.$Identifier
    >(PublicationEventStubStatic, query);
  }

  async publicationEventStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<PublicationEventStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<PublicationEventStubStatic.$Identifier>(
      PublicationEventStubStatic,
      query,
    );
  }

  async quantitativeValue(
    identifier: QuantitativeValue.$Identifier,
  ): Promise<purify.Either<Error, QuantitativeValue>> {
    return (
      await this.quantitativeValues({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async quantitativeValueIdentifiers(
    query?: $SparqlObjectSet.Query<QuantitativeValue.$Identifier>,
  ): Promise<purify.Either<Error, readonly QuantitativeValue.$Identifier[]>> {
    return this.$objectIdentifiers<QuantitativeValue.$Identifier>(
      QuantitativeValue,
      query,
    );
  }

  async quantitativeValues(
    query?: $SparqlObjectSet.Query<QuantitativeValue.$Identifier>,
  ): Promise<readonly purify.Either<Error, QuantitativeValue>[]> {
    return this.$objects<QuantitativeValue, QuantitativeValue.$Identifier>(
      QuantitativeValue,
      query,
    );
  }

  async quantitativeValuesCount(
    query?: Pick<
      $SparqlObjectSet.Query<QuantitativeValue.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<QuantitativeValue.$Identifier>(
      QuantitativeValue,
      query,
    );
  }

  async quantitativeValueStub(
    identifier: QuantitativeValueStub.$Identifier,
  ): Promise<purify.Either<Error, QuantitativeValueStub>> {
    return (
      await this.quantitativeValueStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async quantitativeValueStubIdentifiers(
    query?: $SparqlObjectSet.Query<QuantitativeValueStub.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly QuantitativeValueStub.$Identifier[]>
  > {
    return this.$objectIdentifiers<QuantitativeValueStub.$Identifier>(
      QuantitativeValueStub,
      query,
    );
  }

  async quantitativeValueStubs(
    query?: $SparqlObjectSet.Query<QuantitativeValueStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, QuantitativeValueStub>[]> {
    return this.$objects<
      QuantitativeValueStub,
      QuantitativeValueStub.$Identifier
    >(QuantitativeValueStub, query);
  }

  async quantitativeValueStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<QuantitativeValueStub.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<QuantitativeValueStub.$Identifier>(
      QuantitativeValueStub,
      query,
    );
  }

  async radioBroadcastService(
    identifier: RadioBroadcastService.$Identifier,
  ): Promise<purify.Either<Error, RadioBroadcastService>> {
    return (
      await this.radioBroadcastServices({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async radioBroadcastServiceIdentifiers(
    query?: $SparqlObjectSet.Query<RadioBroadcastService.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RadioBroadcastService.$Identifier[]>
  > {
    return this.$objectIdentifiers<RadioBroadcastService.$Identifier>(
      RadioBroadcastService,
      query,
    );
  }

  async radioBroadcastServices(
    query?: $SparqlObjectSet.Query<RadioBroadcastService.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioBroadcastService>[]> {
    return this.$objects<
      RadioBroadcastService,
      RadioBroadcastService.$Identifier
    >(RadioBroadcastService, query);
  }

  async radioBroadcastServicesCount(
    query?: Pick<
      $SparqlObjectSet.Query<RadioBroadcastService.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RadioBroadcastService.$Identifier>(
      RadioBroadcastService,
      query,
    );
  }

  async radioBroadcastServiceStub(
    identifier: RadioBroadcastServiceStub.$Identifier,
  ): Promise<purify.Either<Error, RadioBroadcastServiceStub>> {
    return (
      await this.radioBroadcastServiceStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async radioBroadcastServiceStubIdentifiers(
    query?: $SparqlObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly RadioBroadcastServiceStub.$Identifier[]>
  > {
    return this.$objectIdentifiers<RadioBroadcastServiceStub.$Identifier>(
      RadioBroadcastServiceStub,
      query,
    );
  }

  async radioBroadcastServiceStubs(
    query?: $SparqlObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioBroadcastServiceStub>[]> {
    return this.$objects<
      RadioBroadcastServiceStub,
      RadioBroadcastServiceStub.$Identifier
    >(RadioBroadcastServiceStub, query);
  }

  async radioBroadcastServiceStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<RadioBroadcastServiceStub.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RadioBroadcastServiceStub.$Identifier>(
      RadioBroadcastServiceStub,
      query,
    );
  }

  async radioEpisode(
    identifier: RadioEpisode.$Identifier,
  ): Promise<purify.Either<Error, RadioEpisode>> {
    return (
      await this.radioEpisodes({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async radioEpisodeIdentifiers(
    query?: $SparqlObjectSet.Query<RadioEpisode.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioEpisode.$Identifier[]>> {
    return this.$objectIdentifiers<RadioEpisode.$Identifier>(
      RadioEpisode,
      query,
    );
  }

  async radioEpisodes(
    query?: $SparqlObjectSet.Query<RadioEpisode.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioEpisode>[]> {
    return this.$objects<RadioEpisode, RadioEpisode.$Identifier>(
      RadioEpisode,
      query,
    );
  }

  async radioEpisodesCount(
    query?: Pick<$SparqlObjectSet.Query<RadioEpisode.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RadioEpisode.$Identifier>(RadioEpisode, query);
  }

  async radioEpisodeStub(
    identifier: RadioEpisodeStub.$Identifier,
  ): Promise<purify.Either<Error, RadioEpisodeStub>> {
    return (
      await this.radioEpisodeStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async radioEpisodeStubIdentifiers(
    query?: $SparqlObjectSet.Query<RadioEpisodeStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioEpisodeStub.$Identifier[]>> {
    return this.$objectIdentifiers<RadioEpisodeStub.$Identifier>(
      RadioEpisodeStub,
      query,
    );
  }

  async radioEpisodeStubs(
    query?: $SparqlObjectSet.Query<RadioEpisodeStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioEpisodeStub>[]> {
    return this.$objects<RadioEpisodeStub, RadioEpisodeStub.$Identifier>(
      RadioEpisodeStub,
      query,
    );
  }

  async radioEpisodeStubsCount(
    query?: Pick<$SparqlObjectSet.Query<RadioEpisodeStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RadioEpisodeStub.$Identifier>(
      RadioEpisodeStub,
      query,
    );
  }

  async radioSeries(
    identifier: RadioSeries.$Identifier,
  ): Promise<purify.Either<Error, RadioSeries>> {
    return (
      await this.radioSeriess({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async radioSeriesIdentifiers(
    query?: $SparqlObjectSet.Query<RadioSeries.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioSeries.$Identifier[]>> {
    return this.$objectIdentifiers<RadioSeries.$Identifier>(RadioSeries, query);
  }

  async radioSeriess(
    query?: $SparqlObjectSet.Query<RadioSeries.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioSeries>[]> {
    return this.$objects<RadioSeries, RadioSeries.$Identifier>(
      RadioSeries,
      query,
    );
  }

  async radioSeriessCount(
    query?: Pick<$SparqlObjectSet.Query<RadioSeries.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RadioSeries.$Identifier>(RadioSeries, query);
  }

  async radioSeriesStub(
    identifier: RadioSeriesStub.$Identifier,
  ): Promise<purify.Either<Error, RadioSeriesStub>> {
    return (
      await this.radioSeriesStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async radioSeriesStubIdentifiers(
    query?: $SparqlObjectSet.Query<RadioSeriesStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly RadioSeriesStub.$Identifier[]>> {
    return this.$objectIdentifiers<RadioSeriesStub.$Identifier>(
      RadioSeriesStub,
      query,
    );
  }

  async radioSeriesStubs(
    query?: $SparqlObjectSet.Query<RadioSeriesStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RadioSeriesStub>[]> {
    return this.$objects<RadioSeriesStub, RadioSeriesStub.$Identifier>(
      RadioSeriesStub,
      query,
    );
  }

  async radioSeriesStubsCount(
    query?: Pick<$SparqlObjectSet.Query<RadioSeriesStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RadioSeriesStub.$Identifier>(
      RadioSeriesStub,
      query,
    );
  }

  async report(
    identifier: Report.$Identifier,
  ): Promise<purify.Either<Error, Report>> {
    return (
      await this.reports({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async reportIdentifiers(
    query?: $SparqlObjectSet.Query<Report.$Identifier>,
  ): Promise<purify.Either<Error, readonly Report.$Identifier[]>> {
    return this.$objectIdentifiers<Report.$Identifier>(Report, query);
  }

  async reports(
    query?: $SparqlObjectSet.Query<Report.$Identifier>,
  ): Promise<readonly purify.Either<Error, Report>[]> {
    return this.$objects<Report, Report.$Identifier>(Report, query);
  }

  async reportsCount(
    query?: Pick<$SparqlObjectSet.Query<Report.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<Report.$Identifier>(Report, query);
  }

  async reportStub(
    identifier: ReportStub.$Identifier,
  ): Promise<purify.Either<Error, ReportStub>> {
    return (
      await this.reportStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async reportStubIdentifiers(
    query?: $SparqlObjectSet.Query<ReportStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly ReportStub.$Identifier[]>> {
    return this.$objectIdentifiers<ReportStub.$Identifier>(ReportStub, query);
  }

  async reportStubs(
    query?: $SparqlObjectSet.Query<ReportStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, ReportStub>[]> {
    return this.$objects<ReportStub, ReportStub.$Identifier>(ReportStub, query);
  }

  async reportStubsCount(
    query?: Pick<$SparqlObjectSet.Query<ReportStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ReportStub.$Identifier>(ReportStub, query);
  }

  async roleStub(
    identifier: RoleStub.$Identifier,
  ): Promise<purify.Either<Error, RoleStub>> {
    return (
      await this.roleStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async roleStubIdentifiers(
    query?: $SparqlObjectSet.Query<RoleStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly RoleStub.$Identifier[]>> {
    return this.$objectIdentifiers<RoleStub.$Identifier>(RoleStub, query);
  }

  async roleStubs(
    query?: $SparqlObjectSet.Query<RoleStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, RoleStub>[]> {
    return this.$objects<RoleStub, RoleStub.$Identifier>(RoleStub, query);
  }

  async roleStubsCount(
    query?: Pick<$SparqlObjectSet.Query<RoleStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<RoleStub.$Identifier>(RoleStub, query);
  }

  async service(
    identifier: ServiceStatic.$Identifier,
  ): Promise<purify.Either<Error, Service>> {
    return (
      await this.services({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async serviceIdentifiers(
    query?: $SparqlObjectSet.Query<ServiceStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ServiceStatic.$Identifier[]>> {
    return this.$objectIdentifiers<ServiceStatic.$Identifier>(
      ServiceStatic,
      query,
    );
  }

  async services(
    query?: $SparqlObjectSet.Query<ServiceStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Service>[]> {
    return this.$objects<Service, ServiceStatic.$Identifier>(
      ServiceStatic,
      query,
    );
  }

  async servicesCount(
    query?: Pick<$SparqlObjectSet.Query<ServiceStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ServiceStatic.$Identifier>(ServiceStatic, query);
  }

  async serviceStub(
    identifier: ServiceStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ServiceStub>> {
    return (
      await this.serviceStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async serviceStubIdentifiers(
    query?: $SparqlObjectSet.Query<ServiceStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ServiceStubStatic.$Identifier[]>> {
    return this.$objectIdentifiers<ServiceStubStatic.$Identifier>(
      ServiceStubStatic,
      query,
    );
  }

  async serviceStubs(
    query?: $SparqlObjectSet.Query<ServiceStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ServiceStub>[]> {
    return this.$objects<ServiceStub, ServiceStubStatic.$Identifier>(
      ServiceStubStatic,
      query,
    );
  }

  async serviceStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<ServiceStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ServiceStubStatic.$Identifier>(
      ServiceStubStatic,
      query,
    );
  }

  async structuredValue(
    identifier: StructuredValueStatic.$Identifier,
  ): Promise<purify.Either<Error, StructuredValue>> {
    return (
      await this.structuredValues({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async structuredValueIdentifiers(
    query?: $SparqlObjectSet.Query<StructuredValueStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly StructuredValueStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<StructuredValueStatic.$Identifier>(
      StructuredValueStatic,
      query,
    );
  }

  async structuredValues(
    query?: $SparqlObjectSet.Query<StructuredValueStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, StructuredValue>[]> {
    return this.$objects<StructuredValue, StructuredValueStatic.$Identifier>(
      StructuredValueStatic,
      query,
    );
  }

  async structuredValuesCount(
    query?: Pick<
      $SparqlObjectSet.Query<StructuredValueStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<StructuredValueStatic.$Identifier>(
      StructuredValueStatic,
      query,
    );
  }

  async structuredValueStub(
    identifier: StructuredValueStubStatic.$Identifier,
  ): Promise<purify.Either<Error, StructuredValueStub>> {
    return (
      await this.structuredValueStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async structuredValueStubIdentifiers(
    query?: $SparqlObjectSet.Query<StructuredValueStubStatic.$Identifier>,
  ): Promise<
    purify.Either<Error, readonly StructuredValueStubStatic.$Identifier[]>
  > {
    return this.$objectIdentifiers<StructuredValueStubStatic.$Identifier>(
      StructuredValueStubStatic,
      query,
    );
  }

  async structuredValueStubs(
    query?: $SparqlObjectSet.Query<StructuredValueStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, StructuredValueStub>[]> {
    return this.$objects<
      StructuredValueStub,
      StructuredValueStubStatic.$Identifier
    >(StructuredValueStubStatic, query);
  }

  async structuredValueStubsCount(
    query?: Pick<
      $SparqlObjectSet.Query<StructuredValueStubStatic.$Identifier>,
      "where"
    >,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<StructuredValueStubStatic.$Identifier>(
      StructuredValueStubStatic,
      query,
    );
  }

  async textObject(
    identifier: TextObject.$Identifier,
  ): Promise<purify.Either<Error, TextObject>> {
    return (
      await this.textObjects({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async textObjectIdentifiers(
    query?: $SparqlObjectSet.Query<TextObject.$Identifier>,
  ): Promise<purify.Either<Error, readonly TextObject.$Identifier[]>> {
    return this.$objectIdentifiers<TextObject.$Identifier>(TextObject, query);
  }

  async textObjects(
    query?: $SparqlObjectSet.Query<TextObject.$Identifier>,
  ): Promise<readonly purify.Either<Error, TextObject>[]> {
    return this.$objects<TextObject, TextObject.$Identifier>(TextObject, query);
  }

  async textObjectsCount(
    query?: Pick<$SparqlObjectSet.Query<TextObject.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<TextObject.$Identifier>(TextObject, query);
  }

  async textObjectStub(
    identifier: TextObjectStub.$Identifier,
  ): Promise<purify.Either<Error, TextObjectStub>> {
    return (
      await this.textObjectStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async textObjectStubIdentifiers(
    query?: $SparqlObjectSet.Query<TextObjectStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly TextObjectStub.$Identifier[]>> {
    return this.$objectIdentifiers<TextObjectStub.$Identifier>(
      TextObjectStub,
      query,
    );
  }

  async textObjectStubs(
    query?: $SparqlObjectSet.Query<TextObjectStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, TextObjectStub>[]> {
    return this.$objects<TextObjectStub, TextObjectStub.$Identifier>(
      TextObjectStub,
      query,
    );
  }

  async textObjectStubsCount(
    query?: Pick<$SparqlObjectSet.Query<TextObjectStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<TextObjectStub.$Identifier>(
      TextObjectStub,
      query,
    );
  }

  async thing(
    identifier: ThingStatic.$Identifier,
  ): Promise<purify.Either<Error, Thing>> {
    return (
      await this.things({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async thingIdentifiers(
    query?: $SparqlObjectSet.Query<ThingStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ThingStatic.$Identifier[]>> {
    return this.$objectIdentifiers<ThingStatic.$Identifier>(ThingStatic, query);
  }

  async things(
    query?: $SparqlObjectSet.Query<ThingStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, Thing>[]> {
    return this.$objects<Thing, ThingStatic.$Identifier>(ThingStatic, query);
  }

  async thingsCount(
    query?: Pick<$SparqlObjectSet.Query<ThingStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ThingStatic.$Identifier>(ThingStatic, query);
  }

  async thingStub(
    identifier: ThingStubStatic.$Identifier,
  ): Promise<purify.Either<Error, ThingStub>> {
    return (
      await this.thingStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async thingStubIdentifiers(
    query?: $SparqlObjectSet.Query<ThingStubStatic.$Identifier>,
  ): Promise<purify.Either<Error, readonly ThingStubStatic.$Identifier[]>> {
    return this.$objectIdentifiers<ThingStubStatic.$Identifier>(
      ThingStubStatic,
      query,
    );
  }

  async thingStubs(
    query?: $SparqlObjectSet.Query<ThingStubStatic.$Identifier>,
  ): Promise<readonly purify.Either<Error, ThingStub>[]> {
    return this.$objects<ThingStub, ThingStubStatic.$Identifier>(
      ThingStubStatic,
      query,
    );
  }

  async thingStubsCount(
    query?: Pick<$SparqlObjectSet.Query<ThingStubStatic.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<ThingStubStatic.$Identifier>(
      ThingStubStatic,
      query,
    );
  }

  async voteAction(
    identifier: VoteAction.$Identifier,
  ): Promise<purify.Either<Error, VoteAction>> {
    return (
      await this.voteActions({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async voteActionIdentifiers(
    query?: $SparqlObjectSet.Query<VoteAction.$Identifier>,
  ): Promise<purify.Either<Error, readonly VoteAction.$Identifier[]>> {
    return this.$objectIdentifiers<VoteAction.$Identifier>(VoteAction, query);
  }

  async voteActions(
    query?: $SparqlObjectSet.Query<VoteAction.$Identifier>,
  ): Promise<readonly purify.Either<Error, VoteAction>[]> {
    return this.$objects<VoteAction, VoteAction.$Identifier>(VoteAction, query);
  }

  async voteActionsCount(
    query?: Pick<$SparqlObjectSet.Query<VoteAction.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<VoteAction.$Identifier>(VoteAction, query);
  }

  async voteActionStub(
    identifier: VoteActionStub.$Identifier,
  ): Promise<purify.Either<Error, VoteActionStub>> {
    return (
      await this.voteActionStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async voteActionStubIdentifiers(
    query?: $SparqlObjectSet.Query<VoteActionStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly VoteActionStub.$Identifier[]>> {
    return this.$objectIdentifiers<VoteActionStub.$Identifier>(
      VoteActionStub,
      query,
    );
  }

  async voteActionStubs(
    query?: $SparqlObjectSet.Query<VoteActionStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, VoteActionStub>[]> {
    return this.$objects<VoteActionStub, VoteActionStub.$Identifier>(
      VoteActionStub,
      query,
    );
  }

  async voteActionStubsCount(
    query?: Pick<$SparqlObjectSet.Query<VoteActionStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<VoteActionStub.$Identifier>(
      VoteActionStub,
      query,
    );
  }

  async agentStub(
    identifier: AgentStub.$Identifier,
  ): Promise<purify.Either<Error, AgentStub>> {
    return (
      await this.agentStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async agentStubIdentifiers(
    query?: $SparqlObjectSet.Query<AgentStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly AgentStub.$Identifier[]>> {
    return this.$objectIdentifiers<AgentStub.$Identifier>(AgentStub, query);
  }

  async agentStubs(
    query?: $SparqlObjectSet.Query<AgentStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, AgentStub>[]> {
    return this.$objects<AgentStub, AgentStub.$Identifier>(AgentStub, query);
  }

  async agentStubsCount(
    query?: Pick<$SparqlObjectSet.Query<AgentStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<AgentStub.$Identifier>(AgentStub, query);
  }

  async musicArtistStub(
    identifier: MusicArtistStub.$Identifier,
  ): Promise<purify.Either<Error, MusicArtistStub>> {
    return (
      await this.musicArtistStubs({
        where: { identifiers: [identifier], type: "identifiers" },
      })
    )[0];
  }

  async musicArtistStubIdentifiers(
    query?: $SparqlObjectSet.Query<MusicArtistStub.$Identifier>,
  ): Promise<purify.Either<Error, readonly MusicArtistStub.$Identifier[]>> {
    return this.$objectIdentifiers<MusicArtistStub.$Identifier>(
      MusicArtistStub,
      query,
    );
  }

  async musicArtistStubs(
    query?: $SparqlObjectSet.Query<MusicArtistStub.$Identifier>,
  ): Promise<readonly purify.Either<Error, MusicArtistStub>[]> {
    return this.$objects<MusicArtistStub, MusicArtistStub.$Identifier>(
      MusicArtistStub,
      query,
    );
  }

  async musicArtistStubsCount(
    query?: Pick<$SparqlObjectSet.Query<MusicArtistStub.$Identifier>, "where">,
  ): Promise<purify.Either<Error, number>> {
    return this.$objectsCount<MusicArtistStub.$Identifier>(
      MusicArtistStub,
      query,
    );
  }

  protected $mapBindingsToCount(
    bindings: readonly Record<
      string,
      rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
    >[],
    variable: string,
  ): purify.Either<Error, number> {
    if (bindings.length === 0) {
      return purify.Left(new Error("empty result rows"));
    }
    if (bindings.length > 1) {
      return purify.Left(new Error("more than one result row"));
    }
    const count = bindings[0][variable];
    if (typeof count === "undefined") {
      return purify.Left(new Error("no 'count' variable in result row"));
    }
    if (count.termType !== "Literal") {
      return purify.Left(new Error("'count' variable is not a Literal"));
    }
    const parsedCount = Number.parseInt(count.value);
    if (Number.isNaN(parsedCount)) {
      return purify.Left(new Error("'count' variable is NaN"));
    }
    return purify.Either.of(parsedCount);
  }

  protected $mapBindingsToIdentifiers(
    bindings: readonly Record<
      string,
      rdfjs.BlankNode | rdfjs.Literal | rdfjs.NamedNode
    >[],
    variable: string,
  ): readonly rdfjs.NamedNode[] {
    const identifiers: rdfjs.NamedNode[] = [];
    for (const bindings_ of bindings) {
      const identifier = bindings_[variable];
      if (
        typeof identifier !== "undefined" &&
        identifier.termType === "NamedNode"
      ) {
        identifiers.push(identifier);
      }
    }
    return identifiers;
  }

  protected async $objectIdentifiers<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectIdentifierT>,
  ): Promise<purify.Either<Error, readonly ObjectIdentifierT[]>> {
    const limit = query?.limit ?? Number.MAX_SAFE_INTEGER;
    if (limit <= 0) {
      return purify.Either.of([]);
    }

    let offset = query?.offset ?? 0;
    if (offset < 0) {
      offset = 0;
    }

    const wherePatterns = this.$wherePatterns(objectType, query?.where).filter(
      (pattern) => pattern.type !== "optional",
    );
    if (wherePatterns.length === 0) {
      return purify.Left(
        new Error("no required SPARQL WHERE patterns for identifiers"),
      );
    }

    const selectQueryString = this.$sparqlGenerator.stringify({
      distinct: true,
      limit: limit < Number.MAX_SAFE_INTEGER ? limit : undefined,
      offset,
      order: query?.order
        ? query.order(this.$objectVariable).concat()
        : [{ expression: this.$objectVariable }],
      prefixes: {},
      queryType: "SELECT",
      type: "query",
      variables: [this.$objectVariable],
      where: wherePatterns,
    });

    return purify.EitherAsync(
      async () =>
        this.$mapBindingsToIdentifiers(
          await this.$sparqlClient.queryBindings(selectQueryString),
          this.$objectVariable.value,
        ) as readonly ObjectIdentifierT[],
    );
  }

  async $objects<
    ObjectT,
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $fromRdf: (parameters: {
        resource: rdfjsResource.Resource;
      }) => purify.Either<rdfjsResource.Resource.ValueError, ObjectT>;
      $sparqlConstructQueryString: (
        parameters?: { subject?: sparqljs.Triple["subject"] } & Omit<
          sparqljs.ConstructQuery,
          "prefixes" | "queryType" | "type"
        > &
          sparqljs.GeneratorOptions,
      ) => string;
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectIdentifierT>,
  ): Promise<readonly purify.Either<Error, ObjectT>[]> {
    const identifiersEither = await this.$objectIdentifiers<ObjectIdentifierT>(
      objectType,
      query,
    );
    if (identifiersEither.isLeft()) {
      return [identifiersEither];
    }
    const identifiers = identifiersEither.unsafeCoerce();
    if (identifiers.length === 0) {
      return [];
    }

    const constructQueryString = objectType.$sparqlConstructQueryString({
      subject: this.$objectVariable,
      where: [
        {
          type: "values" as const,
          values: identifiers.map((identifier) => {
            const valuePatternRow: sparqljs.ValuePatternRow = {};
            valuePatternRow["?object"] = identifier as rdfjs.NamedNode;
            return valuePatternRow;
          }),
        },
      ],
    });

    let quads: readonly rdfjs.Quad[];
    try {
      quads = await this.$sparqlClient.queryQuads(constructQueryString);
    } catch (e) {
      const left = purify.Left<Error, ObjectT>(e as Error);
      return identifiers.map(() => left);
    }

    const dataset: rdfjs.DatasetCore = new N3.Store(quads.concat());

    return identifiers.map((identifier) =>
      objectType.$fromRdf({
        resource: new rdfjsResource.Resource<rdfjs.NamedNode>({
          dataset,
          identifier: identifier as rdfjs.NamedNode,
        }),
      }),
    );
  }

  protected async $objectsCount<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    query?: $SparqlObjectSet.Query<ObjectIdentifierT>,
  ): Promise<purify.Either<Error, number>> {
    const wherePatterns = this.$wherePatterns(objectType, query?.where).filter(
      (pattern) => pattern.type !== "optional",
    );
    if (wherePatterns.length === 0) {
      return purify.Left(
        new Error("no required SPARQL WHERE patterns for count"),
      );
    }

    const selectQueryString = this.$sparqlGenerator.stringify({
      prefixes: {},
      queryType: "SELECT",
      type: "query",
      variables: [
        {
          expression: {
            aggregation: "COUNT",
            distinct: true,
            expression: this.$objectVariable,
            type: "aggregate",
          },
          variable: this.$countVariable,
        },
      ],
      where: wherePatterns,
    });

    return purify.EitherAsync(async ({ liftEither }) =>
      liftEither(
        this.$mapBindingsToCount(
          await this.$sparqlClient.queryBindings(selectQueryString),
          this.$countVariable.value,
        ),
      ),
    );
  }

  protected $wherePatterns<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  >(
    objectType: {
      $sparqlWherePatterns: (parameters?: {
        subject?: sparqljs.Triple["subject"];
      }) => readonly sparqljs.Pattern[];
    },
    where?: $SparqlObjectSet.Where<ObjectIdentifierT>,
  ): sparqljs.Pattern[] {
    const patterns: sparqljs.Pattern[] = [];

    // Patterns should be most to least specific.

    if (where) {
      switch (where.type) {
        case "identifiers":
          patterns.push({
            type: "values" as const,
            values: where.identifiers.map((identifier) => {
              const valuePatternRow: sparqljs.ValuePatternRow = {};
              valuePatternRow["?object"] = identifier as rdfjs.NamedNode;
              return valuePatternRow;
            }),
          });
          break;
        case "patterns":
          patterns.push(...where.patterns(this.$objectVariable));
          break;
      }
    }

    patterns.push(
      ...objectType.$sparqlWherePatterns({ subject: this.$objectVariable }),
    );

    return patterns;
  }
}

export namespace $SparqlObjectSet {
  export type Query<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > = Omit<$ObjectSet.Query<ObjectIdentifierT>, "where"> & {
    readonly order?: (
      objectVariable: rdfjs.Variable,
    ) => readonly sparqljs.Ordering[];
    readonly where?: Where<ObjectIdentifierT>;
  };
  export type Where<
    ObjectIdentifierT extends rdfjs.BlankNode | rdfjs.NamedNode,
  > =
    | $ObjectSet.Where<ObjectIdentifierT>
    | {
        readonly patterns: (
          objectVariable: rdfjs.Variable,
        ) => readonly sparqljs.Pattern[];
        readonly type: "patterns";
      };
}
